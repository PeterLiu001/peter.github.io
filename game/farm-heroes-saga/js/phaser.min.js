(function() {
    var c = c || {};
    c.WEBGL_RENDERER = 0;
    c.CANVAS_RENDERER = 1;
    c.VERSION = "v1.5.2";
    c.blendModes = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
    };
    c.scaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
    };
    c.INTERACTION_FREQUENCY = 30;
    c.AUTO_PREVENT_DEFAULT = !0;
    c.RAD_TO_DEG = 180 / Math.PI;
    c.DEG_TO_RAD = Math.PI / 180;
    c.Point = function(a, b) {
        this.x = a || 0;
        this.y = b || 0
    };
    c.Point.prototype.clone =
        function() {
            return new c.Point(this.x, this.y)
        };
    c.Point.prototype.constructor = c.Point;
    c.Point.prototype.set = function(a, b) {
        this.x = a || 0;
        this.y = b || (0 !== b ? this.x : 0)
    };
    c.Rectangle = function(a, b, c, h) {
        this.x = a || 0;
        this.y = b || 0;
        this.width = c || 0;
        this.height = h || 0
    };
    c.Rectangle.prototype.clone = function() {
        return new c.Rectangle(this.x, this.y, this.width, this.height)
    };
    c.Rectangle.prototype.contains = function(a, b) {
        if (0 >= this.width || 0 >= this.height) return !1;
        var c = this.x;
        return a >= c && a <= c + this.width && (c = this.y, b >= c && b <= c + this.height) ?
            !0 : !1
    };
    c.Rectangle.prototype.constructor = c.Rectangle;
    c.EmptyRectangle = new c.Rectangle(0, 0, 0, 0);
    c.Polygon = function(a) {
        a instanceof Array || (a = Array.prototype.slice.call(arguments));
        if ("number" === typeof a[0]) {
            for (var b = [], f = 0, h = a.length; f < h; f += 2) b.push(new c.Point(a[f], a[f + 1]));
            a = b
        }
        this.points = a
    };
    c.Polygon.prototype.clone = function() {
        for (var a = [], b = 0; b < this.points.length; b++) a.push(this.points[b].clone());
        return new c.Polygon(a)
    };
    c.Polygon.prototype.contains = function(a, b) {
        for (var c = !1, h = 0, k = this.points.length -
                1; h < this.points.length; k = h++) {
            var p = this.points[h].x,
                g = this.points[h].y,
                m = this.points[k].x,
                k = this.points[k].y;
            g > b !== k > b && a < (m - p) * (b - g) / (k - g) + p && (c = !c)
        }
        return c
    };
    c.Polygon.prototype.constructor = c.Polygon;
    c.Circle = function(a, b, c) {
        this.x = a || 0;
        this.y = b || 0;
        this.radius = c || 0
    };
    c.Circle.prototype.clone = function() {
        return new c.Circle(this.x, this.y, this.radius)
    };
    c.Circle.prototype.contains = function(a, b) {
        if (0 >= this.radius) return !1;
        var c = this.x - a,
            h = this.y - b,
            k = this.radius * this.radius;
        return c * c + h * h <= k
    };
    c.Circle.prototype.constructor =
        c.Circle;
    c.Ellipse = function(a, b, c, h) {
        this.x = a || 0;
        this.y = b || 0;
        this.width = c || 0;
        this.height = h || 0
    };
    c.Ellipse.prototype.clone = function() {
        return new c.Ellipse(this.x, this.y, this.width, this.height)
    };
    c.Ellipse.prototype.contains = function(a, b) {
        if (0 >= this.width || 0 >= this.height) return !1;
        var c = (a - this.x) / this.width,
            h = (b - this.y) / this.height;
        return 1 >= c * c + h * h
    };
    c.Ellipse.prototype.getBounds = function() {
        return new c.Rectangle(this.x, this.y, this.width, this.height)
    };
    c.Ellipse.prototype.constructor = c.Ellipse;
    c.determineMatrixArrayType =
        function() {
            return "undefined" !== typeof Float32Array ? Float32Array : Array
        };
    c.Matrix2 = c.determineMatrixArrayType();
    c.Matrix = function() {
        this.a = 1;
        this.c = this.b = 0;
        this.d = 1;
        this.ty = this.tx = 0
    };
    c.Matrix.prototype.fromArray = function(a) {
        this.a = a[0];
        this.b = a[1];
        this.c = a[3];
        this.d = a[4];
        this.tx = a[2];
        this.ty = a[5]
    };
    c.Matrix.prototype.toArray = function(a) {
        this.array || (this.array = new Float32Array(9));
        var b = this.array;
        a ? (this.array[0] = this.a, this.array[1] = this.c, this.array[2] = 0, this.array[3] = this.b, this.array[4] = this.d,
            this.array[5] = 0, this.array[6] = this.tx, this.array[7] = this.ty) : (this.array[0] = this.a, this.array[1] = this.b, this.array[2] = this.tx, this.array[3] = this.c, this.array[4] = this.d, this.array[5] = this.ty, this.array[6] = 0, this.array[7] = 0);
        this.array[8] = 1;
        return b
    };
    c.identityMatrix = new c.Matrix;
    c.DisplayObject = function() {
        this.position = new c.Point;
        this.scale = new c.Point(1, 1);
        this.pivot = new c.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = !0;
        this.hitArea = null;
        this.renderable = this.buttonMode = !1;
        this.stage = this.parent =
            null;
        this.worldAlpha = 1;
        this._interactive = !1;
        this.defaultCursor = "pointer";
        this.worldTransform = new c.Matrix;
        this.color = [];
        this.dynamic = !0;
        this._sr = 0;
        this._cr = 1;
        this.filterArea = null;
        this._bounds = new c.Rectangle(0, 0, 1, 1);
        this._mask = this._currentBounds = null;
        this._cacheIsDirty = this._cacheAsBitmap = !1
    };
    c.DisplayObject.prototype.constructor = c.DisplayObject;
    c.DisplayObject.prototype.setInteractive = function(a) {
        this.interactive = a
    };
    Object.defineProperty(c.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive
        },
        set: function(a) {
            this._interactive = a;
            this.stage && (this.stage.dirty = !0)
        }
    });
    Object.defineProperty(c.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var a = this;
            do {
                if (!a.visible) return !1;
                a = a.parent
            } while (a);
            return !0
        }
    });
    Object.defineProperty(c.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask
        },
        set: function(a) {
            this._mask && (this._mask.isMask = !1);
            if (this._mask = a) this._mask.isMask = !0
        }
    });
    Object.defineProperty(c.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters
        },
        set: function(a) {
            if (a) {
                for (var b = [], c = 0; c < a.length; c++)
                    for (var h = a[c].passes, k = 0; k < h.length; k++) b.push(h[k]);
                this._filterBlock = {
                    target: this,
                    filterPasses: b
                }
            }
            this._filters = a
        }
    });
    Object.defineProperty(c.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(a) {
            this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = a)
        }
    });
    c.DisplayObject.prototype.updateTransform = function() {
        this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr =
            Math.sin(this.rotation), this._cr = Math.cos(this.rotation));
        var a = this.parent.worldTransform,
            b = this.worldTransform,
            c = this.pivot.x,
            h = this.pivot.y,
            k = this._cr * this.scale.x,
            p = -this._sr * this.scale.y,
            g = this._sr * this.scale.x,
            m = this._cr * this.scale.y,
            n = this.position.x - k * c - h * p,
            c = this.position.y - m * h - c * g,
            h = a.a,
            q = a.b,
            s = a.c,
            v = a.d;
        b.a = h * k + q * g;
        b.b = h * p + q * m;
        b.tx = h * n + q * c + a.tx;
        b.c = s * k + v * g;
        b.d = s * p + v * m;
        b.ty = s * n + v * c + a.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    };
    c.DisplayObject.prototype.getBounds = function(a) {
        return c.EmptyRectangle
    };
    c.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(c.identityMatrix)
    };
    c.DisplayObject.prototype.setStageReference = function(a) {
        this.stage = a;
        this._interactive && (this.stage.dirty = !0)
    };
    c.DisplayObject.prototype.generateTexture = function(a) {
        var b = this.getLocalBounds();
        a = new c.RenderTexture(b.width | 0, b.height | 0, a);
        a.render(this, new c.Point(-b.x, -b.y));
        return a
    };
    c.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite()
    };
    c.DisplayObject.prototype._renderCachedSprite =
        function(a) {
            a.gl ? c.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : c.Sprite.prototype._renderCanvas.call(this._cachedSprite, a)
        };
    c.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = !1;
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.texture.resize(a.width | 0, a.height | 0);
        else {
            var b = new c.RenderTexture(a.width | 0, a.height | 0);
            this._cachedSprite = new c.Sprite(b);
            this._cachedSprite.worldTransform = this.worldTransform
        }
        b = this._filters;
        this._filters = null;
        this._cachedSprite.filters = b;
        this._cachedSprite.texture.render(this, new c.Point(-a.x, -a.y));
        this._cachedSprite.anchor.x = -(a.x / a.width);
        this._cachedSprite.anchor.y = -(a.y / a.height);
        this._filters = b;
        this._cacheAsBitmap = !0
    };
    c.DisplayObject.prototype._destroyCachedSprite = function() {
        this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
    };
    c.DisplayObject.prototype._renderWebGL = function(a) {};
    c.DisplayObject.prototype._renderCanvas = function(a) {};
    Object.defineProperty(c.DisplayObject.prototype,
        "x", {
            get: function() {
                return this.position.x
            },
            set: function(a) {
                this.position.x = a
            }
        });
    Object.defineProperty(c.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(a) {
            this.position.y = a
        }
    });
    c.DisplayObjectContainer = function() {
        c.DisplayObject.call(this);
        this.children = []
    };
    c.DisplayObjectContainer.prototype = Object.create(c.DisplayObject.prototype);
    c.DisplayObjectContainer.prototype.constructor = c.DisplayObjectContainer;
    c.DisplayObjectContainer.prototype.addChild = function(a) {
        this.addChildAt(a,
            this.children.length)
    };
    c.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
        if (0 <= b && b <= this.children.length) a.parent && a.parent.removeChild(a), a.parent = this, this.children.splice(b, 0, a), this.stage && a.setStageReference(this.stage);
        else throw Error(a + " The index " + b + " supplied is out of bounds " + this.children.length);
    };
    c.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
        if (a !== b) {
            var c = this.children.indexOf(a),
                h = this.children.indexOf(b);
            if (0 > c || 0 > h) throw Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[c] = b;
            this.children[h] = a
        }
    };
    c.DisplayObjectContainer.prototype.getChildAt = function(a) {
        if (0 <= a && a < this.children.length) return this.children[a];
        throw Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
    };
    c.DisplayObjectContainer.prototype.removeChild = function(a) {
        return this.removeChildAt(this.children.indexOf(a))
    };
    c.DisplayObjectContainer.prototype.removeChildAt = function(a) {
        var b = this.getChildAt(a);
        this.stage && b.removeStageReference();
        b.parent = void 0;
        this.children.splice(a, 1);
        return b
    };
    c.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
        var c = a || 0,
            h = "number" === typeof b ? b : this.children.length,
            k = h - c;
        if (0 < k && k <= h) {
            c = this.children.splice(c, k);
            for (h = 0; h < c.length; h++) k = c[h], this.stage && k.removeStageReference(), k.parent = void 0;
            return c
        }
        throw Error("Range Error, numeric values are outside the acceptable range");
    };
    c.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (c.DisplayObject.prototype.updateTransform.call(this), !this._cacheAsBitmap))
            for (var a = 0, b = this.children.length; a < b; a++) this.children[a].updateTransform()
    };
    c.DisplayObjectContainer.prototype.getBounds = function(a) {
        if (0 === this.children.length) return c.EmptyRectangle;
        if (a) {
            var b = this.worldTransform;
            this.worldTransform = a;
            this.updateTransform();
            this.worldTransform = b
        }
        for (var f = b = Infinity, h = -Infinity, k = -Infinity, p, g, m = !1, n = 0, q = this.children.length; n < q; n++) this.children[n].visible && (m = !0, p = this.children[n].getBounds(a), b = b < p.x ? b : p.x, f = f < p.y ? f : p.y, g = p.width + p.x,
            p = p.height + p.y, h = h > g ? h : g, k = k > p ? k : p);
        if (!m) return c.EmptyRectangle;
        a = this._bounds;
        a.x = b;
        a.y = f;
        a.width = h - b;
        a.height = k - f;
        return a
    };
    c.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = c.identityMatrix;
        for (var b = 0, f = this.children.length; b < f; b++) this.children[b].updateTransform();
        b = this.getBounds();
        this.worldTransform = a;
        return b
    };
    c.DisplayObjectContainer.prototype.setStageReference = function(a) {
        this.stage = a;
        this._interactive && (this.stage.dirty = !0);
        for (var b =
                0, c = this.children.length; b < c; b++) this.children[b].setStageReference(a)
    };
    c.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].removeStageReference();
        this._interactive && (this.stage.dirty = !0);
        this.stage = null
    };
    c.DisplayObjectContainer.prototype._renderWebGL = function(a) {
        if (this.visible && !(0 >= this.alpha))
            if (this._cacheAsBitmap) this._renderCachedSprite(a);
            else {
                var b, c;
                if (this._mask || this._filters) {
                    this._mask && (a.spriteBatch.stop(),
                        a.maskManager.pushMask(this.mask, a), a.spriteBatch.start());
                    this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock));
                    b = 0;
                    for (c = this.children.length; b < c; b++) this.children[b]._renderWebGL(a);
                    a.spriteBatch.stop();
                    this._filters && a.filterManager.popFilter();
                    this._mask && a.maskManager.popMask(a);
                    a.spriteBatch.start()
                } else {
                    b = 0;
                    for (c = this.children.length; b < c; b++) this.children[b]._renderWebGL(a)
                }
            }
    };
    c.DisplayObjectContainer.prototype._renderCanvas = function(a) {
        if (!(!1 === this.visible ||
                0 === this.alpha))
            if (this._cacheAsBitmap) this._renderCachedSprite(a);
            else {
                this._mask && a.maskManager.pushMask(this._mask, a.context);
                for (var b = 0, c = this.children.length; b < c; b++) this.children[b]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a.context)
            }
    };
    c.Sprite = function(a) {
        c.DisplayObjectContainer.call(this);
        this.anchor = new c.Point;
        this.texture = a;
        this._height = this._width = 0;
        this.tint = 16777215;
        this.blendMode = c.blendModes.NORMAL;
        if (a.baseTexture.hasLoaded) this.onTextureUpdate();
        else this.onTextureUpdateBind =
            this.onTextureUpdate.bind(this), this.texture.addEventListener("update", this.onTextureUpdateBind);
        this.renderable = !0
    };
    c.Sprite.prototype = Object.create(c.DisplayObjectContainer.prototype);
    c.Sprite.prototype.constructor = c.Sprite;
    Object.defineProperty(c.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width;
            this._width = a
        }
    });
    Object.defineProperty(c.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height;
            this._height = a
        }
    });
    c.Sprite.prototype.setTexture = function(a) {
        this.texture.baseTexture !== a.baseTexture && (this.textureChange = !0);
        this.texture = a;
        this.cachedTint = 16777215;
        this.updateFrame = !0
    };
    c.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width);
        this._height && (this.scale.y = this._height / this.texture.frame.height);
        this.updateFrame = !0
    };
    c.Sprite.prototype.getBounds = function(a) {
        var b = this.texture.frame.width,
            c = this.texture.frame.height,
            h = b * (1 - this.anchor.x),
            k = b * -this.anchor.x,
            p = c * (1 - this.anchor.y),
            g = c * -this.anchor.y;
        a = a || this.worldTransform;
        var m = a.a,
            n = a.c,
            q = a.b,
            s = a.d,
            v = a.tx,
            t = a.ty;
        a = m * k + q * g + v;
        var c = s * g + n * k + t,
            b = m * h + q * g + v,
            g = s * g + n * h + t,
            u = m * h + q * p + v,
            h = s * p + n * h + t,
            m = m * k + q * p + v,
            k = s * p + n * k + t,
            n = p = -Infinity,
            q = s = Infinity,
            s = a < s ? a : s,
            s = b < s ? b : s,
            s = u < s ? u : s,
            s = m < s ? m : s,
            q = c < q ? c : q,
            q = g < q ? g : q,
            q = h < q ? h : q,
            q = k < q ? k : q,
            p = a > p ? a : p,
            p = b > p ? b : p,
            p = u > p ? u : p,
            n = c > n ? c : n,
            n = g > n ? g : n,
            n = h > n ? h : n;
        a = this._bounds;
        a.x = s;
        a.width = (m > p ? m : p) - s;
        a.y = q;
        a.height = (k >
            n ? k : n) - q;
        return this._currentBounds = a
    };
    c.Sprite.prototype._renderWebGL = function(a) {
        if (this.visible && !(0 >= this.alpha)) {
            var b, c;
            if (this._mask || this._filters) {
                var h = a.spriteBatch;
                this._mask && (h.stop(), a.maskManager.pushMask(this.mask, a), h.start());
                this._filters && (h.flush(), a.filterManager.pushFilter(this._filterBlock));
                h.render(this);
                b = 0;
                for (c = this.children.length; b < c; b++) this.children[b]._renderWebGL(a);
                h.stop();
                this._filters && a.filterManager.popFilter();
                this._mask && a.maskManager.popMask(a);
                h.start()
            } else {
                a.spriteBatch.render(this);
                b = 0;
                for (c = this.children.length; b < c; b++) this.children[b]._renderWebGL(a)
            }
        }
    };
    c.Sprite.prototype._renderCanvas = function(a) {
        if (!(!1 === this.visible || 0 === this.alpha)) {
            var b = this.texture.frame,
                f = a.context,
                h = this.texture;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, f.globalCompositeOperation = c.blendModesCanvas[a.currentBlendMode]);
            this._mask && a.maskManager.pushMask(this._mask, a.context);
            if (b && b.width && b.height && h.baseTexture.source) {
                f.globalAlpha = this.worldAlpha;
                var k = this.worldTransform;
                a.roundPixels ? f.setTransform(k.a, k.c, k.b, k.d, k.tx | 0, k.ty | 0) : f.setTransform(k.a, k.c, k.b, k.d, k.tx, k.ty);
                a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, f[a.smoothProperty] = a.scaleMode === c.scaleModes.LINEAR);
                if (16777215 !== this.tint) {
                    if (this.cachedTint !== this.tint) {
                        if (!h.baseTexture.hasLoaded) return;
                        this.cachedTint = this.tint;
                        this.tintedTexture = c.CanvasTinter.getTintedTexture(this, this.tint)
                    }
                    f.drawImage(this.tintedTexture, 0, 0, b.width,
                        b.height, this.anchor.x * -b.width, this.anchor.y * -b.height, b.width, b.height)
                } else h.trim ? (h = h.trim, f.drawImage(this.texture.baseTexture.source, b.x, b.y, b.width, b.height, h.x - this.anchor.x * h.width, h.y - this.anchor.y * h.height, b.width, b.height)) : f.drawImage(this.texture.baseTexture.source, b.x, b.y, b.width, b.height, this.anchor.x * -b.width, this.anchor.y * -b.height, b.width, b.height)
            }
            b = 0;
            for (f = this.children.length; b < f; b++) this.children[b]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a.context)
        }
    };
    c.Sprite.fromFrame =
        function(a) {
            var b = c.TextureCache[a];
            if (!b) throw Error('The frameId "' + a + '" does not exist in the texture cache' + this);
            return new c.Sprite(b)
        };
    c.Sprite.fromImage = function(a, b, f) {
        a = c.Texture.fromImage(a, b, f);
        return new c.Sprite(a)
    };
    c.SpriteBatch = function(a) {
        c.DisplayObjectContainer.call(this);
        this.textureThing = a;
        this.ready = !1
    };
    c.SpriteBatch.prototype = Object.create(c.DisplayObjectContainer.prototype);
    c.SpriteBatch.constructor = c.SpriteBatch;
    c.SpriteBatch.prototype.initWebGL = function(a) {
        this.fastSpriteBatch =
            new c.WebGLFastSpriteBatch(a);
        this.ready = !0
    };
    c.SpriteBatch.prototype.updateTransform = function() {
        c.DisplayObject.prototype.updateTransform.call(this)
    };
    c.SpriteBatch.prototype._renderWebGL = function(a) {
        this.visible && (!(0 >= this.alpha) && this.children.length) && (this.ready || this.initWebGL(a.gl), a.spriteBatch.stop(), a.shaderManager.activateShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), this.fastSpriteBatch.render(this), a.shaderManager.activateShader(a.shaderManager.defaultShader), a.spriteBatch.start())
    };
    c.SpriteBatch.prototype._renderCanvas = function(a) {
        var b = a.context;
        b.globalAlpha = this.worldAlpha;
        c.DisplayObject.prototype.updateTransform.call(this);
        for (var f = this.worldTransform, h = !0, k = 0; k < this.children.length; k++) {
            var p = this.children[k];
            if (p.visible) {
                var g = p.texture,
                    m = g.frame;
                b.globalAlpha = this.worldAlpha * p.alpha;
                if (0 === p.rotation % (2 * Math.PI)) h && (b.setTransform(f.a, f.c, f.b, f.d, f.tx, f.ty), h = !1), b.drawImage(g.baseTexture.source, m.x, m.y, m.width, m.height, p.anchor.x * -m.width * p.scale.x + p.position.x + 0.5 |
                    0, p.anchor.y * -m.height * p.scale.y + p.position.y + 0.5 | 0, m.width * p.scale.x, m.height * p.scale.y);
                else {
                    h || (h = !0);
                    c.DisplayObject.prototype.updateTransform.call(p);
                    var n = p.worldTransform;
                    a.roundPixels ? b.setTransform(n.a, n.c, n.b, n.d, n.tx | 0, n.ty | 0) : b.setTransform(n.a, n.c, n.b, n.d, n.tx, n.ty);
                    b.drawImage(g.baseTexture.source, m.x, m.y, m.width, m.height, p.anchor.x * -m.width + 0.5 | 0, p.anchor.y * -m.height + 0.5 | 0, m.width, m.height)
                }
            }
        }
    };
    c.AbstractFilter = function(a, b) {
        this.passes = [this];
        this.shaders = [];
        this.dirty = !0;
        this.padding =
            0;
        this.uniforms = b || {};
        this.fragmentSrc = a || []
    };
    c.FilterBlock = function() {
        this.renderable = this.visible = !0
    };
    c.Text = function(a, b) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        c.Sprite.call(this, c.Texture.fromCanvas(this.canvas));
        this.setText(a);
        this.setStyle(b);
        this.updateText();
        this.dirty = !1
    };
    c.Text.prototype = Object.create(c.Sprite.prototype);
    c.Text.prototype.constructor = c.Text;
    c.Text.prototype.setStyle = function(a) {
        a = a || {};
        a.font = a.font || "bold 20pt Arial";
        a.fill =
            a.fill || "black";
        a.align = a.align || "left";
        a.stroke = a.stroke || "black";
        a.strokeThickness = a.strokeThickness || 0;
        a.wordWrap = a.wordWrap || !1;
        a.wordWrapWidth = a.wordWrapWidth || 100;
        a.wordWrapWidth = a.wordWrapWidth || 100;
        a.dropShadow = a.dropShadow || !1;
        a.dropShadowAngle = a.dropShadowAngle || Math.PI / 6;
        a.dropShadowDistance = a.dropShadowDistance || 4;
        a.dropShadowColor = a.dropShadowColor || "black";
        this.style = a;
        this.dirty = !0
    };
    c.Text.prototype.setText = function(a) {
        this.text = a.toString() || " ";
        this.dirty = !0
    };
    c.Text.prototype.updateText =
        function() {
            this.context.font = this.style.font;
            var a = this.text;
            this.style.wordWrap && (a = this.wordWrap(this.text));
            for (var a = a.split(/(?:\r\n|\r|\n)/), b = [], c = 0, h = 0; h < a.length; h++) {
                var k = this.context.measureText(a[h]).width;
                b[h] = k;
                c = Math.max(c, k)
            }
            h = c + this.style.strokeThickness;
            this.style.dropShadow && (h += this.style.dropShadowDistance);
            this.canvas.width = h + this.context.lineWidth;
            k = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
            h = k * a.length;
            this.style.dropShadow && (h += this.style.dropShadowDistance);
            this.canvas.height = h;
            navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.context.font = this.style.font;
            this.context.strokeStyle = this.style.stroke;
            this.context.lineWidth = this.style.strokeThickness;
            this.context.textBaseline = "top";
            var p, g;
            if (this.style.dropShadow) {
                this.context.fillStyle = this.style.dropShadowColor;
                for (var m = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance, n = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance, h = 0; h <
                    a.length; h++) p = this.style.strokeThickness / 2, g = this.style.strokeThickness / 2 + h * k, "right" === this.style.align ? p += c - b[h] : "center" === this.style.align && (p += (c - b[h]) / 2), this.style.fill && this.context.fillText(a[h], p + m, g + n)
            }
            this.context.fillStyle = this.style.fill;
            for (h = 0; h < a.length; h++) p = this.style.strokeThickness / 2, g = this.style.strokeThickness / 2 + h * k, "right" === this.style.align ? p += c - b[h] : "center" === this.style.align && (p += (c - b[h]) / 2), this.style.stroke && this.style.strokeThickness && this.context.strokeText(a[h], p,
                g), this.style.fill && this.context.fillText(a[h], p, g);
            this.updateTexture()
        };
    c.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.frame.width = this.canvas.width;
        this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        this.requiresUpdate = !0
    };
    c.Text.prototype._renderWebGL = function(a) {
        this.requiresUpdate && (this.requiresUpdate = !1, c.updateWebGLTexture(this.texture.baseTexture,
            a.gl));
        c.Sprite.prototype._renderWebGL.call(this, a)
    };
    c.Text.prototype.updateTransform = function() {
        this.dirty && (this.updateText(), this.dirty = !1);
        c.Sprite.prototype.updateTransform.call(this)
    };
    c.Text.prototype.determineFontHeight = function(a) {
        var b = c.Text.heightCache[a];
        if (!b) {
            var f = document.getElementsByTagName("body")[0],
                h = document.createElement("div"),
                b = document.createTextNode("M");
            h.appendChild(b);
            h.setAttribute("style", a + ";position:absolute;top:0;left:0");
            f.appendChild(h);
            b = h.offsetHeight;
            c.Text.heightCache[a] =
                b;
            f.removeChild(h)
        }
        return b
    };
    c.Text.prototype.wordWrap = function(a) {
        var b = "";
        a = a.split("\n");
        for (var c = 0; c < a.length; c++) {
            for (var h = this.style.wordWrapWidth, k = a[c].split(" "), p = 0; p < k.length; p++) {
                var g = this.context.measureText(k[p]).width,
                    m = g + this.context.measureText(" ").width;
                0 === p || m > h ? (0 < p && (b += "\n"), b += k[p], h = this.style.wordWrapWidth - g) : (h -= m, b += " " + k[p])
            }
            c < a.length - 1 && (b += "\n")
        }
        return b
    };
    c.Text.prototype.destroy = function(a) {
        a && this.texture.destroy()
    };
    c.Text.heightCache = {};
    c.BitmapText = function(a,
        b) {
        c.DisplayObjectContainer.call(this);
        this._pool = [];
        this.setText(a);
        this.setStyle(b);
        this.updateText();
        this.dirty = !1
    };
    c.BitmapText.prototype = Object.create(c.DisplayObjectContainer.prototype);
    c.BitmapText.prototype.constructor = c.BitmapText;
    c.BitmapText.prototype.setText = function(a) {
        this.text = a || " ";
        this.dirty = !0
    };
    c.BitmapText.prototype.setStyle = function(a) {
        a = a || {};
        a.align = a.align || "left";
        this.style = a;
        var b = a.font.split(" ");
        this.fontName = b[b.length - 1];
        this.fontSize = 2 <= b.length ? parseInt(b[b.length -
            2], 10) : c.BitmapText.fonts[this.fontName].size;
        this.dirty = !0;
        this.tint = a.tint
    };
    c.BitmapText.prototype.updateText = function() {
        for (var a = c.BitmapText.fonts[this.fontName], b = new c.Point, f = null, h = [], k = 0, p = [], g = 0, m = this.fontSize / a.size, n = 0; n < this.text.length; n++) {
            var q = this.text.charCodeAt(n);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(n))) p.push(b.x), k = Math.max(k, b.x), g++, b.x = 0, b.y += a.lineHeight, f = null;
            else {
                var s = a.chars[q];
                s && (f && s[f] && (b.x += s.kerning[f]), h.push({
                    texture: s.texture,
                    line: g,
                    charCode: q,
                    position: new c.Point(b.x +
                        s.xOffset, b.y + s.yOffset)
                }), b.x += s.xAdvance, f = q)
            }
        }
        p.push(b.x);
        k = Math.max(k, b.x);
        f = [];
        for (n = 0; n <= g; n++) q = 0, "right" === this.style.align ? q = k - p[n] : "center" === this.style.align && (q = (k - p[n]) / 2), f.push(q);
        g = this.children.length;
        p = h.length;
        q = this.tint || 16777215;
        for (n = 0; n < p; n++)(s = n < g ? this.children[n] : this._pool.pop()) ? s.setTexture(h[n].texture) : s = new c.Sprite(h[n].texture), s.position.x = (h[n].position.x + f[h[n].line]) * m, s.position.y = h[n].position.y * m, s.scale.x = s.scale.y = m, s.tint = q, s.parent || this.addChild(s);
        for (; this.children.length >
            p;) h = this.getChildAt(this.children.length - 1), this._pool.push(h), this.removeChild(h);
        this.textWidth = k * m;
        this.textHeight = (b.y + a.lineHeight) * m
    };
    c.BitmapText.prototype.updateTransform = function() {
        this.dirty && (this.updateText(), this.dirty = !1);
        c.DisplayObjectContainer.prototype.updateTransform.call(this)
    };
    c.BitmapText.fonts = {};
    c.Stage = function(a) {
        c.DisplayObjectContainer.call(this);
        this.worldTransform = new c.Matrix;
        this.interactive = !0;
        this.interactionManager = new c.InteractionManager(this);
        this.dirty = !0;
        this.stage =
            this;
        this.stage.hitArea = new c.Rectangle(0, 0, 1E5, 1E5);
        this.setBackgroundColor(a)
    };
    c.Stage.prototype = Object.create(c.DisplayObjectContainer.prototype);
    c.Stage.prototype.constructor = c.Stage;
    c.Stage.prototype.setInteractionDelegate = function(a) {
        this.interactionManager.setTargetDomElement(a)
    };
    c.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].updateTransform();
        this.dirty && (this.dirty = !1, this.interactionManager.dirty = !0);
        this.interactive &&
            this.interactionManager.update()
    };
    c.Stage.prototype.setBackgroundColor = function(a) {
        this.backgroundColor = a || 0;
        this.backgroundColorSplit = c.hex2rgb(this.backgroundColor);
        a = this.backgroundColor.toString(16);
        a = "000000".substr(0, 6 - a.length) + a;
        this.backgroundColorString = "#" + a
    };
    c.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global
    };
    for (var g = 0, a = ["ms", "moz", "webkit", "o"], b = 0; b < a.length && !window.requestAnimationFrame; ++b) window.requestAnimationFrame = window[a[b] + "RequestAnimationFrame"],
        window.cancelAnimationFrame = window[a[b] + "CancelAnimationFrame"] || window[a[b] + "CancelRequestAnimationFrame"];
    window.requestAnimationFrame || (window.requestAnimationFrame = function(a) {
        var b = (new Date).getTime(),
            c = Math.max(0, 16 - (b - g)),
            h = window.setTimeout(function() {
                a(b + c)
            }, c);
        g = b + c;
        return h
    });
    window.cancelAnimationFrame || (window.cancelAnimationFrame = function(a) {
        clearTimeout(a)
    });
    window.requestAnimFrame = window.requestAnimationFrame;
    c.hex2rgb = function(a) {
        return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (a & 255) / 255]
    };
    c.rgb2hex = function(a) {
        return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
    };
    "function" !== typeof Function.prototype.bind && (Function.prototype.bind = function() {
        var a = Array.prototype.slice;
        return function(b) {
            function c() {
                var p = k.concat(a.call(arguments));
                h.apply(this instanceof c ? this : b, p)
            }
            var h = this,
                k = a.call(arguments, 1);
            if ("function" !== typeof h) throw new TypeError;
            c.prototype = function l(a) {
                a && (l.prototype = a);
                if (!(this instanceof l)) return new l
            }(h.prototype);
            return c
        }
    }());
    c.AjaxRequest = function() {
        var a = ["Msxml2.XMLHTTP.6.0",
            "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP"
        ];
        if (window.ActiveXObject)
            for (var b = 0; b < a.length; b++) try {
                return new window.ActiveXObject(a[b])
            } catch (c) {} else return window.XMLHttpRequest ? new window.XMLHttpRequest : !1
    };
    c.canUseNewCanvasBlendModes = function() {
        var a = document.createElement("canvas");
        a.width = 1;
        a.height = 1;
        a = a.getContext("2d");
        a.fillStyle = "#000";
        a.fillRect(0, 0, 1, 1);
        a.globalCompositeOperation = "multiply";
        a.fillStyle = "#fff";
        a.fillRect(0, 0, 1, 1);
        return 0 === a.getImageData(0, 0, 1, 1).data[0]
    };
    c.getNextPowerOfTwo =
        function(a) {
            if (0 < a && 0 === (a & a - 1)) return a;
            for (var b = 1; b < a;) b <<= 1;
            return b
        };
    c.EventTarget = function() {
        var a = {};
        this.addEventListener = this.on = function(b, c) {
            void 0 === a[b] && (a[b] = []); - 1 === a[b].indexOf(c) && a[b].push(c)
        };
        this.dispatchEvent = this.emit = function(b) {
            if (a[b.type] && a[b.type].length)
                for (var c = 0, h = a[b.type].length; c < h; c++) a[b.type][c](b)
        };
        this.removeEventListener = this.off = function(b, c) {
            var h = a[b].indexOf(c); - 1 !== h && a[b].splice(h, 1)
        };
        this.removeAllEventListeners = function(b) {
            if (b = a[b]) b.length = 0
        }
    };
    c.PolyK = {};
    c.PolyK.Triangulate = function(a) {
        var b = !0,
            f = a.length >> 1;
        if (3 > f) return [];
        for (var h = [], k = [], p = 0; p < f; p++) k.push(p);
        for (var p = 0, g = f; 3 < g;) {
            var m = k[(p + 0) % g],
                n = k[(p + 1) % g],
                q = k[(p + 2) % g],
                s = a[2 * m],
                v = a[2 * m + 1],
                t = a[2 * n],
                u = a[2 * n + 1],
                A = a[2 * q],
                r = a[2 * q + 1],
                x = !1;
            if (c.PolyK._convex(s, v, t, u, A, r, b))
                for (var x = !0, z = 0; z < g; z++) {
                    var w = k[z];
                    if (!(w === m || w === n || w === q) && c.PolyK._PointInTriangle(a[2 * w], a[2 * w + 1], s, v, t, u, A, r)) {
                        x = !1;
                        break
                    }
                }
            if (x) h.push(m, n, q), k.splice((p + 1) % g, 1), g--, p = 0;
            else if (p++ > 3 * g)
                if (b) {
                    h = [];
                    k = [];
                    for (p =
                        0; p < f; p++) k.push(p);
                    p = 0;
                    g = f;
                    b = !1
                } else return window.console.log("PIXI Warning: shape too complex to fill"), []
        }
        h.push(k[0], k[1], k[2]);
        return h
    };
    c.PolyK._PointInTriangle = function(a, b, c, h, k, p, g, m) {
        g -= c;
        m -= h;
        k -= c;
        p -= h;
        a -= c;
        c = b - h;
        b = g * g + m * m;
        h = g * k + m * p;
        g = g * a + m * c;
        m = k * k + p * p;
        k = k * a + p * c;
        p = 1 / (b * m - h * h);
        m = (m * g - h * k) * p;
        g = (b * k - h * g) * p;
        return 0 <= m && 0 <= g && 1 > m + g
    };
    c.PolyK._convex = function(a, b, c, h, k, g, l) {
        return 0 <= (b - h) * (k - c) + (c - a) * (g - h) === l
    };
    c.initDefaultShaders = function() {};
    c.CompileVertexShader = function(a, b) {
        return c._CompileShader(a,
            b, a.VERTEX_SHADER)
    };
    c.CompileFragmentShader = function(a, b) {
        return c._CompileShader(a, b, a.FRAGMENT_SHADER)
    };
    c._CompileShader = function(a, b, c) {
        b = b.join("\n");
        c = a.createShader(c);
        a.shaderSource(c, b);
        a.compileShader(c);
        return !a.getShaderParameter(c, a.COMPILE_STATUS) ? (window.console.log(a.getShaderInfoLog(c)), null) : c
    };
    c.compileProgram = function(a, b, f) {
        f = c.CompileFragmentShader(a, f);
        b = c.CompileVertexShader(a, b);
        var h = a.createProgram();
        a.attachShader(h, b);
        a.attachShader(h, f);
        a.linkProgram(h);
        a.getProgramParameter(h,
            a.LINK_STATUS) || window.console.log("Could not initialise shaders");
        return h
    };
    c.PixiShader = function(a) {
        this.gl = a;
        this.program = null;
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
        this.textureCount = 0;
        this.attributes = [];
        this.init()
    };
    c.PixiShader.prototype.init = function() {
        var a = this.gl,
            b = c.compileProgram(a, this.vertexSrc || c.PixiShader.defaultVertexSrc,
                this.fragmentSrc);
        a.useProgram(b);
        this.uSampler = a.getUniformLocation(b, "uSampler");
        this.projectionVector = a.getUniformLocation(b, "projectionVector");
        this.offsetVector = a.getUniformLocation(b, "offsetVector");
        this.dimensions = a.getUniformLocation(b, "dimensions");
        this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition");
        this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord");
        this.colorAttribute = a.getAttribLocation(b, "aColor"); - 1 === this.colorAttribute && (this.colorAttribute = 2);
        this.attributes = [this.aVertexPosition,
            this.aTextureCoord, this.colorAttribute
        ];
        for (var f in this.uniforms) this.uniforms[f].uniformLocation = a.getUniformLocation(b, f);
        this.initUniforms();
        this.program = b
    };
    c.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var a = this.gl,
            b, c;
        for (c in this.uniforms) {
            b = this.uniforms[c];
            var h = b.type;
            "sampler2D" === h ? (b._init = !1, null !== b.value && this.initSampler2D(b)) : "mat2" === h || "mat3" === h || "mat4" === h ? (b.glMatrix = !0, b.glValueLength = 1, "mat2" === h ? b.glFunc = a.uniformMatrix2fv : "mat3" === h ? b.glFunc = a.uniformMatrix3fv :
                "mat4" === h && (b.glFunc = a.uniformMatrix4fv)) : (b.glFunc = a["uniform" + h], b.glValueLength = "2f" === h || "2i" === h ? 2 : "3f" === h || "3i" === h ? 3 : "4f" === h || "4i" === h ? 4 : 1)
        }
    };
    c.PixiShader.prototype.initSampler2D = function(a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
            var b = this.gl;
            b.activeTexture(b["TEXTURE" + this.textureCount]);
            b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]);
            if (a.textureData) {
                var c = a.textureData,
                    h = c.magFilter ? c.magFilter : b.LINEAR,
                    k = c.minFilter ? c.minFilter : b.LINEAR,
                    g = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE,
                    l = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE,
                    m = c.luminance ? b.LUMINANCE : b.RGBA;
                c.repeat && (l = g = b.REPEAT);
                b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY);
                c.width ? b.texImage2D(b.TEXTURE_2D, 0, m, c.width ? c.width : 512, c.height ? c.height : 2, c.border ? c.border : 0, m, b.UNSIGNED_BYTE, null) : b.texImage2D(b.TEXTURE_2D, 0, m, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, h);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, k);
                b.texParameteri(b.TEXTURE_2D,
                    b.TEXTURE_WRAP_S, g);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, l)
            }
            b.uniform1i(a.uniformLocation, this.textureCount);
            a._init = !0;
            this.textureCount++
        }
    };
    c.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var a, b = this.gl,
            f;
        for (f in this.uniforms) a = this.uniforms[f], 1 === a.glValueLength ? !0 === a.glMatrix ? a.glFunc.call(b, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(b, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ?
            a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id] || c.createWebGLTexture(a.value.baseTexture, b)), b.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a))
    };
    c.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.attributes = this.gl = this.uniforms = null
    };
    c.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;",
        "   vColor = vec4(color * aColor.x, aColor.x);", "}"
    ];
    c.PixiFastShader = function(a) {
        this.gl = a;
        this.program = null;
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;",
            "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);",
            "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"
        ];
        this.textureCount = 0;
        this.init()
    };
    c.PixiFastShader.prototype.init = function() {
        var a = this.gl,
            b = c.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(b);
        this.uSampler = a.getUniformLocation(b, "uSampler");
        this.projectionVector = a.getUniformLocation(b, "projectionVector");
        this.offsetVector = a.getUniformLocation(b, "offsetVector");
        this.dimensions = a.getUniformLocation(b, "dimensions");
        this.uMatrix = a.getUniformLocation(b, "uMatrix");
        this.aVertexPosition =
            a.getAttribLocation(b, "aVertexPosition");
        this.aPositionCoord = a.getAttribLocation(b, "aPositionCoord");
        this.aScale = a.getAttribLocation(b, "aScale");
        this.aRotation = a.getAttribLocation(b, "aRotation");
        this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord");
        this.colorAttribute = a.getAttribLocation(b, "aColor"); - 1 === this.colorAttribute && (this.colorAttribute = 2);
        this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
        this.program = b
    };
    c.PixiFastShader.prototype.destroy =
        function() {
            this.gl.deleteProgram(this.program);
            this.attributes = this.gl = this.uniforms = null
        };
    c.StripShader = function() {
        this.program = null;
        this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "   gl_FragColor = gl_FragColor * alpha;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;",
            "attribute float aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "uniform vec2 offsetVector;", "varying float vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"
        ]
    };
    c.StripShader.prototype.init = function() {
        var a = c.gl,
            b = c.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(b);
        this.uSampler = a.getUniformLocation(b, "uSampler");
        this.projectionVector = a.getUniformLocation(b, "projectionVector");
        this.offsetVector = a.getUniformLocation(b, "offsetVector");
        this.colorAttribute = a.getAttribLocation(b, "aColor");
        this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition");
        this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord");
        this.translationMatrix = a.getUniformLocation(b, "translationMatrix");
        this.alpha = a.getUniformLocation(b,
            "alpha");
        this.program = b
    };
    c.PrimitiveShader = function(a) {
        this.gl = a;
        this.program = null;
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"
        ];
        this.init()
    };
    c.PrimitiveShader.prototype.init = function() {
        var a = this.gl,
            b = c.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(b);
        this.projectionVector = a.getUniformLocation(b, "projectionVector");
        this.offsetVector = a.getUniformLocation(b, "offsetVector");
        this.tintColor = a.getUniformLocation(b, "tint");
        this.aVertexPosition =
            a.getAttribLocation(b, "aVertexPosition");
        this.colorAttribute = a.getAttribLocation(b, "aColor");
        this.attributes = [this.aVertexPosition, this.colorAttribute];
        this.translationMatrix = a.getUniformLocation(b, "translationMatrix");
        this.alpha = a.getUniformLocation(b, "alpha");
        this.program = b
    };
    c.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.attribute = this.gl = this.uniforms = null
    };
    c.WebGLGraphics = function() {};
    c.WebGLGraphics.renderGraphics = function(a, b) {
        var f = b.gl,
            h = b.projection,
            k = b.offset,
            g = b.shaderManager.primitiveShader;
        a._webGL[f.id] || (a._webGL[f.id] = {
            points: [],
            indices: [],
            lastIndex: 0,
            buffer: f.createBuffer(),
            indexBuffer: f.createBuffer()
        });
        var l = a._webGL[f.id];
        a.dirty && (a.dirty = !1, a.clearDirty && (a.clearDirty = !1, l.lastIndex = 0, l.points = [], l.indices = []), c.WebGLGraphics.updateGraphics(a, f));
        b.shaderManager.activatePrimitiveShader();
        f.blendFunc(f.ONE, f.ONE_MINUS_SRC_ALPHA);
        f.uniformMatrix3fv(g.translationMatrix, !1, a.worldTransform.toArray(!0));
        f.uniform2f(g.projectionVector,
            h.x, -h.y);
        f.uniform2f(g.offsetVector, -k.x, -k.y);
        f.uniform3fv(g.tintColor, c.hex2rgb(a.tint));
        f.uniform1f(g.alpha, a.worldAlpha);
        f.bindBuffer(f.ARRAY_BUFFER, l.buffer);
        f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 24, 0);
        f.vertexAttribPointer(g.colorAttribute, 4, f.FLOAT, !1, 24, 8);
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, l.indexBuffer);
        f.drawElements(f.TRIANGLE_STRIP, l.indices.length, f.UNSIGNED_SHORT, 0);
        b.shaderManager.deactivatePrimitiveShader()
    };
    c.WebGLGraphics.updateGraphics = function(a, b) {
        for (var f =
                a._webGL[b.id], h = f.lastIndex; h < a.graphicsData.length; h++) {
            var k = a.graphicsData[h];
            k.type === c.Graphics.POLY ? (k.fill && 3 < k.points.length && c.WebGLGraphics.buildPoly(k, f), 0 < k.lineWidth && c.WebGLGraphics.buildLine(k, f)) : k.type === c.Graphics.RECT ? c.WebGLGraphics.buildRectangle(k, f) : (k.type === c.Graphics.CIRC || k.type === c.Graphics.ELIP) && c.WebGLGraphics.buildCircle(k, f)
        }
        f.lastIndex = a.graphicsData.length;
        f.glPoints = new Float32Array(f.points);
        b.bindBuffer(b.ARRAY_BUFFER, f.buffer);
        b.bufferData(b.ARRAY_BUFFER, f.glPoints,
            b.STATIC_DRAW);
        f.glIndicies = new Uint16Array(f.indices);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, f.indexBuffer);
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, f.glIndicies, b.STATIC_DRAW)
    };
    c.WebGLGraphics.buildRectangle = function(a, b) {
        var f = a.points,
            h = f[0],
            k = f[1],
            g = f[2],
            f = f[3];
        if (a.fill) {
            var l = c.hex2rgb(a.fillColor),
                m = a.fillAlpha,
                n = l[0] * m,
                q = l[1] * m,
                l = l[2] * m,
                s = b.points,
                v = b.indices,
                t = s.length / 6;
            s.push(h, k);
            s.push(n, q, l, m);
            s.push(h + g, k);
            s.push(n, q, l, m);
            s.push(h, k + f);
            s.push(n, q, l, m);
            s.push(h + g, k + f);
            s.push(n, q, l, m);
            v.push(t,
                t, t + 1, t + 2, t + 3, t + 3)
        }
        a.lineWidth && (m = a.points, a.points = [h, k, h + g, k, h + g, k + f, h, k + f, h, k], c.WebGLGraphics.buildLine(a, b), a.points = m)
    };
    c.WebGLGraphics.buildCircle = function(a, b) {
        var f = a.points,
            h = f[0],
            k = f[1],
            g = f[2],
            f = f[3],
            l = 2 * Math.PI / 40,
            m = 0;
        if (a.fill) {
            var m = c.hex2rgb(a.fillColor),
                n = a.fillAlpha,
                q = m[0] * n,
                s = m[1] * n,
                v = m[2] * n,
                t = b.points,
                u = b.indices,
                A = t.length / 6;
            u.push(A);
            for (m = 0; 41 > m; m++) t.push(h, k, q, s, v, n), t.push(h + Math.sin(l * m) * g, k + Math.cos(l * m) * f, q, s, v, n), u.push(A++, A++);
            u.push(A - 1)
        }
        if (a.lineWidth) {
            n = a.points;
            a.points = [];
            for (m = 0; 41 > m; m++) a.points.push(h + Math.sin(l * m) * g, k + Math.cos(l * m) * f);
            c.WebGLGraphics.buildLine(a, b);
            a.points = n
        }
    };
    c.WebGLGraphics.buildLine = function(a, b) {
        var f = 0,
            h = a.points;
        if (0 !== h.length) {
            if (a.lineWidth % 2)
                for (f = 0; f < h.length; f++) h[f] += 0.5;
            var k = new c.Point(h[0], h[1]),
                g = new c.Point(h[h.length - 2], h[h.length - 1]);
            if (k.x === g.x && k.y === g.y) {
                h.pop();
                h.pop();
                var g = new c.Point(h[h.length - 2], h[h.length - 1]),
                    l = g.x + 0.5 * (k.x - g.x),
                    k = g.y + 0.5 * (k.y - g.y);
                h.unshift(l, k);
                h.push(l, k)
            }
            var l = b.points,
                k = b.indices,
                g = h.length / 2,
                m = h.length,
                n = l.length / 6,
                q = a.lineWidth / 2,
                f = c.hex2rgb(a.lineColor),
                s = a.lineAlpha,
                v = f[0] * s,
                t = f[1] * s,
                u = f[2] * s,
                A, r, x, z, w, B, C, F, y, D, I, E, H;
            x = h[0];
            z = h[1];
            w = h[2];
            B = h[3];
            y = -(z - B);
            D = x - w;
            r = Math.sqrt(y * y + D * D);
            y = y / r * q;
            D = D / r * q;
            l.push(x - y, z - D, v, t, u, s);
            l.push(x + y, z + D, v, t, u, s);
            for (f = 1; f < g - 1; f++) x = h[2 * (f - 1)], z = h[2 * (f - 1) + 1], w = h[2 * f], B = h[2 * f + 1], C = h[2 * (f + 1)], F = h[2 * (f + 1) + 1], y = -(z - B), D = x - w, r = Math.sqrt(y * y + D * D), y /= r, D /= r, y *= q, D *= q, I = -(B - F), E = w - C, r = Math.sqrt(I * I + E * E), I /= r, E /= r, I *= q, E *= q, r = -D + z - (-D + B), A = -y + w - (-y +
                x), x = (-y + x) * (-D + B) - (-y + w) * (-D + z), z = -E + F - (-E + B), H = -I + w - (-I + C), C = (-I + C) * (-E + B) - (-I + w) * (-E + F), F = r * H - z * A, 0.1 > Math.abs(F) ? (l.push(w - y, B - D, v, t, u, s), l.push(w + y, B + D, v, t, u, s)) : (A = (A * C - H * x) / F, r = (z * x - r * C) / F, C = (A - w) * (A - w) + (r - B) + (r - B), 19600 < C ? (y -= I, D -= E, r = Math.sqrt(y * y + D * D), y /= r, D /= r, y *= q, D *= q, l.push(w - y, B - D), l.push(v, t, u, s), l.push(w + y, B + D), l.push(v, t, u, s), l.push(w - y, B - D), l.push(v, t, u, s), m++) : (l.push(A, r), l.push(v, t, u, s), l.push(w - (A - w), B - (r - B)), l.push(v, t, u, s)));
            x = h[2 * (g - 2)];
            z = h[2 * (g - 2) + 1];
            w = h[2 * (g - 1)];
            B = h[2 *
                (g - 1) + 1];
            y = -(z - B);
            D = x - w;
            r = Math.sqrt(y * y + D * D);
            y /= r;
            D /= r;
            y *= q;
            D *= q;
            l.push(w - y, B - D);
            l.push(v, t, u, s);
            l.push(w + y, B + D);
            l.push(v, t, u, s);
            k.push(n);
            for (f = 0; f < m; f++) k.push(n++);
            k.push(n - 1)
        }
    };
    c.WebGLGraphics.buildPoly = function(a, b) {
        var f = a.points;
        if (!(6 > f.length)) {
            for (var h = b.points, k = b.indices, g = f.length / 2, l = c.hex2rgb(a.fillColor), m = a.fillAlpha, n = l[0] * m, q = l[1] * m, l = l[2] * m, s = c.PolyK.Triangulate(f), v = h.length / 6, t = 0, t = 0; t < s.length; t += 3) k.push(s[t] + v), k.push(s[t] + v), k.push(s[t + 1] + v), k.push(s[t + 2] + v), k.push(s[t +
                2] + v);
            for (t = 0; t < g; t++) h.push(f[2 * t], f[2 * t + 1], n, q, l, m)
        }
    };
    c.glContexts = [];
    c.WebGLRenderer = function(a, b, f, h, k) {
        c.defaultRenderer || (c.defaultRenderer = this);
        this.type = c.WEBGL_RENDERER;
        this.transparent = !!h;
        this.width = a || 800;
        this.height = b || 600;
        this.view = f || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        this.contextLost = this.handleContextLost.bind(this);
        this.contextRestoredLost = this.handleContextRestored.bind(this);
        this.view.addEventListener("webglcontextlost", this.contextLost, !1);
        this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, !1);
        this.options = {
            alpha: this.transparent,
            antialias: !!k,
            premultipliedAlpha: !!h,
            stencil: !0
        };
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options)
        } catch (g) {
            try {
                this.gl = this.view.getContext("webgl", this.options)
            } catch (l) {
                throw Error(" This browser does not support webGL. Try using the canvas renderer" + this);
            }
        }
        a = this.gl;
        this.glContextId = a.id = c.WebGLRenderer.glContextId++;
        c.glContexts[this.glContextId] = a;
        c.blendModesWebGL ||
            (c.blendModesWebGL = [], c.blendModesWebGL[c.blendModes.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.ADD] = [a.SRC_ALPHA, a.DST_ALPHA], c.blendModesWebGL[c.blendModes.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.SCREEN] = [a.SRC_ALPHA, a.ONE], c.blendModesWebGL[c.blendModes.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c.blendModesWebGL[c.blendModes.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]);
        this.projection = new c.Point;
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
        this.offset = new c.Point(0, 0);
        this.resize(this.width, this.height);
        this.contextLost = !1;
        this.shaderManager = new c.WebGLShaderManager(a);
        this.spriteBatch = new c.WebGLSpriteBatch(a);
        this.maskManager = new c.WebGLMaskManager(a);
        this.filterManager =
            new c.WebGLFilterManager(a, this.transparent);
        this.renderSession = {};
        this.renderSession.gl = this.gl;
        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.renderer = this;
        a.useProgram(this.shaderManager.defaultShader.program);
        a.disable(a.DEPTH_TEST);
        a.disable(a.CULL_FACE);
        a.enable(a.BLEND);
        a.colorMask(!0, !0, !0,
            this.transparent)
    };
    c.WebGLRenderer.prototype.constructor = c.WebGLRenderer;
    c.WebGLRenderer.prototype.render = function(a) {
        if (!this.contextLost) {
            this.__stage !== a && (a.interactive && a.interactionManager.removeEvents(), this.__stage = a);
            c.WebGLRenderer.updateTextures();
            a.updateTransform();
            a._interactive && !a._interactiveEventsAdded && (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this));
            var b = this.gl;
            b.viewport(0, 0, this.width, this.height);
            b.bindFramebuffer(b.FRAMEBUFFER, null);
            this.transparent ? b.clearColor(0,
                0, 0, 0) : b.clearColor(a.backgroundColorSplit[0], a.backgroundColorSplit[1], a.backgroundColorSplit[2], 1);
            b.clear(b.COLOR_BUFFER_BIT);
            this.renderDisplayObject(a, this.projection);
            a.interactive ? a._interactiveEventsAdded || (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this)) : a._interactiveEventsAdded && (a._interactiveEventsAdded = !1, a.interactionManager.setTarget(this))
        }
    };
    c.WebGLRenderer.prototype.renderDisplayObject = function(a, b, c) {
        this.renderSession.drawCount = 0;
        this.renderSession.currentBlendMode =
            9999;
        this.renderSession.projection = b;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, c);
        a._renderWebGL(this.renderSession);
        this.spriteBatch.end()
    };
    c.WebGLRenderer.updateTextures = function() {
        for (var a = 0, a = 0; a < c.Texture.frameUpdates.length; a++) c.WebGLRenderer.updateTextureFrame(c.Texture.frameUpdates[a]);
        for (a = 0; a < c.texturesToDestroy.length; a++) c.WebGLRenderer.destroyTexture(c.texturesToDestroy[a]);
        c.texturesToUpdate.length =
            0;
        c.texturesToDestroy.length = 0;
        c.Texture.frameUpdates.length = 0
    };
    c.WebGLRenderer.destroyTexture = function(a) {
        for (var b = a._glTextures.length - 1; 0 <= b; b--) {
            var f = a._glTextures[b],
                h = c.glContexts[b];
            h && f && h.deleteTexture(f)
        }
        a._glTextures.length = 0
    };
    c.WebGLRenderer.updateTextureFrame = function(a) {
        a.updateFrame = !1;
        a._updateWebGLuvs()
    };
    c.WebGLRenderer.prototype.resize = function(a, b) {
        this.width = a;
        this.height = b;
        this.view.width = a;
        this.view.height = b;
        this.gl.viewport(0, 0, this.width, this.height);
        this.projection.x = this.width /
            2;
        this.projection.y = -this.height / 2
    };
    c.createWebGLTexture = function(a, b) {
        a.hasLoaded && (a._glTextures[b.id] = b.createTexture(), b.bindTexture(b.TEXTURE_2D, a._glTextures[b.id]), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, a.source), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a.scaleMode === c.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === c.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a._powerOf2 ?
            (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT)) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE)), b.bindTexture(b.TEXTURE_2D, null));
        return a._glTextures[b.id]
    };
    c.updateWebGLTexture = function(a, b) {
        a._glTextures[b.id] && (b.bindTexture(b.TEXTURE_2D, a._glTextures[b.id]), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA,
            b.UNSIGNED_BYTE, a.source), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a.scaleMode === c.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === c.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a._powerOf2 ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT)) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE)), b.bindTexture(b.TEXTURE_2D,
            null))
    };
    c.WebGLRenderer.prototype.handleContextLost = function(a) {
        a.preventDefault();
        this.contextLost = !0
    };
    c.WebGLRenderer.prototype.handleContextRestored = function() {
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options)
        } catch (a) {
            try {
                this.gl = this.view.getContext("webgl", this.options)
            } catch (b) {
                throw Error(" This browser does not support webGL. Try using the canvas renderer" + this);
            }
        }
        var f = this.gl;
        f.id = c.WebGLRenderer.glContextId++;
        this.shaderManager.setContext(f);
        this.spriteBatch.setContext(f);
        this.maskManager.setContext(f);
        this.filterManager.setContext(f);
        this.renderSession.gl = this.gl;
        f.disable(f.DEPTH_TEST);
        f.disable(f.CULL_FACE);
        f.enable(f.BLEND);
        f.colorMask(!0, !0, !0, this.transparent);
        this.gl.viewport(0, 0, this.width, this.height);
        for (var h in c.TextureCache) c.TextureCache[h].baseTexture._glTextures = [];
        this.contextLost = !1
    };
    c.WebGLRenderer.prototype.destroy = function() {
        this.view.removeEventListener("webglcontextlost", this.contextLost);
        this.view.removeEventListener("webglcontextrestored",
            this.contextRestoredLost);
        this.offset = this.projection = c.glContexts[this.glContextId] = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();
        this.renderSession = this.gl = this.filterManager = this.maskManager = this.spriteBatch = this.shaderManager = null
    };
    c.WebGLRenderer.glContextId = 0;
    c.WebGLMaskManager = function(a) {
        this.maskStack = [];
        this.maskPosition = 0;
        this.setContext(a)
    };
    c.WebGLMaskManager.prototype.setContext = function(a) {
        this.gl = a
    };
    c.WebGLMaskManager.prototype.pushMask =
        function(a, b) {
            var f = this.gl;
            0 === this.maskStack.length && (f.enable(f.STENCIL_TEST), f.stencilFunc(f.ALWAYS, 1, 1));
            this.maskStack.push(a);
            f.colorMask(!1, !1, !1, !1);
            f.stencilOp(f.KEEP, f.KEEP, f.INCR);
            c.WebGLGraphics.renderGraphics(a, b);
            f.colorMask(!0, !0, !0, !0);
            f.stencilFunc(f.NOTEQUAL, 0, this.maskStack.length);
            f.stencilOp(f.KEEP, f.KEEP, f.KEEP)
        };
    c.WebGLMaskManager.prototype.popMask = function(a) {
        var b = this.gl,
            f = this.maskStack.pop();
        f && (b.colorMask(!1, !1, !1, !1), b.stencilOp(b.KEEP, b.KEEP, b.DECR), c.WebGLGraphics.renderGraphics(f,
            a), b.colorMask(!0, !0, !0, !0), b.stencilFunc(b.NOTEQUAL, 0, this.maskStack.length), b.stencilOp(b.KEEP, b.KEEP, b.KEEP));
        0 === this.maskStack.length && b.disable(b.STENCIL_TEST)
    };
    c.WebGLMaskManager.prototype.destroy = function() {
        this.gl = this.maskStack = null
    };
    c.WebGLShaderManager = function(a) {
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var b = 0; b < this.maxAttibs; b++) this.attribState[b] = !1;
        this.setContext(a)
    };
    c.WebGLShaderManager.prototype.setContext = function(a) {
        this.gl = a;
        this.primitiveShader = new c.PrimitiveShader(a);
        this.defaultShader = new c.PixiShader(a);
        this.fastShader = new c.PixiFastShader(a);
        this.activateShader(this.defaultShader)
    };
    c.WebGLShaderManager.prototype.setAttribs = function(a) {
        var b;
        for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
        for (b = 0; b < a.length; b++) this.tempAttribState[a[b]] = !0;
        a = this.gl;
        for (b = 0; b < this.attribState.length; b++) this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], this.tempAttribState[b] ? a.enableVertexAttribArray(b) : a.disableVertexAttribArray(b))
    };
    c.WebGLShaderManager.prototype.activateShader = function(a) {
        this.currentShader = a;
        this.gl.useProgram(a.program);
        this.setAttribs(a.attributes)
    };
    c.WebGLShaderManager.prototype.activatePrimitiveShader = function() {
        this.gl.useProgram(this.primitiveShader.program);
        this.setAttribs(this.primitiveShader.attributes)
    };
    c.WebGLShaderManager.prototype.deactivatePrimitiveShader = function() {
        this.gl.useProgram(this.defaultShader.program);
        this.setAttribs(this.defaultShader.attributes)
    };
    c.WebGLShaderManager.prototype.destroy =
        function() {
            this.tempAttribState = this.attribState = null;
            this.primitiveShader.destroy();
            this.defaultShader.destroy();
            this.fastShader.destroy();
            this.gl = null
        };
    c.WebGLSpriteBatch = function(a) {
        this.vertSize = 6;
        this.size = 2E3;
        var b = 6 * this.size;
        this.vertices = new Float32Array(4 * this.size * this.vertSize);
        this.indices = new Uint16Array(b);
        for (var c = this.lastIndexCount = 0, h = 0; c < b; c += 6, h += 4) this.indices[c + 0] = h + 0, this.indices[c + 1] = h + 1, this.indices[c + 2] = h + 2, this.indices[c + 3] = h + 0, this.indices[c + 4] = h + 2, this.indices[c + 5] =
            h + 3;
        this.drawing = !1;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.setContext(a)
    };
    c.WebGLSpriteBatch.prototype.setContext = function(a) {
        this.gl = a;
        this.vertexBuffer = a.createBuffer();
        this.indexBuffer = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
        this.currentBlendMode = 99999
    };
    c.WebGLSpriteBatch.prototype.begin =
        function(a) {
            this.renderSession = a;
            this.shader = this.renderSession.shaderManager.defaultShader;
            this.start()
        };
    c.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    };
    c.WebGLSpriteBatch.prototype.render = function(a) {
        var b = a.texture;
        if (b.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size) this.flush(), this.currentBaseTexture = b.baseTexture;
        a.blendMode !== this.currentBlendMode && this.setBlendMode(a.blendMode);
        var c = a._uvs || a.texture._uvs;
        if (c) {
            var h = a.worldAlpha,
                k = a.tint,
                g = this.vertices,
                l = a.anchor.x,
                m = a.anchor.y,
                n, q;
            a.texture.trim ? (q = a.texture.trim, l = q.x - l * q.width, n = l + b.frame.width, m = q.y - m * q.height, q = m + b.frame.height) : (n = b.frame.width * (1 - l), l = b.frame.width * -l, q = b.frame.height * (1 - m), m = b.frame.height * -m);
            var b = 4 * this.currentBatchSize * this.vertSize,
                s = a.worldTransform;
            a = s.a;
            var v = s.c,
                t = s.b,
                u = s.d,
                A = s.tx,
                s = s.ty;
            g[b++] = a * l + t * m + A;
            g[b++] = u * m + v * l + s;
            g[b++] = c.x0;
            g[b++] = c.y0;
            g[b++] = h;
            g[b++] = k;
            g[b++] = a * n + t * m + A;
            g[b++] = u * m + v * n + s;
            g[b++] = c.x1;
            g[b++] = c.y1;
            g[b++] = h;
            g[b++] = k;
            g[b++] = a * n + t * q + A;
            g[b++] =
                u * q + v * n + s;
            g[b++] = c.x2;
            g[b++] = c.y2;
            g[b++] = h;
            g[b++] = k;
            g[b++] = a * l + t * q + A;
            g[b++] = u * q + v * l + s;
            g[b++] = c.x3;
            g[b++] = c.y3;
            g[b++] = h;
            g[b++] = k;
            this.currentBatchSize++
        }
    };
    c.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
        var b = a.tilingTexture;
        if (b.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size) this.flush(), this.currentBaseTexture = b.baseTexture;
        a.blendMode !== this.currentBlendMode && this.setBlendMode(a.blendMode);
        a._uvs || (a._uvs = new c.TextureUvs);
        var f = a._uvs;
        a.tilePosition.x %= b.baseTexture.width *
            a.tileScaleOffset.x;
        a.tilePosition.y %= b.baseTexture.height * a.tileScaleOffset.y;
        var h = a.tilePosition.x / (b.baseTexture.width * a.tileScaleOffset.x),
            k = a.tilePosition.y / (b.baseTexture.height * a.tileScaleOffset.y),
            g = a.width / b.baseTexture.width / (a.tileScale.x * a.tileScaleOffset.x),
            b = a.height / b.baseTexture.height / (a.tileScale.y * a.tileScaleOffset.y);
        f.x0 = 0 - h;
        f.y0 = 0 - k;
        f.x1 = 1 * g - h;
        f.y1 = 0 - k;
        f.x2 = 1 * g - h;
        f.y2 = 1 * b - k;
        f.x3 = 0 - h;
        f.y3 = 1 * b - k;
        var h = a.worldAlpha,
            k = a.tint,
            g = this.vertices,
            l = a.width,
            m = a.height,
            n = a.anchor.x,
            q = a.anchor.y,
            b = l * (1 - n),
            l = l * -n,
            n = m * (1 - q),
            m = m * -q,
            q = 4 * this.currentBatchSize * this.vertSize,
            s = a.worldTransform;
        a = s.a;
        var v = s.c,
            t = s.b,
            u = s.d,
            A = s.tx,
            s = s.ty;
        g[q++] = a * l + t * m + A;
        g[q++] = u * m + v * l + s;
        g[q++] = f.x0;
        g[q++] = f.y0;
        g[q++] = h;
        g[q++] = k;
        g[q++] = a * b + t * m + A;
        g[q++] = u * m + v * b + s;
        g[q++] = f.x1;
        g[q++] = f.y1;
        g[q++] = h;
        g[q++] = k;
        g[q++] = a * b + t * n + A;
        g[q++] = u * n + v * b + s;
        g[q++] = f.x2;
        g[q++] = f.y2;
        g[q++] = h;
        g[q++] = k;
        g[q++] = a * l + t * n + A;
        g[q++] = u * n + v * l + s;
        g[q++] = f.x3;
        g[q++] = f.y3;
        g[q++] = h;
        g[q++] = k;
        this.currentBatchSize++
    };
    c.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !==
            this.currentBatchSize) {
            var a = this.gl;
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id] || c.createWebGLTexture(this.currentBaseTexture, a));
            if (this.currentBatchSize > 0.5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
            else {
                var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b)
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0);
            this.currentBatchSize = 0;
            this.renderSession.drawCount++
        }
    };
    c.WebGLSpriteBatch.prototype.stop =
        function() {
            this.flush()
        };
    c.WebGLSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y);
        b = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, b, 0);
        a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, b, 8);
        a.vertexAttribPointer(this.shader.colorAttribute,
            2, a.FLOAT, !1, b, 16);
        this.currentBlendMode !== c.blendModes.NORMAL && this.setBlendMode(c.blendModes.NORMAL)
    };
    c.WebGLSpriteBatch.prototype.setBlendMode = function(a) {
        this.flush();
        this.currentBlendMode = a;
        a = c.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(a[0], a[1])
    };
    c.WebGLSpriteBatch.prototype.destroy = function() {
        this.indices = this.vertices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.gl = this.currentBaseTexture = null
    };
    c.WebGLFastSpriteBatch = function(a) {
        this.vertSize =
            10;
        this.size = this.maxSize = 6E3;
        var b = 6 * this.maxSize;
        this.vertices = new Float32Array(4 * this.size * this.vertSize);
        this.indices = new Uint16Array(b);
        this.indexBuffer = this.vertexBuffer = null;
        for (var c = this.lastIndexCount = 0, h = 0; c < b; c += 6, h += 4) this.indices[c + 0] = h + 0, this.indices[c + 1] = h + 1, this.indices[c + 2] = h + 2, this.indices[c + 3] = h + 0, this.indices[c + 4] = h + 2, this.indices[c + 5] = h + 3;
        this.drawing = !1;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.currentBlendMode = 0;
        this.matrix = this.shader = this.renderSession = null;
        this.setContext(a)
    };
    c.WebGLFastSpriteBatch.prototype.setContext = function(a) {
        this.gl = a;
        this.vertexBuffer = a.createBuffer();
        this.indexBuffer = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
        this.currentBlendMode = 99999
    };
    c.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
        this.renderSession = b;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = a.worldTransform.toArray(!0);
        this.start()
    };
    c.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    };
    c.WebGLFastSpriteBatch.prototype.render = function(a) {
        a = a.children;
        var b = a[0];
        if (b.texture._uvs) {
            this.currentBaseTexture = b.texture.baseTexture;
            b.blendMode !== this.currentBlendMode && this.setBlendMode(b.blendMode);
            for (var b = 0, c = a.length; b < c; b++) this.renderSprite(a[b]);
            this.flush()
        }
    };
    c.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
        if (a.visible) {
            if (a.texture.baseTexture !== this.currentBaseTexture &&
                (this.flush(), this.currentBaseTexture = a.texture.baseTexture, !a.texture._uvs)) return;
            var b, c = this.vertices,
                h, k, g, l, m;
            b = a.texture._uvs;
            a.texture.trim ? (g = a.texture.trim, k = g.x - a.anchor.x * g.width, h = k + a.texture.frame.width, l = g.y - a.anchor.y * g.height, g = l + a.texture.frame.height) : (h = a.texture.frame.width * (1 - a.anchor.x), k = a.texture.frame.width * -a.anchor.x, g = a.texture.frame.height * (1 - a.anchor.y), l = a.texture.frame.height * -a.anchor.y);
            m = 4 * this.currentBatchSize * this.vertSize;
            c[m++] = k;
            c[m++] = l;
            c[m++] = a.position.x;
            c[m++] = a.position.y;
            c[m++] = a.scale.x;
            c[m++] = a.scale.y;
            c[m++] = a.rotation;
            c[m++] = b.x0;
            c[m++] = b.y1;
            c[m++] = a.alpha;
            c[m++] = h;
            c[m++] = l;
            c[m++] = a.position.x;
            c[m++] = a.position.y;
            c[m++] = a.scale.x;
            c[m++] = a.scale.y;
            c[m++] = a.rotation;
            c[m++] = b.x1;
            c[m++] = b.y1;
            c[m++] = a.alpha;
            c[m++] = h;
            c[m++] = g;
            c[m++] = a.position.x;
            c[m++] = a.position.y;
            c[m++] = a.scale.x;
            c[m++] = a.scale.y;
            c[m++] = a.rotation;
            c[m++] = b.x2;
            c[m++] = b.y2;
            c[m++] = a.alpha;
            c[m++] = k;
            c[m++] = g;
            c[m++] = a.position.x;
            c[m++] = a.position.y;
            c[m++] = a.scale.x;
            c[m++] = a.scale.y;
            c[m++] = a.rotation;
            c[m++] = b.x3;
            c[m++] = b.y3;
            c[m++] = a.alpha;
            this.currentBatchSize++;
            this.currentBatchSize >= this.size && this.flush()
        }
    };
    c.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a = this.gl;
            this.currentBaseTexture._glTextures[a.id] || c.createWebGLTexture(this.currentBaseTexture, a);
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]);
            if (this.currentBatchSize > 0.5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
            else {
                var b = this.vertices.subarray(0,
                    4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b)
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0);
            this.currentBatchSize = 0;
            this.renderSession.drawCount++
        }
    };
    c.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    };
    c.WebGLFastSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector,
            b.x, b.y);
        a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        b = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, b, 0);
        a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, b, 8);
        a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, b, 16);
        a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, b, 24);
        a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, b, 28);
        a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, b, 36);
        this.currentBlendMode !== c.blendModes.NORMAL &&
            this.setBlendMode(c.blendModes.NORMAL)
    };
    c.WebGLFastSpriteBatch.prototype.setBlendMode = function(a) {
        this.flush();
        this.currentBlendMode = a;
        a = c.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(a[0], a[1])
    };
    c.WebGLFilterManager = function(a, b) {
        this.transparent = b;
        this.filterStack = [];
        this.offsetY = this.offsetX = 0;
        this.setContext(a)
    };
    c.WebGLFilterManager.prototype.setContext = function(a) {
        this.gl = a;
        this.texturePool = [];
        this.initShaderBuffers()
    };
    c.WebGLFilterManager.prototype.begin = function(a, b) {
        this.renderSession =
            a;
        this.defaultShader = a.shaderManager.defaultShader;
        var c = this.renderSession.projection;
        this.width = 2 * c.x;
        this.height = 2 * -c.y;
        this.buffer = b
    };
    c.WebGLFilterManager.prototype.pushFilter = function(a) {
        var b = this.gl,
            f = this.renderSession.projection,
            h = this.renderSession.offset;
        a._filterArea = a.target.filterArea || a.target.getBounds();
        this.filterStack.push(a);
        var k = a.filterPasses[0];
        this.offsetX += a._filterArea.x;
        this.offsetY += a._filterArea.y;
        var g = this.texturePool.pop();
        g ? g.resize(this.width, this.height) : g = new c.FilterTexture(this.gl,
            this.width, this.height);
        b.bindTexture(b.TEXTURE_2D, g.texture);
        var l = a._filterArea,
            k = k.padding;
        l.x -= k;
        l.y -= k;
        l.width += 2 * k;
        l.height += 2 * k;
        0 > l.x && (l.x = 0);
        l.width > this.width && (l.width = this.width);
        0 > l.y && (l.y = 0);
        l.height > this.height && (l.height = this.height);
        b.bindFramebuffer(b.FRAMEBUFFER, g.frameBuffer);
        b.viewport(0, 0, l.width, l.height);
        f.x = l.width / 2;
        f.y = -l.height / 2;
        h.x = -l.x;
        h.y = -l.y;
        b.uniform2f(this.defaultShader.projectionVector, l.width / 2, -l.height / 2);
        b.uniform2f(this.defaultShader.offsetVector, -l.x, -l.y);
        b.colorMask(!0, !0, !0, !0);
        b.clearColor(0, 0, 0, 0);
        b.clear(b.COLOR_BUFFER_BIT);
        a._glFilterTexture = g
    };
    c.WebGLFilterManager.prototype.popFilter = function() {
        var a = this.gl,
            b = this.filterStack.pop(),
            f = b._filterArea,
            h = b._glFilterTexture,
            k = this.renderSession.projection,
            g = this.renderSession.offset;
        if (1 < b.filterPasses.length) {
            a.viewport(0, 0, f.width, f.height);
            a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
            this.vertexArray[0] = 0;
            this.vertexArray[1] = f.height;
            this.vertexArray[2] = f.width;
            this.vertexArray[3] = f.height;
            this.vertexArray[4] = 0;
            this.vertexArray[5] = 0;
            this.vertexArray[6] = f.width;
            this.vertexArray[7] = 0;
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
            a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
            this.uvArray[2] = f.width / this.width;
            this.uvArray[5] = f.height / this.height;
            this.uvArray[6] = f.width / this.width;
            this.uvArray[7] = f.height / this.height;
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
            var l = this.texturePool.pop();
            l || (l = new c.FilterTexture(this.gl, this.width, this.height));
            l.resize(this.width, this.height);
            a.bindFramebuffer(a.FRAMEBUFFER,
                l.frameBuffer);
            a.clear(a.COLOR_BUFFER_BIT);
            a.disable(a.BLEND);
            for (var m = 0; m < b.filterPasses.length - 1; m++) {
                var n = b.filterPasses[m];
                a.bindFramebuffer(a.FRAMEBUFFER, l.frameBuffer);
                a.activeTexture(a.TEXTURE0);
                a.bindTexture(a.TEXTURE_2D, h.texture);
                this.applyFilterPass(n, f, f.width, f.height);
                n = h;
                h = l;
                l = n
            }
            a.enable(a.BLEND);
            this.texturePool.push(l)
        }
        l = b.filterPasses[b.filterPasses.length - 1];
        this.offsetX -= f.x;
        this.offsetY -= f.y;
        var m = this.width,
            n = this.height,
            q = 0,
            s = 0,
            v = this.buffer;
        0 === this.filterStack.length ? a.colorMask(!0, !0, !0, !0) : (v = this.filterStack[this.filterStack.length - 1], f = v._filterArea, m = f.width, n = f.height, q = f.x, s = f.y, v = v._glFilterTexture.frameBuffer);
        k.x = m / 2;
        k.y = -n / 2;
        g.x = q;
        g.y = s;
        f = b._filterArea;
        k = f.x - q;
        g = f.y - s;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = k;
        this.vertexArray[1] = g + f.height;
        this.vertexArray[2] = k + f.width;
        this.vertexArray[3] = g + f.height;
        this.vertexArray[4] = k;
        this.vertexArray[5] = g;
        this.vertexArray[6] = k + f.width;
        this.vertexArray[7] = g;
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
        a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = f.width / this.width;
        this.uvArray[5] = f.height / this.height;
        this.uvArray[6] = f.width / this.width;
        this.uvArray[7] = f.height / this.height;
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
        a.viewport(0, 0, m, n);
        a.bindFramebuffer(a.FRAMEBUFFER, v);
        a.activeTexture(a.TEXTURE0);
        a.bindTexture(a.TEXTURE_2D, h.texture);
        this.applyFilterPass(l, f, m, n);
        a.useProgram(this.defaultShader.program);
        a.uniform2f(this.defaultShader.projectionVector, m / 2, -n / 2);
        a.uniform2f(this.defaultShader.offsetVector, -q, -s);
        this.texturePool.push(h);
        b._glFilterTexture = null
    };
    c.WebGLFilterManager.prototype.applyFilterPass = function(a, b, f, h) {
        b = this.gl;
        var k = a.shaders[b.id];
        k || (k = new c.PixiShader(b), k.fragmentSrc = a.fragmentSrc, k.uniforms = a.uniforms, k.init(), a.shaders[b.id] = k);
        b.useProgram(k.program);
        b.uniform2f(k.projectionVector, f / 2, -h / 2);
        b.uniform2f(k.offsetVector, 0, 0);
        a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0],
            a.uniforms.dimensions.value[3] = this.vertexArray[5]);
        k.syncUniforms();
        b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
        b.vertexAttribPointer(k.aVertexPosition, 2, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ARRAY_BUFFER, this.uvBuffer);
        b.vertexAttribPointer(k.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ARRAY_BUFFER, this.colorBuffer);
        b.vertexAttribPointer(k.colorAttribute, 2, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++
    };
    c.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var a = this.gl;
        this.vertexBuffer = a.createBuffer();
        this.uvBuffer = a.createBuffer();
        this.colorBuffer = a.createBuffer();
        this.indexBuffer = a.createBuffer();
        this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW);
        this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.uvArray,
            a.STATIC_DRAW);
        this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]);
        a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW)
    };
    c.WebGLFilterManager.prototype.destroy = function() {
        var a = this.gl;
        this.filterStack = null;
        for (var b = this.offsetY = this.offsetX = 0; b < this.texturePool.length; b++) this.texturePool.destroy();
        this.texturePool = null;
        a.deleteBuffer(this.vertexBuffer);
        a.deleteBuffer(this.uvBuffer);
        a.deleteBuffer(this.colorBuffer);
        a.deleteBuffer(this.indexBuffer)
    };
    c.FilterTexture = function(a, b, f, h) {
        this.gl = a;
        this.frameBuffer = a.createFramebuffer();
        this.texture = a.createTexture();
        h = h || c.scaleModes.DEFAULT;
        a.bindTexture(a.TEXTURE_2D, this.texture);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, h === c.scaleModes.LINEAR ? a.LINEAR : a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, h === c.scaleModes.LINEAR ?
            a.LINEAR : a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
        a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer);
        a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer);
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0);
        this.renderBuffer = a.createRenderbuffer();
        a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer);
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER,
            this.renderBuffer);
        this.resize(b, f)
    };
    c.FilterTexture.prototype.clear = function() {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT)
    };
    c.FilterTexture.prototype.resize = function(a, b) {
        if (!(this.width === a && this.height === b)) {
            this.width = a;
            this.height = b;
            var c = this.gl;
            c.bindTexture(c.TEXTURE_2D, this.texture);
            c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null);
            c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer);
            c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b)
        }
    };
    c.FilterTexture.prototype.destroy =
        function() {
            var a = this.gl;
            a.deleteFramebuffer(this.frameBuffer);
            a.deleteTexture(this.texture);
            this.texture = this.frameBuffer = null
        };
    c.CanvasMaskManager = function() {};
    c.CanvasMaskManager.prototype.pushMask = function(a, b) {
        b.save();
        var f = a.alpha,
            h = a.worldTransform;
        b.setTransform(h.a, h.c, h.b, h.d, h.tx, h.ty);
        c.CanvasGraphics.renderGraphicsMask(a, b);
        b.clip();
        a.worldAlpha = f
    };
    c.CanvasMaskManager.prototype.popMask = function(a) {
        a.restore()
    };
    c.CanvasTinter = function() {};
    c.CanvasTinter.getTintedTexture = function(a, b) {
        var f =
            a.texture;
        b = c.CanvasTinter.roundColor(b);
        var h = "#" + ("00000" + (b | 0).toString(16)).substr(-6);
        f.tintCache = f.tintCache || {};
        if (f.tintCache[h]) return f.tintCache[h];
        var k = c.CanvasTinter.canvas || document.createElement("canvas");
        c.CanvasTinter.tintMethod(f, b, k);
        if (c.CanvasTinter.convertTintToImage) {
            var g = new Image;
            g.src = k.toDataURL();
            f.tintCache[h] = g
        } else f.tintCache[h] = k, c.CanvasTinter.canvas = null;
        return k
    };
    c.CanvasTinter.tintWithMultiply = function(a, b, c) {
        var h = c.getContext("2d"),
            k = a.frame;
        c.width = k.width;
        c.height = k.height;
        h.fillStyle = "#" + ("00000" + (b | 0).toString(16)).substr(-6);
        h.fillRect(0, 0, k.width, k.height);
        h.globalCompositeOperation = "multiply";
        h.drawImage(a.baseTexture.source, k.x, k.y, k.width, k.height, 0, 0, k.width, k.height);
        h.globalCompositeOperation = "destination-atop";
        h.drawImage(a.baseTexture.source, k.x, k.y, k.width, k.height, 0, 0, k.width, k.height)
    };
    c.CanvasTinter.tintWithOverlay = function(a, b, c) {
        var h = c.getContext("2d"),
            k = a.frame;
        c.width = k.width;
        c.height = k.height;
        h.globalCompositeOperation = "copy";
        h.fillStyle = "#" + ("00000" + (b | 0).toString(16)).substr(-6);
        h.fillRect(0, 0, k.width, k.height);
        h.globalCompositeOperation = "destination-atop";
        h.drawImage(a.baseTexture.source, k.x, k.y, k.width, k.height, 0, 0, k.width, k.height)
    };
    c.CanvasTinter.tintWithPerPixel = function(a, b, f) {
        var h = f.getContext("2d"),
            k = a.frame;
        f.width = k.width;
        f.height = k.height;
        h.globalCompositeOperation = "copy";
        h.drawImage(a.baseTexture.source, k.x, k.y, k.width, k.height, 0, 0, k.width, k.height);
        f = c.hex2rgb(b);
        a = f[0];
        b = f[1];
        f = f[2];
        for (var k = h.getImageData(0,
                0, k.width, k.height), g = k.data, l = 0; l < g.length; l += 4) g[l + 0] *= a, g[l + 1] *= b, g[l + 2] *= f;
        h.putImageData(k, 0, 0)
    };
    c.CanvasTinter.roundColor = function(a) {
        var b = c.CanvasTinter.cacheStepsPerColorChannel;
        a = c.hex2rgb(a);
        a[0] = Math.min(255, a[0] / b * b);
        a[1] = Math.min(255, a[1] / b * b);
        a[2] = Math.min(255, a[2] / b * b);
        return c.rgb2hex(a)
    };
    c.CanvasTinter.cacheStepsPerColorChannel = 8;
    c.CanvasTinter.convertTintToImage = !1;
    c.CanvasTinter.canUseMultiply = c.canUseNewCanvasBlendModes();
    c.CanvasTinter.tintMethod = c.CanvasTinter.canUseMultiply ?
        c.CanvasTinter.tintWithMultiply : c.CanvasTinter.tintWithPerPixel;
    c.CanvasRenderer = function(a, b, f, h) {
        c.defaultRenderer = c.defaultRenderer || this;
        this.type = c.CANVAS_RENDERER;
        this.clearBeforeRender = !0;
        this.roundPixels = !1;
        this.transparent = !!h;
        c.blendModesCanvas || (c.blendModesCanvas = [], c.canUseNewCanvasBlendModes() ? (c.blendModesCanvas[c.blendModes.NORMAL] = "source-over", c.blendModesCanvas[c.blendModes.ADD] = "lighter", c.blendModesCanvas[c.blendModes.MULTIPLY] = "multiply", c.blendModesCanvas[c.blendModes.SCREEN] =
            "screen", c.blendModesCanvas[c.blendModes.OVERLAY] = "overlay", c.blendModesCanvas[c.blendModes.DARKEN] = "darken", c.blendModesCanvas[c.blendModes.LIGHTEN] = "lighten", c.blendModesCanvas[c.blendModes.COLOR_DODGE] = "color-dodge", c.blendModesCanvas[c.blendModes.COLOR_BURN] = "color-burn", c.blendModesCanvas[c.blendModes.HARD_LIGHT] = "hard-light", c.blendModesCanvas[c.blendModes.SOFT_LIGHT] = "soft-light", c.blendModesCanvas[c.blendModes.DIFFERENCE] = "difference", c.blendModesCanvas[c.blendModes.EXCLUSION] = "exclusion",
            c.blendModesCanvas[c.blendModes.HUE] = "hue", c.blendModesCanvas[c.blendModes.SATURATION] = "saturation", c.blendModesCanvas[c.blendModes.COLOR] = "color", c.blendModesCanvas[c.blendModes.LUMINOSITY] = "luminosity") : (c.blendModesCanvas[c.blendModes.NORMAL] = "source-over", c.blendModesCanvas[c.blendModes.ADD] = "lighter", c.blendModesCanvas[c.blendModes.MULTIPLY] = "source-over", c.blendModesCanvas[c.blendModes.SCREEN] = "source-over", c.blendModesCanvas[c.blendModes.OVERLAY] = "source-over", c.blendModesCanvas[c.blendModes.DARKEN] =
            "source-over", c.blendModesCanvas[c.blendModes.LIGHTEN] = "source-over", c.blendModesCanvas[c.blendModes.COLOR_DODGE] = "source-over", c.blendModesCanvas[c.blendModes.COLOR_BURN] = "source-over", c.blendModesCanvas[c.blendModes.HARD_LIGHT] = "source-over", c.blendModesCanvas[c.blendModes.SOFT_LIGHT] = "source-over", c.blendModesCanvas[c.blendModes.DIFFERENCE] = "source-over", c.blendModesCanvas[c.blendModes.EXCLUSION] = "source-over", c.blendModesCanvas[c.blendModes.HUE] = "source-over", c.blendModesCanvas[c.blendModes.SATURATION] =
            "source-over", c.blendModesCanvas[c.blendModes.COLOR] = "source-over", c.blendModesCanvas[c.blendModes.LUMINOSITY] = "source-over"));
        this.width = a || 800;
        this.height = b || 600;
        this.view = f || document.createElement("canvas");
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        });
        this.refresh = !0;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0;
        this.maskManager = new c.CanvasMaskManager;
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null
        };
        "imageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context && (this.renderSession.smoothProperty = "oImageSmoothingEnabled")
    };
    c.CanvasRenderer.prototype.constructor = c.CanvasRenderer;
    c.CanvasRenderer.prototype.render =
        function(a) {
            c.texturesToUpdate.length = 0;
            c.texturesToDestroy.length = 0;
            a.updateTransform();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.globalAlpha = 1;
            !this.transparent && this.clearBeforeRender ? (this.context.fillStyle = a.backgroundColorString, this.context.fillRect(0, 0, this.width, this.height)) : this.transparent && this.clearBeforeRender && this.context.clearRect(0, 0, this.width, this.height);
            this.renderDisplayObject(a);
            a.interactive && !a._interactiveEventsAdded && (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this));
            0 < c.Texture.frameUpdates.length && (c.Texture.frameUpdates.length = 0)
        };
    c.CanvasRenderer.prototype.resize = function(a, b) {
        this.width = a;
        this.height = b;
        this.view.width = a;
        this.view.height = b
    };
    c.CanvasRenderer.prototype.renderDisplayObject = function(a, b) {
        this.renderSession.context = b || this.context;
        a._renderCanvas(this.renderSession)
    };
    c.CanvasRenderer.prototype.renderStripFlat = function(a) {
        var b = this.context;
        a = a.verticies;
        var c = a.length / 2;
        this.count++;
        b.beginPath();
        for (var h = 1; h < c - 2; h++) {
            var k = 2 * h,
                g = a[k + 2],
                l = a[k +
                    4],
                m = a[k + 3],
                n = a[k + 5];
            b.moveTo(a[k], a[k + 1]);
            b.lineTo(g, m);
            b.lineTo(l, n)
        }
        b.fillStyle = "#FF0000";
        b.fill();
        b.closePath()
    };
    c.CanvasRenderer.prototype.renderStrip = function(a) {
        var b = this.context,
            c = a.verticies,
            h = a.uvs,
            k = c.length / 2;
        this.count++;
        for (var g = 1; g < k - 2; g++) {
            var l = 2 * g,
                m = c[l],
                n = c[l + 2],
                q = c[l + 4],
                s = c[l + 1],
                v = c[l + 3],
                t = c[l + 5],
                u = h[l] * a.texture.width,
                A = h[l + 2] * a.texture.width,
                r = h[l + 4] * a.texture.width,
                x = h[l + 1] * a.texture.height,
                z = h[l + 3] * a.texture.height,
                l = h[l + 5] * a.texture.height;
            b.save();
            b.beginPath();
            b.moveTo(m,
                s);
            b.lineTo(n, v);
            b.lineTo(q, t);
            b.closePath();
            b.clip();
            var w = u * z + x * r + A * l - z * r - x * A - u * l;
            b.transform((m * z + x * q + n * l - z * q - x * n - m * l) / w, (s * z + x * t + v * l - z * t - x * v - s * l) / w, (u * n + m * r + A * q - n * r - m * A - u * q) / w, (u * v + s * r + A * t - v * r - s * A - u * t) / w, (u * z * q + x * n * r + m * A * l - m * z * r - x * A * q - u * n * l) / w, (u * z * t + x * v * r + s * A * l - s * z * r - x * A * t - u * v * l) / w);
            b.drawImage(a.texture.baseTexture.source, 0, 0);
            b.restore()
        }
    };
    c.CanvasBuffer = function(a, b) {
        this.width = a;
        this.height = b;
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.canvas.width =
            a;
        this.canvas.height = b
    };
    c.CanvasBuffer.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height)
    };
    c.CanvasBuffer.prototype.resize = function(a, b) {
        this.width = this.canvas.width = a;
        this.height = this.canvas.height = b
    };
    c.CanvasGraphics = function() {};
    c.CanvasGraphics.renderGraphics = function(a, b) {
        for (var f = a.worldAlpha, h = 0; h < a.graphicsData.length; h++) {
            var k = a.graphicsData[h],
                g = k.points;
            b.strokeStyle = "#" + ("00000" + (k.lineColor | 0).toString(16)).substr(-6);
            b.lineWidth = k.lineWidth;
            if (k.type === c.Graphics.POLY) {
                b.beginPath();
                b.moveTo(g[0], g[1]);
                for (var l = 1; l < g.length / 2; l++) b.lineTo(g[2 * l], g[2 * l + 1]);
                g[0] === g[g.length - 2] && g[1] === g[g.length - 1] && b.closePath();
                k.fill && (b.globalAlpha = k.fillAlpha * f, b.fillStyle = "#" + ("00000" + (k.fillColor | 0).toString(16)).substr(-6), b.fill());
                k.lineWidth && (b.globalAlpha = k.lineAlpha * f, b.stroke())
            } else if (k.type === c.Graphics.RECT) {
                if (k.fillColor || 0 === k.fillColor) b.globalAlpha = k.fillAlpha * f, b.fillStyle = "#" + ("00000" + (k.fillColor | 0).toString(16)).substr(-6), b.fillRect(g[0], g[1], g[2], g[3]);
                k.lineWidth &&
                    (b.globalAlpha = k.lineAlpha * f, b.strokeRect(g[0], g[1], g[2], g[3]))
            } else if (k.type === c.Graphics.CIRC) b.beginPath(), b.arc(g[0], g[1], g[2], 0, 2 * Math.PI), b.closePath(), k.fill && (b.globalAlpha = k.fillAlpha * f, b.fillStyle = "#" + ("00000" + (k.fillColor | 0).toString(16)).substr(-6), b.fill()), k.lineWidth && (b.globalAlpha = k.lineAlpha * f, b.stroke());
            else if (k.type === c.Graphics.ELIP) {
                var m = k.points,
                    n = 2 * m[2],
                    l = 2 * m[3],
                    g = m[0] - n / 2,
                    m = m[1] - l / 2;
                b.beginPath();
                var q = 0.5522848 * (n / 2),
                    s = 0.5522848 * (l / 2),
                    v = g + n,
                    t = m + l,
                    n = g + n / 2,
                    l = m + l / 2;
                b.moveTo(g,
                    l);
                b.bezierCurveTo(g, l - s, n - q, m, n, m);
                b.bezierCurveTo(n + q, m, v, l - s, v, l);
                b.bezierCurveTo(v, l + s, n + q, t, n, t);
                b.bezierCurveTo(n - q, t, g, l + s, g, l);
                b.closePath();
                k.fill && (b.globalAlpha = k.fillAlpha * f, b.fillStyle = "#" + ("00000" + (k.fillColor | 0).toString(16)).substr(-6), b.fill());
                k.lineWidth && (b.globalAlpha = k.lineAlpha * f, b.stroke())
            }
        }
    };
    c.CanvasGraphics.renderGraphicsMask = function(a, b) {
        var f = a.graphicsData.length;
        if (0 !== f) {
            1 < f && window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
            for (f = 0; 1 > f; f++) {
                var h = a.graphicsData[f],
                    k = h.points;
                if (h.type === c.Graphics.POLY) {
                    b.beginPath();
                    b.moveTo(k[0], k[1]);
                    for (h = 1; h < k.length / 2; h++) b.lineTo(k[2 * h], k[2 * h + 1]);
                    k[0] === k[k.length - 2] && k[1] === k[k.length - 1] && b.closePath()
                } else if (h.type === c.Graphics.RECT) b.beginPath(), b.rect(k[0], k[1], k[2], k[3]), b.closePath();
                else if (h.type === c.Graphics.CIRC) b.beginPath(), b.arc(k[0], k[1], k[2], 0, 2 * Math.PI), b.closePath();
                else if (h.type === c.Graphics.ELIP) {
                    var g = h.points,
                        l = 2 * g[2],
                        h = 2 * g[3],
                        k = g[0] - l / 2,
                        g = g[1] - h / 2;
                    b.beginPath();
                    var m = 0.5522848 * (l / 2),
                        n = 0.5522848 * (h / 2),
                        q = k + l,
                        s = g + h,
                        l = k + l / 2,
                        h = g + h / 2;
                    b.moveTo(k, h);
                    b.bezierCurveTo(k, h - n, l - m, g, l, g);
                    b.bezierCurveTo(l + m, g, q, h - n, q, h);
                    b.bezierCurveTo(q, h + n, l + m, s, l, s);
                    b.bezierCurveTo(l - m, s, k, h + n, k, h);
                    b.closePath()
                }
            }
        }
    };
    c.Graphics = function() {
        c.DisplayObjectContainer.call(this);
        this.renderable = !0;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.tint = 16777215;
        this.blendMode = c.blendModes.NORMAL;
        this.currentPath = {
            points: []
        };
        this._webGL = [];
        this.isMask = !1;
        this.bounds =
            null;
        this.boundsPadding = 10
    };
    c.Graphics.prototype = Object.create(c.DisplayObjectContainer.prototype);
    c.Graphics.prototype.constructor = c.Graphics;
    Object.defineProperty(c.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(a) {
            (this._cacheAsBitmap = a) ? this._generateCachedSprite(): (this.destroyCachedSprite(), this.dirty = !0)
        }
    });
    c.Graphics.prototype.lineStyle = function(a, b, f) {
        this.currentPath.points.length || this.graphicsData.pop();
        this.lineWidth = a || 0;
        this.lineColor = b ||
            0;
        this.lineAlpha = 3 > arguments.length ? 1 : f;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: c.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        return this
    };
    c.Graphics.prototype.moveTo = function(a, b) {
        this.currentPath.points.length || this.graphicsData.pop();
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: c.Graphics.POLY
        };
        this.currentPath.points.push(a, b);
        this.graphicsData.push(this.currentPath);
        return this
    };
    c.Graphics.prototype.lineTo = function(a, b) {
        this.currentPath.points.push(a, b);
        this.dirty = !0;
        return this
    };
    c.Graphics.prototype.beginFill = function(a, b) {
        this.filling = !0;
        this.fillColor = a || 0;
        this.fillAlpha = 2 > arguments.length ? 1 : b;
        return this
    };
    c.Graphics.prototype.endFill = function() {
        this.filling = !1;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this
    };
    c.Graphics.prototype.drawRect = function(a, b, f, h) {
        this.currentPath.points.length || this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [a, b, f, h],
            type: c.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = !0;
        return this
    };
    c.Graphics.prototype.drawCircle = function(a, b, f) {
        this.currentPath.points.length || this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [a, b, f, f],
            type: c.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = !0;
        return this
    };
    c.Graphics.prototype.drawEllipse = function(a, b, f, h) {
        this.currentPath.points.length || this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [a,
                b, f, h
            ],
            type: c.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = !0;
        return this
    };
    c.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = !1;
        this.clearDirty = this.dirty = !0;
        this.graphicsData = [];
        this.bounds = null;
        return this
    };
    c.Graphics.prototype.generateTexture = function() {
        var a = this.getBounds(),
            b = new c.CanvasBuffer(a.width, a.height),
            f = c.Texture.fromCanvas(b.canvas);
        b.context.translate(-a.x, -a.y);
        c.CanvasGraphics.renderGraphics(this, b.context);
        return f
    };
    c.Graphics.prototype._renderWebGL =
        function(a) {
            if (!(!1 === this.visible || 0 === this.alpha || !0 === this.isMask))
                if (this._cacheAsBitmap) this.dirty && (this._generateCachedSprite(), c.updateWebGLTexture(this._cachedSprite.texture.baseTexture, a.gl), this.dirty = !1), this._cachedSprite.alpha = this.alpha, c.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
                else {
                    a.spriteBatch.stop();
                    this._mask && a.maskManager.pushMask(this.mask, a);
                    this._filters && a.filterManager.pushFilter(this._filterBlock);
                    if (this.blendMode !== a.spriteBatch.currentBlendMode) {
                        a.spriteBatch.currentBlendMode =
                            this.blendMode;
                        var b = c.blendModesWebGL[a.spriteBatch.currentBlendMode];
                        a.spriteBatch.gl.blendFunc(b[0], b[1])
                    }
                    c.WebGLGraphics.renderGraphics(this, a);
                    if (this.children.length) {
                        a.spriteBatch.start();
                        for (var b = 0, f = this.children.length; b < f; b++) this.children[b]._renderWebGL(a);
                        a.spriteBatch.stop()
                    }
                    this._filters && a.filterManager.popFilter();
                    this._mask && a.maskManager.popMask(a);
                    a.drawCount++;
                    a.spriteBatch.start()
                }
        };
    c.Graphics.prototype._renderCanvas = function(a) {
        if (!(!1 === this.visible || 0 === this.alpha || !0 ===
                this.isMask)) {
            var b = a.context,
                f = this.worldTransform;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = c.blendModesCanvas[a.currentBlendMode]);
            b.setTransform(f.a, f.c, f.b, f.d, f.tx, f.ty);
            c.CanvasGraphics.renderGraphics(this, b);
            b = 0;
            for (f = this.children.length; b < f; b++) this.children[b]._renderCanvas(a)
        }
    };
    c.Graphics.prototype.getBounds = function(a) {
        this.bounds || this.updateBounds();
        var b = this.bounds.x,
            c = this.bounds.width + this.bounds.x,
            h = this.bounds.y,
            k = this.bounds.height +
            this.bounds.y;
        a = a || this.worldTransform;
        var g = a.a,
            l = a.c,
            m = a.b,
            n = a.d,
            q = a.tx,
            s = a.ty,
            v = g * c + m * k + q,
            t = n * k + l * c + s;
        a = g * b + m * k + q;
        var k = n * k + l * b + s,
            u = g * b + m * h + q,
            b = n * h + l * b + s,
            g = g * c + m * h + q,
            c = n * h + l * c + s,
            h = v,
            l = t,
            v = a < v ? a : v,
            v = u < v ? u : v,
            v = g < v ? g : v,
            t = k < t ? k : t,
            t = b < t ? b : t,
            t = c < t ? c : t,
            h = a > h ? a : h,
            h = u > h ? u : h,
            l = k > l ? k : l,
            l = b > l ? b : l;
        a = this._bounds;
        a.x = v;
        a.width = (g > h ? g : h) - v;
        a.y = t;
        a.height = (c > l ? c : l) - t;
        return a
    };
    c.Graphics.prototype.updateBounds = function() {
        for (var a = Infinity, b = -Infinity, f = Infinity, h = -Infinity, k, g, l, m, n, q = 0; q < this.graphicsData.length; q++)
            if (k =
                this.graphicsData[q], g = k.type, n = k.lineWidth, k = k.points, g === c.Graphics.RECT) g = k[0] - n / 2, l = k[1] - n / 2, m = k[2] + n, n = k[3] + n, a = g < a ? g : a, b = g + m > b ? g + m : b, f = l < f ? g : f, h = l + n > h ? l + n : h;
            else if (g === c.Graphics.CIRC || g === c.Graphics.ELIP) g = k[0], l = k[1], m = k[2] + n / 2, n = k[3] + n / 2, a = g - m < a ? g - m : a, b = g + m > b ? g + m : b, f = l - n < f ? l - n : f, h = l + n > h ? l + n : h;
        else
            for (m = 0; m < k.length; m += 2) g = k[m], l = k[m + 1], a = g - n < a ? g - n : a, b = g + n > b ? g + n : b, f = l - n < f ? l - n : f, h = l + n > h ? l + n : h;
        q = this.boundsPadding;
        this.bounds = new c.Rectangle(a - q, f - q, b - a + 2 * q, h - f + 2 * q)
    };
    c.Graphics.prototype._generateCachedSprite =
        function() {
            var a = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height);
            else {
                var b = new c.CanvasBuffer(a.width, a.height),
                    f = c.Texture.fromCanvas(b.canvas);
                this._cachedSprite = new c.Sprite(f);
                this._cachedSprite.buffer = b;
                this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -(a.x / a.width);
            this._cachedSprite.anchor.y = -(a.y / a.height);
            this._cachedSprite.buffer.context.translate(-a.x, -a.y);
            c.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
            this._cachedSprite.alpha = this.alpha
        };
    c.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0);
        this._cachedSprite = null
    };
    c.Graphics.POLY = 0;
    c.Graphics.RECT = 1;
    c.Graphics.CIRC = 2;
    c.Graphics.ELIP = 3;
    c.TilingSprite = function(a, b, f) {
        c.Sprite.call(this, a);
        this.width = b || 100;
        this.height = f || 100;
        this.tileScale = new c.Point(1, 1);
        this.tileScaleOffset = new c.Point(1, 1);
        this.tilePosition = new c.Point(0, 0);
        this.renderable = !0;
        this.tint = 16777215;
        this.blendMode = c.blendModes.NORMAL
    };
    c.TilingSprite.prototype =
        Object.create(c.Sprite.prototype);
    c.TilingSprite.prototype.constructor = c.TilingSprite;
    Object.defineProperty(c.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            this._width = a
        }
    });
    Object.defineProperty(c.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            this._height = a
        }
    });
    c.TilingSprite.prototype.onTextureUpdate = function() {
        this.updateFrame = !0
    };
    c.TilingSprite.prototype.setTexture = function(a) {
        this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215)
    };
    c.TilingSprite.prototype._renderWebGL = function(a) {
        if (!(!1 === this.visible || 0 === this.alpha)) {
            var b, f;
            this.mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start());
            this.filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock));
            !this.tilingTexture || this.refreshTexture ? (this.generateTilingTexture(!0), this.tilingTexture && this.tilingTexture.needsUpdate && (c.updateWebGLTexture(this.tilingTexture.baseTexture, a.gl), this.tilingTexture.needsUpdate = !1)) : a.spriteBatch.renderTilingSprite(this);
            b = 0;
            for (f = this.children.length; b < f; b++) this.children[b]._renderWebGL(a);
            a.spriteBatch.stop();
            this.filters && a.filterManager.popFilter();
            this.mask && a.maskManager.popMask(a);
            a.spriteBatch.start()
        }
    };
    c.TilingSprite.prototype._renderCanvas = function(a) {
        if (!(!1 === this.visible || 0 === this.alpha)) {
            var b = a.context;
            this._mask && a.maskManager.pushMask(this._mask, b);
            b.globalAlpha = this.worldAlpha;
            var f = this.worldTransform;
            b.setTransform(f.a, f.c, f.b, f.d, f.tx, f.ty);
            if (!this.__tilePattern ||
                this.refreshTexture)
                if (this.generateTilingTexture(!1), this.tilingTexture) this.__tilePattern = b.createPattern(this.tilingTexture.baseTexture.source, "repeat");
                else return;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = c.blendModesCanvas[a.currentBlendMode]);
            b.beginPath();
            var f = this.tilePosition,
                h = this.tileScale;
            f.x %= this.tilingTexture.baseTexture.width;
            f.y %= this.tilingTexture.baseTexture.height;
            b.scale(h.x, h.y);
            b.translate(f.x, f.y);
            b.fillStyle = this.__tilePattern;
            b.fillRect(-f.x + this.anchor.x * -this._width, -f.y + this.anchor.y * -this._height, this._width / h.x, this._height / h.y);
            b.scale(1 / h.x, 1 / h.y);
            b.translate(-f.x, -f.y);
            b.closePath();
            this._mask && a.maskManager.popMask(a.context)
        }
    };
    c.TilingSprite.prototype.getBounds = function() {
        var a = this._width,
            b = this._height,
            c = a * (1 - this.anchor.x),
            h = a * -this.anchor.x,
            k = b * (1 - this.anchor.y),
            g = b * -this.anchor.y,
            b = this.worldTransform,
            l = b.a,
            m = b.c,
            n = b.b,
            q = b.d,
            s = b.tx,
            v = b.ty,
            b = l * h + n * g + s,
            a = q * g + m * h + v,
            t = l * c + n * g + s,
            g = q * g + m * c + v,
            u = l * c + n * k + s,
            c = q * k +
            m * c + v,
            l = l * h + n * k + s,
            h = q * k + m * h + v,
            m = k = -Infinity,
            n = q = Infinity,
            q = b < q ? b : q,
            q = t < q ? t : q,
            q = u < q ? u : q,
            q = l < q ? l : q,
            n = a < n ? a : n,
            n = g < n ? g : n,
            n = c < n ? c : n,
            n = h < n ? h : n,
            k = b > k ? b : k,
            k = t > k ? t : k,
            k = u > k ? u : k,
            m = a > m ? a : m,
            m = g > m ? g : m,
            m = c > m ? c : m,
            b = this._bounds;
        b.x = q;
        b.width = (l > k ? l : k) - q;
        b.y = n;
        b.height = (h > m ? h : m) - n;
        return this._currentBounds = b
    };
    c.TilingSprite.prototype.generateTilingTexture = function(a) {
        var b = this.texture;
        if (b.baseTexture.hasLoaded) {
            var f = b.baseTexture,
                h = b.frame,
                k, g, f = h.width !== f.width || h.height !== f.height,
                l = !1;
            a ? (k = c.getNextPowerOfTwo(h.width),
                g = c.getNextPowerOfTwo(h.height), h.width !== k && h.height !== g && (l = !0)) : f && (k = h.width, g = h.height, l = !0);
            l ? (this.tilingTexture && this.tilingTexture.isTiling ? (a = this.tilingTexture.canvasBuffer, a.resize(k, g), this.tilingTexture.baseTexture.width = k, this.tilingTexture.baseTexture.height = g, this.tilingTexture.needsUpdate = !0) : (a = new c.CanvasBuffer(k, g), this.tilingTexture = c.Texture.fromCanvas(a.canvas), this.tilingTexture.canvasBuffer = a, this.tilingTexture.isTiling = !0), a.context.drawImage(b.baseTexture.source, h.x, h.y,
                h.width, h.height, 0, 0, k, g), this.tileScaleOffset.x = h.width / k, this.tileScaleOffset.y = h.height / g) : (this.tilingTexture && this.tilingTexture.isTiling && this.tilingTexture.destroy(!0), this.tileScaleOffset.x = 1, this.tileScaleOffset.y = 1, this.tilingTexture = b);
            this.refreshTexture = !1;
            this.tilingTexture.baseTexture._powerOf2 = !0
        }
    };
    c.BaseTextureCache = {};
    c.texturesToUpdate = [];
    c.texturesToDestroy = [];
    c.BaseTextureCacheIdGenerator = 0;
    c.BaseTexture = function(a, b) {
        c.EventTarget.call(this);
        this.height = this.width = 100;
        this.scaleMode =
            b || c.scaleModes.DEFAULT;
        this.hasLoaded = !1;
        this.source = a;
        this.id = c.BaseTextureCacheIdGenerator++;
        this._glTextures = [];
        if (a) {
            if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) this.hasLoaded = !0, this.width = this.source.width, this.height = this.source.height, c.texturesToUpdate.push(this);
            else {
                var f = this;
                this.source.onload = function() {
                    f.hasLoaded = !0;
                    f.width = f.source.width;
                    f.height = f.source.height;
                    c.texturesToUpdate.push(f);
                    f.dispatchEvent({
                        type: "loaded",
                        content: f
                    })
                }
            }
            this.imageUrl =
                null;
            this._powerOf2 = !1
        }
    };
    c.BaseTexture.prototype.constructor = c.BaseTexture;
    c.BaseTexture.prototype.destroy = function() {
        this.imageUrl && (delete c.BaseTextureCache[this.imageUrl], this.imageUrl = null, this.source.src = null);
        this.source = null;
        c.texturesToDestroy.push(this)
    };
    c.BaseTexture.prototype.updateSourceImage = function(a) {
        this.hasLoaded = !1;
        this.source.src = null;
        this.source.src = a
    };
    c.BaseTexture.fromImage = function(a, b, f) {
        var h = c.BaseTextureCache[a];
        void 0 === b && -1 === a.indexOf("data:") && (b = !0);
        h || (h = new Image,
            b && (h.crossOrigin = ""), h.src = a, h = new c.BaseTexture(h, f), h.imageUrl = a, c.BaseTextureCache[a] = h);
        return h
    };
    c.BaseTexture.fromCanvas = function(a, b) {
        a._pixiId || (a._pixiId = "canvas_" + c.TextureCacheIdGenerator++);
        var f = c.BaseTextureCache[a._pixiId];
        f || (f = new c.BaseTexture(a, b), c.BaseTextureCache[a._pixiId] = f);
        return f
    };
    c.TextureCache = {};
    c.FrameCache = {};
    c.TextureCacheIdGenerator = 0;
    c.Texture = function(a, b) {
        c.EventTarget.call(this);
        b || (this.noFrame = !0, b = new c.Rectangle(0, 0, 1, 1));
        a instanceof c.Texture && (a = a.baseTexture);
        this.baseTexture = a;
        this.frame = b;
        this.trim = null;
        this.scope = this;
        this._uvs = null;
        if (a.hasLoaded) this.noFrame && (b = new c.Rectangle(0, 0, a.width, a.height)), this.setFrame(b);
        else {
            var f = this;
            a.addEventListener("loaded", function() {
                f.onBaseTextureLoaded()
            })
        }
    };
    c.Texture.prototype.constructor = c.Texture;
    c.Texture.prototype.onBaseTextureLoaded = function() {
        var a = this.baseTexture;
        a.removeEventListener("loaded", this.onLoaded);
        this.noFrame && (this.frame = new c.Rectangle(0, 0, a.width, a.height));
        this.setFrame(this.frame);
        this.scope.dispatchEvent({
            type: "update",
            content: this
        })
    };
    c.Texture.prototype.destroy = function(a) {
        a && this.baseTexture.destroy()
    };
    c.Texture.prototype.setFrame = function(a) {
        this.frame = a;
        this.width = a.width;
        this.height = a.height;
        if (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height) throw Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        this.updateFrame = !0;
        c.Texture.frameUpdates.push(this)
    };
    c.Texture.prototype._updateWebGLuvs = function() {
        this._uvs || (this._uvs =
            new c.TextureUvs);
        var a = this.frame,
            b = this.baseTexture.width,
            f = this.baseTexture.height;
        this._uvs.x0 = a.x / b;
        this._uvs.y0 = a.y / f;
        this._uvs.x1 = (a.x + a.width) / b;
        this._uvs.y1 = a.y / f;
        this._uvs.x2 = (a.x + a.width) / b;
        this._uvs.y2 = (a.y + a.height) / f;
        this._uvs.x3 = a.x / b;
        this._uvs.y3 = (a.y + a.height) / f
    };
    c.Texture.fromImage = function(a, b, f) {
        var h = c.TextureCache[a];
        h || (h = new c.Texture(c.BaseTexture.fromImage(a, b, f)), c.TextureCache[a] = h);
        return h
    };
    c.Texture.fromFrame = function(a) {
        var b = c.TextureCache[a];
        if (!b) throw Error('The frameId "' +
            a + '" does not exist in the texture cache ');
        return b
    };
    c.Texture.fromCanvas = function(a, b) {
        var f = c.BaseTexture.fromCanvas(a, b);
        return new c.Texture(f)
    };
    c.Texture.addTextureToCache = function(a, b) {
        c.TextureCache[b] = a
    };
    c.Texture.removeTextureFromCache = function(a) {
        var b = c.TextureCache[a];
        delete c.TextureCache[a];
        delete c.BaseTextureCache[a];
        return b
    };
    c.Texture.frameUpdates = [];
    c.TextureUvs = function() {
        this.y4 = this.x3 = this.y2 = this.x2 = this.y1 = this.x1 = this.y0 = this.x0 = 0
    };
    c.RenderTexture = function(a, b, f, h) {
        c.EventTarget.call(this);
        this.width = a || 100;
        this.height = b || 100;
        this.frame = new c.Rectangle(0, 0, this.width, this.height);
        this.baseTexture = new c.BaseTexture;
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTextures = [];
        this.baseTexture.scaleMode = h || c.scaleModes.DEFAULT;
        this.baseTexture.hasLoaded = !0;
        this.renderer = f || c.defaultRenderer;
        this.renderer.type === c.WEBGL_RENDERER ? (a = this.renderer.gl, this.textureBuffer = new c.FilterTexture(a, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[a.id] =
            this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new c.Point(this.width / 2, -this.height / 2)) : (this.render = this.renderCanvas, this.textureBuffer = new c.CanvasBuffer(this.width, this.height), this.baseTexture.source = this.textureBuffer.canvas);
        c.Texture.frameUpdates.push(this)
    };
    c.RenderTexture.prototype = Object.create(c.Texture.prototype);
    c.RenderTexture.prototype.constructor = c.RenderTexture;
    c.RenderTexture.prototype.resize = function(a, b, f) {
        a === this.width && b === this.height || (this.width =
            a, this.height = b, this.frame.width = this.width, this.frame.height = this.height, f && (this.baseTexture.width = this.width, this.baseTexture.height = this.height), this.renderer.type === c.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.textureBuffer.resize(this.width, this.height))
    };
    c.RenderTexture.prototype.clear = function() {
        this.renderer.type === c.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        this.textureBuffer.clear()
    };
    c.RenderTexture.prototype.renderWebGL = function(a, b, f) {
        var h = this.renderer.gl;
        h.colorMask(!0, !0, !0, !0);
        h.viewport(0, 0, this.width, this.height);
        h.bindFramebuffer(h.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        f && this.textureBuffer.clear();
        f = a.children;
        h = a.worldTransform;
        a.worldTransform = c.RenderTexture.tempMatrix;
        a.worldTransform.d = -1;
        a.worldTransform.ty = -2 * this.projection.y;
        b && (a.worldTransform.tx = b.x, a.worldTransform.ty -= b.y);
        b = 0;
        for (var k = f.length; b < k; b++) f[b].updateTransform();
        c.WebGLRenderer.updateTextures();
        this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer);
        a.worldTransform = h
    };
    c.RenderTexture.prototype.renderCanvas = function(a, b, f) {
        var h = a.children,
            k = a.worldTransform;
        a.worldTransform = c.RenderTexture.tempMatrix;
        b && (a.worldTransform.tx = b.x, a.worldTransform.ty = b.y);
        b = 0;
        for (var g = h.length; b < g; b++) h[b].updateTransform();
        f && this.textureBuffer.clear();
        f = this.textureBuffer.context;
        this.renderer.renderDisplayObject(a, f);
        f.setTransform(1, 0, 0, 1, 0, 0);
        a.worldTransform = k
    };
    c.RenderTexture.tempMatrix =
        new c.Matrix;
    "undefined" !== typeof exports ? ("undefined" !== typeof module && module.exports && (exports = module.exports = c), exports.PIXI = c) : "undefined" !== typeof define && define.amd ? define("PIXI", this.PIXI = c) : this.PIXI = c
}).call(this);
(function() {
    var c = c || {
        VERSION: "2.0.5",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        }
    };
    PIXI.InteractionManager = PIXI.InteractionManager || function() {};
    c.Utils = {
        transposeArray: function(a) {
            for (var b = Array(a[0].length), c = 0; c < a[0].length; c++) {
                b[c] = Array(a.length - 1);
                for (var e = a.length - 1; - 1 < e; e--) b[c][e] = a[e][c]
            }
            return b
        },
        rotateArray: function(a, b) {
            "string" !== typeof b && (b = (b % 360 + 360) % 360);
            if (90 === b || -270 === b || "rotateLeft" === b) a = c.Utils.transposeArray(a), a = a.reverse();
            else if (-90 === b || 270 === b || "rotateRight" ===
                b) a = a.reverse(), a = c.Utils.transposeArray(a);
            else if (180 === Math.abs(b) || "rotate180" === b) {
                for (var d = 0; d < a.length; d++) a[d].reverse();
                a = a.reverse()
            }
            return a
        },
        parseDimension: function(a, b) {
            var c = 0,
                c = 0;
            "string" === typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100, c = 0 === b ? window.innerWidth * c : window.innerHeight * c) : c = parseInt(a, 10) : c = a;
            return c
        },
        shuffle: function(a) {
            for (var b = a.length - 1; 0 < b; b--) {
                var c = Math.floor(Math.random() * (b + 1)),
                    e = a[b];
                a[b] = a[c];
                a[c] = e
            }
            return a
        },
        pad: function(a, b, c, e) {
            "undefined" == typeof b &&
                (b = 0);
            "undefined" == typeof c && (c = " ");
            "undefined" == typeof e && (e = 3);
            var f = 0;
            if (b + 1 >= a.length) switch (e) {
                case 1:
                    a = Array(b + 1 - a.length).join(c) + a;
                    break;
                case 3:
                    b = Math.ceil((f = b - a.length) / 2);
                    a = Array(f - b + 1).join(c) + a + Array(b + 1).join(c);
                    break;
                default:
                    a += Array(b + 1 - a.length).join(c)
            }
            return a
        },
        isPlainObject: function(a) {
            if ("object" !== typeof a || a.nodeType || a === a.window) return !1;
            try {
                if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1
            } catch (b) {
                return !1
            }
            return !0
        },
        extend: function() {
            var a,
                b, d, e, f, h = arguments[0] || {},
                k = 1,
                g = arguments.length,
                l = !1;
            "boolean" === typeof h && (l = h, h = arguments[1] || {}, k = 2);
            g === k && (h = this, --k);
            for (; k < g; k++)
                if (null != (a = arguments[k]))
                    for (b in a) d = h[b], e = a[b], h !== e && (l && e && (c.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, d = d && Array.isArray(d) ? d : []) : d = d && c.Utils.isPlainObject(d) ? d : {}, h[b] = c.Utils.extend(l, d, e)) : void 0 !== e && (h[b] = e));
            return h
        }
    };
    "function" != typeof Function.prototype.bind && (Function.prototype.bind = function() {
        var a = Array.prototype.slice;
        return function(b) {
            function c() {
                var h =
                    f.concat(a.call(arguments));
                e.apply(this instanceof c ? this : b, h)
            }
            var e = this,
                f = a.call(arguments, 1);
            if ("function" != typeof e) throw new TypeError;
            c.prototype = function k(a) {
                a && (k.prototype = a);
                if (!(this instanceof k)) return new k
            }(e.prototype);
            return c
        }
    }());
    Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" == Object.prototype.toString.call(a)
    });
    Array.prototype.forEach || (Array.prototype.forEach = function(a) {
        if (void 0 === this || null === this) throw new TypeError;
        var b = Object(this),
            c = b.length >>> 0;
        if ("function" !==
            typeof a) throw new TypeError;
        for (var e = 2 <= arguments.length ? arguments[1] : void 0, f = 0; f < c; f++) f in b && a.call(e, b[f], f, b)
    });
    if ("function" !== typeof window.Uint32Array) {
        var g = function(a) {
            window[a] = function(a) {
                if ("number" === typeof a) {
                    Array.call(this, a);
                    this.length = a;
                    for (var c = 0; c < this.length; c++) this[c] = 0
                } else {
                    Array.call(this, a.length);
                    this.length = a.length;
                    for (c = 0; c < this.length; c++) this[c] = a[c]
                }
            };
            window[a].prototype = [];
            window[a].constructor = window[a]
        };
        g("Uint32Array");
        g("Int16Array")
    }
    window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {});
    c.Circle = function(a, b, c) {
        c = c || 0;
        this.x = a || 0;
        this.y = b || 0;
        this._diameter = c;
        this._radius = 0 < c ? 0.5 * c : 0
    };
    c.Circle.prototype = {
        circumference: function() {
            return 2 * Math.PI * this._radius
        },
        setTo: function(a, b, c) {
            this.x = a;
            this.y = b;
            this._diameter = c;
            this._radius = 0.5 * c;
            return this
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.diameter)
        },
        copyTo: function(a) {
            a.x = this.x;
            a.y = this.y;
            a.diameter = this._diameter;
            return a
        },
        distance: function(a, b) {
            "undefined" === typeof b && (b = !1);
            return b ? c.Math.distanceRounded(this.x, this.y, a.x, a.y) : c.Math.distance(this.x, this.y, a.x, a.y)
        },
        clone: function(a) {
            "undefined" === typeof a ? a = new c.Circle(this.x, this.y, this.diameter) : a.setTo(this.x, this.y, this.diameter);
            return a
        },
        contains: function(a, b) {
            return c.Circle.contains(this, a, b)
        },
        circumferencePoint: function(a, b, d) {
            return c.Circle.circumferencePoint(this, a, b, d)
        },
        offset: function(a, b) {
            this.x += a;
            this.y += b;
            return this
        },
        offsetPoint: function(a) {
            return this.offset(a.x,
                a.y)
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    };
    c.Circle.prototype.constructor = c.Circle;
    Object.defineProperty(c.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter
        },
        set: function(a) {
            0 < a && (this._diameter = a, this._radius = 0.5 * a)
        }
    });
    Object.defineProperty(c.Circle.prototype, "radius", {
        get: function() {
            return this._radius
        },
        set: function(a) {
            0 < a && (this._radius = a, this._diameter = 2 * a)
        }
    });
    Object.defineProperty(c.Circle.prototype,
        "left", {
            get: function() {
                return this.x - this._radius
            },
            set: function(a) {
                a > this.x ? this._diameter = this._radius = 0 : this.radius = this.x - a
            }
        });
    Object.defineProperty(c.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius
        },
        set: function(a) {
            a < this.x ? this._diameter = this._radius = 0 : this.radius = a - this.x
        }
    });
    Object.defineProperty(c.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius
        },
        set: function(a) {
            a > this.y ? this._diameter = this._radius = 0 : this.radius = this.y - a
        }
    });
    Object.defineProperty(c.Circle.prototype,
        "bottom", {
            get: function() {
                return this.y + this._radius
            },
            set: function(a) {
                a < this.y ? this._diameter = this._radius = 0 : this.radius = a - this.y
            }
        });
    Object.defineProperty(c.Circle.prototype, "area", {
        get: function() {
            return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
        }
    });
    Object.defineProperty(c.Circle.prototype, "empty", {
        get: function() {
            return 0 === this._diameter
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0)
        }
    });
    c.Circle.contains = function(a, b, c) {
        return 0 < a.radius && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom ? (a.x - b) * (a.x -
            b) + (a.y - c) * (a.y - c) <= a.radius * a.radius : !1
    };
    c.Circle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.diameter == b.diameter
    };
    c.Circle.intersects = function(a, b) {
        return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius
    };
    c.Circle.circumferencePoint = function(a, b, d, e) {
        "undefined" === typeof d && (d = !1);
        "undefined" === typeof e && (e = new c.Point);
        !0 === d && (b = c.Math.degToRad(b));
        e.x = a.x + a.radius * Math.cos(b);
        e.y = a.y + a.radius * Math.sin(b);
        return e
    };
    c.Circle.intersectsRectangle = function(a, b) {
        var c = Math.abs(a.x - b.x - b.halfWidth);
        if (c > b.halfWidth + a.radius) return !1;
        var e = Math.abs(a.y - b.y - b.halfHeight);
        if (e > b.halfHeight + a.radius) return !1;
        if (c <= b.halfWidth || e <= b.halfHeight) return !0;
        c -= b.halfWidth;
        e -= b.halfHeight;
        return c * c + e * e <= a.radius * a.radius
    };
    PIXI.Circle = c.Circle;
    c.Point = function(a, b) {
        this.x = a || 0;
        this.y = b || 0
    };
    c.Point.prototype = {
        copyFrom: function(a) {
            return this.setTo(a.x, a.y)
        },
        invert: function() {
            return this.setTo(this.y, this.x)
        },
        setTo: function(a, b) {
            this.x = a || 0;
            this.y = b || (0 !== b ? this.x : 0);
            return this
        },
        set: function(a, b) {
            this.x =
                a || 0;
            this.y = b || (0 !== b ? this.x : 0);
            return this
        },
        add: function(a, b) {
            this.x += a;
            this.y += b;
            return this
        },
        subtract: function(a, b) {
            this.x -= a;
            this.y -= b;
            return this
        },
        multiply: function(a, b) {
            this.x *= a;
            this.y *= b;
            return this
        },
        divide: function(a, b) {
            this.x /= a;
            this.y /= b;
            return this
        },
        clampX: function(a, b) {
            this.x = c.Math.clamp(this.x, a, b);
            return this
        },
        clampY: function(a, b) {
            this.y = c.Math.clamp(this.y, a, b);
            return this
        },
        clamp: function(a, b) {
            this.x = c.Math.clamp(this.x, a, b);
            this.y = c.Math.clamp(this.y, a, b);
            return this
        },
        clone: function(a) {
            "undefined" ===
            typeof a ? a = new c.Point(this.x, this.y) : a.setTo(this.x, this.y);
            return a
        },
        copyTo: function(a) {
            a.x = this.x;
            a.y = this.y;
            return a
        },
        distance: function(a, b) {
            return c.Point.distance(this, a, b)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y
        },
        angle: function(a, b) {
            "undefined" === typeof b && (b = !1);
            return b ? c.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x)
        },
        angleSq: function(a) {
            return this.subtract(a).angle(a.subtract(this))
        },
        rotate: function(a, b, d, e, f) {
            return c.Point.rotate(this,
                a, b, d, e, f)
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y
        },
        setMagnitude: function(a) {
            return this.normalize().multiply(a, a)
        },
        normalize: function() {
            if (!this.isZero()) {
                var a = this.getMagnitude();
                this.x /= a;
                this.y /= a
            }
            return this
        },
        isZero: function() {
            return 0 === this.x && 0 === this.y
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x
        },
        perp: function() {
            return this.setTo(-this.y, this.x)
        },
        rperp: function() {
            return this.setTo(this.y, -this.x)
        },
        normalRightHand: function() {
            return this.setTo(-1 * this.y, this.x)
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    };
    c.Point.prototype.constructor = c.Point;
    c.Point.add = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Point);
        d.x = a.x + b.x;
        d.y = a.y + b.y;
        return d
    };
    c.Point.subtract = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Point);
        d.x = a.x - b.x;
        d.y = a.y - b.y;
        return d
    };
    c.Point.multiply = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Point);
        d.x = a.x * b.x;
        d.y = a.y * b.y;
        return d
    };
    c.Point.divide = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Point);
        d.x = a.x / b.x;
        d.y = a.y / b.y;
        return d
    };
    c.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y
    };
    c.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x)
    };
    c.Point.angleSq = function(a, b) {
        return a.subtract(b).angle(b.subtract(a))
    };
    c.Point.negative = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        return b.setTo(-a.x, -a.y)
    };
    c.Point.multiplyAdd = function(a, b, d, e) {
        "undefined" === typeof e && (e = new c.Point);
        return e.setTo(a.x + b.x * d, a.y + b.y * d)
    };
    c.Point.interpolate = function(a, b, d, e) {
        "undefined" === typeof e && (e = new c.Point);
        return e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d)
    };
    c.Point.perp = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        return b.setTo(-a.y, a.x)
    };
    c.Point.rperp = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        return b.setTo(a.y, -a.x)
    };
    c.Point.distance = function(a, b, d) {
        "undefined" === typeof d && (d = !1);
        return d ? c.Math.distanceRounded(a.x, a.y, b.x, b.y) : c.Math.distance(a.x, a.y, b.x, b.y)
    };
    c.Point.project =
        function(a, b, d) {
            "undefined" === typeof d && (d = new c.Point);
            a = a.dot(b) / b.getMagnitudeSq();
            0 !== a && d.setTo(a * b.x, a * b.y);
            return d
        };
    c.Point.projectUnit = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Point);
        a = a.dot(b);
        0 !== a && d.setTo(a * b.x, a * b.y);
        return d
    };
    c.Point.normalRightHand = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        return b.setTo(-1 * a.y, a.x)
    };
    c.Point.normalize = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        var d = a.getMagnitude();
        0 !== d && b.setTo(a.x / d, a.y / d);
        return b
    };
    c.Point.rotate =
        function(a, b, d, e, f, h) {
            h = h || null;
            f && (e = c.Math.degToRad(e));
            null === h && (h = Math.sqrt((b - a.x) * (b - a.x) + (d - a.y) * (d - a.y)));
            return a.setTo(b + h * Math.cos(e), d + h * Math.sin(e))
        };
    c.Point.centroid = function(a, b) {
        "undefined" === typeof b && (b = new c.Point);
        if ("[object Array]" !== Object.prototype.toString.call(a)) throw Error("Phaser.Point. Parameter 'points' must be an array");
        var d = a.length;
        if (1 > d) throw Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === d) return b.copyFrom(a[0]), b;
        for (var e = 0; e < d; e++) c.Point.add(b,
            a[e], b);
        b.divide(d, d);
        return b
    };
    PIXI.Point = c.Point;
    c.Rectangle = function(a, b, c, e) {
        this.x = a || 0;
        this.y = b || 0;
        this.width = c || 0;
        this.height = e || 0
    };
    c.Rectangle.prototype = {
        offset: function(a, b) {
            this.x += a;
            this.y += b;
            return this
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y)
        },
        setTo: function(a, b, c, e) {
            this.x = a;
            this.y = b;
            this.width = c;
            this.height = e;
            return this
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y)
        },
        floorAll: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width =
                Math.floor(this.width);
            this.height = Math.floor(this.height)
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height)
        },
        copyTo: function(a) {
            a.x = this.x;
            a.y = this.y;
            a.width = this.width;
            a.height = this.height;
            return a
        },
        inflate: function(a, b) {
            return c.Rectangle.inflate(this, a, b)
        },
        size: function(a) {
            return c.Rectangle.size(this, a)
        },
        clone: function(a) {
            return c.Rectangle.clone(this, a)
        },
        contains: function(a, b) {
            return c.Rectangle.contains(this, a, b)
        },
        containsRect: function(a) {
            return c.Rectangle.containsRect(this,
                a)
        },
        equals: function(a) {
            return c.Rectangle.equals(this, a)
        },
        intersection: function(a, b) {
            return c.Rectangle.intersection(this, a, b)
        },
        intersects: function(a, b) {
            return c.Rectangle.intersects(this, a, b)
        },
        intersectsRaw: function(a, b, d, e, f) {
            return c.Rectangle.intersectsRaw(this, a, b, d, e, f)
        },
        union: function(a, b) {
            return c.Rectangle.union(this, a, b)
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    };
    Object.defineProperty(c.Rectangle.prototype,
        "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        });
    Object.defineProperty(c.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2)
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(a) {
            this.height = a <= this.y ? 0 : this.y - a
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new c.Point(this.right, this.bottom)
        },
        set: function(a) {
            this.right = a.x;
            this.bottom = a.y
        }
    });
    Object.defineProperty(c.Rectangle.prototype,
        "left", {
            get: function() {
                return this.x
            },
            set: function(a) {
                this.width = a >= this.right ? 0 : this.right - a;
                this.x = a
            }
        });
    Object.defineProperty(c.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(a) {
            this.width = a <= this.x ? 0 : this.x + a
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "perimeter", {
        get: function() {
            return 2 * this.width + 2 * this.height
        }
    });
    Object.defineProperty(c.Rectangle.prototype,
        "centerX", {
            get: function() {
                return this.x + this.halfWidth
            },
            set: function(a) {
                this.x = a - this.halfWidth
            }
        });
    Object.defineProperty(c.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight
        },
        set: function(a) {
            this.y = a - this.halfHeight
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(a) {
            a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "topLeft", {
        get: function() {
            return new c.Point(this.x,
                this.y)
        },
        set: function(a) {
            this.x = a.x;
            this.y = a.y
        }
    });
    Object.defineProperty(c.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0)
        }
    });
    c.Rectangle.prototype.constructor = c.Rectangle;
    c.Rectangle.inflate = function(a, b, c) {
        a.x -= b;
        a.width += 2 * b;
        a.y -= c;
        a.height += 2 * c;
        return a
    };
    c.Rectangle.inflatePoint = function(a, b) {
        return c.Rectangle.inflate(a, b.x, b.y)
    };
    c.Rectangle.size = function(a, b) {
        "undefined" === typeof b ? b = new c.Point(a.width, a.height) : b.setTo(a.width,
            a.height);
        return b
    };
    c.Rectangle.clone = function(a, b) {
        "undefined" === typeof b ? b = new c.Rectangle(a.x, a.y, a.width, a.height) : b.setTo(a.x, a.y, a.width, a.height);
        return b
    };
    c.Rectangle.contains = function(a, b, c) {
        return 0 >= a.width || 0 >= a.height ? !1 : b >= a.x && b <= a.right && c >= a.y && c <= a.bottom
    };
    c.Rectangle.containsRaw = function(a, b, c, e, f, h) {
        return f >= a && f <= a + c && h >= b && h <= b + e
    };
    c.Rectangle.containsPoint = function(a, b) {
        return c.Rectangle.contains(a, b.x, b.y)
    };
    c.Rectangle.containsRect = function(a, b) {
        return a.volume > b.volume ? !1 :
            a.x >= b.x && a.y >= b.y && a.right <= b.right && a.bottom <= b.bottom
    };
    c.Rectangle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height
    };
    c.Rectangle.intersection = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Rectangle);
        c.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), d.y = Math.max(a.y, b.y), d.width = Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y);
        return d
    };
    c.Rectangle.intersects = function(a, b) {
        return 0 >= a.width || 0 >= a.height || 0 >= b.width || 0 >= b.height ? !1 :
            !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom)
    };
    c.Rectangle.intersectsRaw = function(a, b, c, e, f, h) {
        "undefined" === typeof h && (h = 0);
        return !(b > a.right + h || c < a.left - h || e > a.bottom + h || f < a.top - h)
    };
    c.Rectangle.union = function(a, b, d) {
        "undefined" === typeof d && (d = new c.Rectangle);
        return d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top))
    };
    PIXI.Rectangle = c.Rectangle;
    PIXI.EmptyRectangle = new c.Rectangle(0, 0, 0, 0);
    c.Line =
        function(a, b, d, e) {
            d = d || 0;
            e = e || 0;
            this.start = new c.Point(a || 0, b || 0);
            this.end = new c.Point(d, e)
        };
    c.Line.prototype = {
        setTo: function(a, b, c, e) {
            this.start.setTo(a, b);
            this.end.setTo(c, e);
            return this
        },
        fromSprite: function(a, b, c) {
            "undefined" === typeof c && (c = !1);
            return c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y)
        },
        intersects: function(a, b, d) {
            return c.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d)
        },
        pointOnLine: function(a, b) {
            return (a - this.start.x) * (this.end.y -
                this.start.y) === (this.end.x - this.start.x) * (b - this.start.y)
        },
        pointOnSegment: function(a, b) {
            var c = Math.min(this.start.x, this.end.x),
                e = Math.max(this.start.x, this.end.x),
                f = Math.min(this.start.y, this.end.y),
                h = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(a, b) && a >= c && a <= e && b >= f && b <= h
        },
        coordinatesOnLine: function(a, b) {
            "undefined" === typeof a && (a = 1);
            "undefined" === typeof b && (b = []);
            var c = Math.round(this.start.x),
                e = Math.round(this.start.y),
                f = Math.round(this.end.x),
                h = Math.round(this.end.y),
                k = Math.abs(f -
                    c),
                g = Math.abs(h - e),
                l = c < f ? 1 : -1,
                m = e < h ? 1 : -1,
                n = k - g;
            b.push([c, e]);
            for (var q = 1; !(c == f && e == h);) {
                var s = n << 1;
                s > -g && (n -= g, c += l);
                s < k && (n += k, e += m);
                0 === q % a && b.push([c, e]);
                q++
            }
            return b
        }
    };
    Object.defineProperty(c.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
        }
    });
    Object.defineProperty(c.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
        }
    });
    Object.defineProperty(c.Line.prototype,
        "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        });
    Object.defineProperty(c.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y))
        }
    });
    Object.defineProperty(c.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    });
    Object.defineProperty(c.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(c.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x,
                this.end.x)
        }
    });
    Object.defineProperty(c.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x)
        }
    });
    Object.defineProperty(c.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(c.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(c.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x)
        }
    });
    Object.defineProperty(c.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y -
                this.end.y)
        }
    });
    c.Line.intersectsPoints = function(a, b, d, e, f, h) {
        "undefined" === typeof f && (f = !0);
        "undefined" === typeof h && (h = new c.Point);
        var k = b.y - a.y,
            g = e.y - d.y,
            l = a.x - b.x,
            m = d.x - e.x,
            n = b.x * a.y - a.x * b.y,
            q = e.x * d.y - d.x * e.y,
            s = k * m - g * l;
        if (0 === s) return null;
        h.x = (l * q - m * n) / s;
        h.y = (g * n - k * q) / s;
        return f && (h.x < Math.min(a.x, b.x) || h.x > Math.max(a.x, b.x) || h.y < Math.min(a.y, b.y) || h.y > Math.max(a.y, b.y) || h.x < Math.min(d.x, e.x) || h.x > Math.max(d.x, e.x) || h.y < Math.min(d.y, e.y) || h.y > Math.max(d.y, e.y)) ? null : h
    };
    c.Line.intersects = function(a,
        b, d, e) {
        return c.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e)
    };
    c.Ellipse = function(a, b, d, e) {
        this.type = c.ELLIPSE;
        this.x = a || 0;
        this.y = b || 0;
        this.width = d || 0;
        this.height = e || 0
    };
    c.Ellipse.prototype = {
        setTo: function(a, b, c, e) {
            this.x = a;
            this.y = b;
            this.width = c;
            this.height = e;
            return this
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height)
        },
        copyTo: function(a) {
            a.x = this.x;
            a.y = this.y;
            a.width = this.width;
            a.height = this.height;
            return a
        },
        clone: function(a) {
            "undefined" === typeof a ? a = new c.Ellipse(this.x,
                this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height);
            return a
        },
        contains: function(a, b) {
            return c.Ellipse.contains(this, a, b)
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
        }
    };
    c.Ellipse.prototype.constructor = c.Ellipse;
    Object.defineProperty(c.Ellipse.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(a) {
            this.x = a
        }
    });
    Object.defineProperty(c.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(a) {
            this.width = a < this.x ? 0 : this.x + a
        }
    });
    Object.defineProperty(c.Ellipse.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(a) {
            this.y = a
        }
    });
    Object.defineProperty(c.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(a) {
            this.height = a < this.y ? 0 : this.y + a
        }
    });
    Object.defineProperty(c.Ellipse.prototype, "empty", {
        get: function() {
            return 0 === this.width || 0 === this.height
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0)
        }
    });
    c.Ellipse.contains = function(a, b, c) {
        if (0 >= a.width ||
            0 >= a.height) return !1;
        b = (b - a.x) / a.width - 0.5;
        a = (c - a.y) / a.height - 0.5;
        return 0.25 > b * b + a * a
    };
    c.Ellipse.prototype.getBounds = function() {
        return new c.Rectangle(this.x, this.y, this.width, this.height)
    };
    PIXI.Ellipse = c.Ellipse;
    c.Polygon = function(a) {
        this.type = c.POLYGON;
        a instanceof Array || (a = Array.prototype.slice.call(arguments));
        if ("number" === typeof a[0]) {
            for (var b = [], d = 0, e = a.length; d < e; d += 2) b.push(new c.Point(a[d], a[d + 1]));
            a = b
        }
        this._points = a
    };
    c.Polygon.prototype = {
        clone: function() {
            for (var a = [], b = 0; b < this.points.length; b++) a.push(this.points[b].clone());
            return new c.Polygon(a)
        },
        contains: function(a, b) {
            for (var c = !1, e = 0, f = this.points.length - 1; e < this.points.length; f = e++) {
                var h = this.points[e].x,
                    k = this.points[e].y,
                    g = this.points[f].x,
                    f = this.points[f].y;
                k > b !== f > b && a < (g - h) * (b - k) / (f - k) + h && (c = !c)
            }
            return c
        }
    };
    c.Polygon.prototype.constructor = c.Polygon;
    Object.defineProperty(c.Polygon.prototype, "points", {
        get: function() {
            return this._points
        },
        set: function(a) {
            a instanceof Array || (a = Array.prototype.slice.call(arguments));
            if ("number" === typeof a[0]) {
                for (var b = [], d = 0, e =
                        a.length; d < e; d += 2) b.push(new c.Point(a[d], a[d + 1]));
                a = b
            }
            this._points = a
        }
    });
    Object.defineProperty(c.Polygon.prototype, "area", {
        get: function() {
            var a, b, c, e, f = Number.MAX_VALUE,
                h = 0;
            for (e = 0; e < this.points.length; e++) this.points[e].y < f && (f = this.points[e].y);
            for (e = 0; e < this.points.length; e++) a = this.points[e], b = e === this.points.length - 1 ? this.points[0] : this.points[e + 1], c = (a.y - f + (b.y - f)) / 2, a = a.x - b.x, h += c * a;
            return h
        }
    });
    PIXI.Polygon = c.Polygon;
    c.Camera = function(a, b, d, e, f, h) {
        this.game = a;
        this.world = a.world;
        this.id = 0;
        this.view =
            new c.Rectangle(d, e, f, h);
        this.screenView = new c.Rectangle(d, e, f, h);
        this.bounds = new c.Rectangle(d, e, f, h);
        this.deadzone = null;
        this.visible = !0;
        this.atLimit = {
            x: !1,
            y: !1
        };
        this.target = null;
        this._edge = 0;
        this.scale = this.displayObject = null
    };
    c.Camera.FOLLOW_LOCKON = 0;
    c.Camera.FOLLOW_PLATFORMER = 1;
    c.Camera.FOLLOW_TOPDOWN = 2;
    c.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    c.Camera.prototype = {
        follow: function(a, b) {
            "undefined" === typeof b && (b = c.Camera.FOLLOW_LOCKON);
            this.target = a;
            var d;
            switch (b) {
                case c.Camera.FOLLOW_PLATFORMER:
                    d = this.width /
                        8;
                    var e = this.height / 3;
                    this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - e) / 2 - 0.25 * e, d, e);
                    break;
                case c.Camera.FOLLOW_TOPDOWN:
                    d = Math.max(this.width, this.height) / 4;
                    this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - d) / 2, d, d);
                    break;
                case c.Camera.FOLLOW_TOPDOWN_TIGHT:
                    d = Math.max(this.width, this.height) / 8;
                    this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - d) / 2, d, d);
                    break;
                case c.Camera.FOLLOW_LOCKON:
                    this.deadzone = null;
                    break;
                default:
                    this.deadzone = null
            }
        },
        unfollow: function() {
            this.target =
                null
        },
        focusOn: function(a) {
            this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight))
        },
        focusOnXY: function(a, b) {
            this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight))
        },
        update: function() {
            this.target && this.updateTarget();
            this.bounds && this.checkBounds();
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y
        },
        updateTarget: function() {
            this.deadzone ? (this._edge = this.target.x - this.deadzone.x, this.view.x > this._edge &&
                (this.view.x = this._edge), this._edge = this.target.x + this.target.width - this.deadzone.x - this.deadzone.width, this.view.x < this._edge && (this.view.x = this._edge), this._edge = this.target.y - this.deadzone.y, this.view.y > this._edge && (this.view.y = this._edge), this._edge = this.target.y + this.target.height - this.deadzone.y - this.deadzone.height, this.view.y < this._edge && (this.view.y = this._edge)) : this.focusOnXY(this.target.x, this.target.y)
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y,
                this.game.world.bounds.width, this.game.world.bounds.height)
        },
        checkBounds: function() {
            this.atLimit.x = !1;
            this.atLimit.y = !1;
            this.view.x <= this.bounds.x && (this.atLimit.x = !0, this.view.x = this.bounds.x);
            this.view.right >= this.bounds.right && (this.atLimit.x = !0, this.view.x = this.bounds.right - this.width);
            this.view.y <= this.bounds.top && (this.atLimit.y = !0, this.view.y = this.bounds.top);
            this.view.bottom >= this.bounds.bottom && (this.atLimit.y = !0, this.view.y = this.bounds.bottom - this.height);
            this.view.floor()
        },
        setPosition: function(a,
            b) {
            this.view.x = a;
            this.view.y = b;
            this.bounds && this.checkBounds()
        },
        setSize: function(a, b) {
            this.view.width = a;
            this.view.height = b
        },
        reset: function() {
            this.target = null;
            this.view.x = 0;
            this.view.y = 0
        }
    };
    c.Camera.prototype.constructor = c.Camera;
    Object.defineProperty(c.Camera.prototype, "x", {
        get: function() {
            return this.view.x
        },
        set: function(a) {
            this.view.x = a;
            this.bounds && this.checkBounds()
        }
    });
    Object.defineProperty(c.Camera.prototype, "y", {
        get: function() {
            return this.view.y
        },
        set: function(a) {
            this.view.y = a;
            this.bounds && this.checkBounds()
        }
    });
    Object.defineProperty(c.Camera.prototype, "width", {
        get: function() {
            return this.view.width
        },
        set: function(a) {
            this.view.width = a
        }
    });
    Object.defineProperty(c.Camera.prototype, "height", {
        get: function() {
            return this.view.height
        },
        set: function(a) {
            this.view.height = a
        }
    });
    c.State = function() {
        this.rnd = this.physics = this.particles = this.world = this.tweens = this.time = this.stage = this.scale = this.sound = this.math = this.load = this.input = this.cache = this.camera = this.make = this.add = this.game = null
    };
    c.State.prototype = {
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        render: function() {},
        paused: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    };
    c.State.prototype.constructor = c.State;
    c.StateManager = function(a, b) {
        this.game = a;
        this.states = {};
        this._pendingState = null;
        "undefined" !== typeof b && null !== b && (this._pendingState = b);
        this._created = this._clearCache = this._clearWorld = !1;
        this._args = [];
        this.current = "";
        this.onShutDownCallback = this.onPauseUpdateCallback = this.onResumedCallback =
            this.onPausedCallback = this.onLoadRenderCallback = this.onLoadUpdateCallback = this.onPreRenderCallback = this.onRenderCallback = this.onUpdateCallback = this.onCreateCallback = this.onPreloadCallback = this.onInitCallback = null
    };
    c.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this);
            this.game.onResume.add(this.resume, this);
            this.game.load.onLoadComplete.add(this.loadComplete, this);
            null !== this._pendingState && ("string" === typeof this._pendingState ? this.start(this._pendingState, !1, !1) : this.add("default",
                this._pendingState, !0))
        },
        add: function(a, b, d) {
            "undefined" === typeof d && (d = !1);
            var e;
            b instanceof c.State ? e = b : "object" === typeof b ? (e = b, e.game = this.game) : "function" === typeof b && (e = new b(this.game));
            this.states[a] = e;
            d && (this.game.isBooted ? this.start(a) : this._pendingState = a);
            return e
        },
        remove: function(a) {
            this.current === a && (this.onPauseUpdateCallback = this.onResumedCallback = this.onPausedCallback = this.onRenderCallback = this.onUpdateCallback = this.onCreateCallback = this.onLoadUpdateCallback = this.onLoadRenderCallback =
                this.onPreloadCallback = this.onShutDownCallback = this.onInitCallback = this.callbackContext = null);
            delete this.states[a]
        },
        start: function(a, b, c) {
            "undefined" === typeof b && (b = !0);
            "undefined" === typeof c && (c = !1);
            this.checkState(a) && (this._pendingState = a, this._clearWorld = b, this._clearCache = c, 3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3)))
        },
        restart: function(a, b) {
            "undefined" === typeof a && (a = !0);
            "undefined" === typeof b && (b = !1);
            this._pendingState = this.current;
            this._clearWorld = a;
            this._clearCache =
                b;
            2 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 2))
        },
        dummy: function() {},
        preUpdate: function() {
            this._pendingState && this.game.isBooted && (this.current && (this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this._clearWorld && (this.game.world.shutdown(), !0 === this._clearCache && this.game.cache.destroy())), this.setCurrentState(this._pendingState),
                this.onPreloadCallback ? (this.game.load.reset(), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() ? this.loadComplete() : this.game.load.start()) : this.loadComplete(), this.current === this._pendingState && (this._pendingState = null))
        },
        checkState: function(a) {
            if (this.states[a]) {
                var b = !1;
                this.states[a].preload && (b = !0);
                this.states[a].create && (b = !0);
                this.states[a].update && (b = !0);
                this.states[a].render && (b = !0);
                return !1 === b ? (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : !0
            }
            console.warn("Phaser.StateManager - No state found with the key: " + a);
            return !1
        },
        link: function(a) {
            this.states[a].game = this.game;
            this.states[a].add = this.game.add;
            this.states[a].make = this.game.make;
            this.states[a].camera = this.game.camera;
            this.states[a].cache = this.game.cache;
            this.states[a].input = this.game.input;
            this.states[a].load = this.game.load;
            this.states[a].math = this.game.math;
            this.states[a].sound = this.game.sound;
            this.states[a].scale = this.game.scale;
            this.states[a].state = this;
            this.states[a].stage =
                this.game.stage;
            this.states[a].time = this.game.time;
            this.states[a].tweens = this.game.tweens;
            this.states[a].world = this.game.world;
            this.states[a].particles = this.game.particles;
            this.states[a].rnd = this.game.rnd;
            this.states[a].physics = this.game.physics
        },
        setCurrentState: function(a) {
            this.callbackContext = this.states[a];
            this.link(a);
            this.onInitCallback = this.states[a].init || this.dummy;
            this.onPreloadCallback = this.states[a].preload || null;
            this.onLoadRenderCallback = this.states[a].loadRender || null;
            this.onLoadUpdateCallback =
                this.states[a].loadUpdate || null;
            this.onCreateCallback = this.states[a].create || null;
            this.onUpdateCallback = this.states[a].update || null;
            this.onPreRenderCallback = this.states[a].preRender || null;
            this.onRenderCallback = this.states[a].render || null;
            this.onPausedCallback = this.states[a].paused || null;
            this.onResumedCallback = this.states[a].resumed || null;
            this.onPauseUpdateCallback = this.states[a].pauseUpdate || null;
            this.onShutDownCallback = this.states[a].shutdown || this.dummy;
            this.current = a;
            this._created = !1;
            this.onInitCallback.apply(this.callbackContext,
                this._args);
            this._args = []
        },
        getCurrentState: function() {
            return this.states[this.current]
        },
        loadComplete: function() {
            !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
        },
        pause: function() {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
        },
        resume: function() {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
        },
        update: function() {
            this._created &&
                this.onUpdateCallback ? this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        pauseUpdate: function() {
            this._created && this.onPauseUpdateCallback ? this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        preRender: function() {
            this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game)
        },
        render: function() {
            this._created && this.onRenderCallback ? (this.game.renderType === c.CANVAS && (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0)), this.onRenderCallback.call(this.callbackContext, this.game), this.game.renderType === c.CANVAS && this.game.context.restore()) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
        },
        destroy: function() {
            this.game = this.onPauseUpdateCallback = this.onResumedCallback = this.onPausedCallback = this.onRenderCallback = this.onUpdateCallback =
                this.onCreateCallback = this.onLoadUpdateCallback = this.onLoadRenderCallback = this.onPreloadCallback = this.onShutDownCallback = this.onInitCallback = this.callbackContext = null;
            this.states = {};
            this._pendingState = null
        }
    };
    c.StateManager.prototype.constructor = c.StateManager;
    c.LinkedList = function() {
        this.last = this.first = this.prev = this.next = null;
        this.total = 0
    };
    c.LinkedList.prototype = {
        add: function(a) {
            if (0 === this.total && null === this.first && null === this.last) return this.next = this.last = this.first = a, a.prev = this, this.total++,
                a;
            this.last.next = a;
            a.prev = this.last;
            this.last = a;
            this.total++;
            return a
        },
        reset: function() {
            this.prev = this.next = this.last = this.first = null;
            this.total = 0
        },
        remove: function(a) {
            1 === this.total ? (this.reset(), a.next = a.prev = null) : (a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev), a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), a.next = a.prev = null, null === this.first && (this.last = null), this.total--)
        },
        callAll: function(a) {
            if (this.first && this.last) {
                var b = this.first;
                do b && b[a] &&
                    b[a].call(b), b = b.next; while (b != this.last.next)
            }
        }
    };
    c.LinkedList.prototype.constructor = c.LinkedList;
    c.ArrayList = function() {
        this.position = this.total = 0;
        this.list = []
    };
    c.ArrayList.prototype = {
        add: function(a) {
            this.exists(a) || (this.list.push(a), this.total++);
            return a
        },
        getIndex: function(a) {
            return this.list.indexOf(a)
        },
        exists: function(a) {
            return -1 < this.list.indexOf(a)
        },
        reset: function() {
            this.total = this.list.length = 0
        },
        remove: function(a) {
            var b = this.list.indexOf(a);
            if (-1 < b) return this.list.splice(b, 1), this.total--,
                a
        },
        callAll: function(a) {
            for (var b = Array.prototype.splice.call(arguments, 1), c = this.list.length; c--;) this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b)
        }
    };
    Object.defineProperty(c.ArrayList.prototype, "first", {
        get: function() {
            this.position = 0;
            return 0 < this.total ? this.list[0] : null
        }
    });
    Object.defineProperty(c.ArrayList.prototype, "next", {
        get: function() {
            return this.position < this.total ? (this.position++, this.list[this.position]) : null
        }
    });
    c.ArrayList.prototype.constructor = c.ArrayList;
    c.Signal = function() {
        this._bindings = [];
        this._prevParams = null;
        var a = this;
        this.dispatch = function() {
            c.Signal.prototype.dispatch.apply(a, arguments)
        }
    };
    c.Signal.prototype = {
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        validateListener: function(a, b) {
            if ("function" !== typeof a) throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
        },
        _registerListener: function(a, b, d, e) {
            var f = this._indexOfListener(a, d);
            if (-1 !== f) {
                if (a = this._bindings[f], a.isOnce() !== b) throw Error("You cannot add" + (b ? "" : "Once") + "() then add" +
                    (!b ? "" : "Once") + "() the same listener without removing the relationship first.");
            } else a = new c.SignalBinding(this, a, b, d, e), this._addBinding(a);
            this.memorize && this._prevParams && a.execute(this._prevParams);
            return a
        },
        _addBinding: function(a) {
            var b = this._bindings.length;
            do --b; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
            this._bindings.splice(b + 1, 0, a)
        },
        _indexOfListener: function(a, b) {
            for (var c = this._bindings.length, e; c--;)
                if (e = this._bindings[c], e._listener === a && e.context === b) return c;
            return -1
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b)
        },
        add: function(a, b, c) {
            this.validateListener(a, "add");
            return this._registerListener(a, !1, b, c)
        },
        addOnce: function(a, b, c) {
            this.validateListener(a, "addOnce");
            return this._registerListener(a, !0, b, c)
        },
        remove: function(a, b) {
            this.validateListener(a, "remove");
            var c = this._indexOfListener(a, b); - 1 !== c && (this._bindings[c]._destroy(), this._bindings.splice(c, 1));
            return a
        },
        removeAll: function() {
            for (var a = this._bindings.length; a--;) this._bindings[a]._destroy();
            this._bindings.length = 0
        },
        getNumListeners: function() {
            return this._bindings.length
        },
        halt: function() {
            this._shouldPropagate = !1
        },
        dispatch: function() {
            if (this.active) {
                var a = Array.prototype.slice.call(arguments),
                    b = this._bindings.length,
                    c;
                this.memorize && (this._prevParams = a);
                if (b) {
                    c = this._bindings.slice();
                    this._shouldPropagate = !0;
                    do b--; while (c[b] && this._shouldPropagate && !1 !== c[b].execute(a))
                }
            }
        },
        forget: function() {
            this._prevParams = null
        },
        dispose: function() {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    };
    c.Signal.prototype.constructor = c.Signal;
    c.SignalBinding = function(a, b, c, e, f) {
        this._listener = b;
        this._isOnce = c;
        this.context = e;
        this._signal = a;
        this._priority = f || 0
    };
    c.SignalBinding.prototype = {
        active: !0,
        params: null,
        execute: function(a) {
            var b;
            this.active && this._listener && (a = this.params ? this.params.concat(a) : a, b = this._listener.apply(this.context, a), this._isOnce && this.detach());
            return b
        },
        detach: function() {
            return this.isBound() ?
                this._signal.remove(this._listener, this.context) : null
        },
        isBound: function() {
            return !!this._signal && !!this._listener
        },
        isOnce: function() {
            return this._isOnce
        },
        getListener: function() {
            return this._listener
        },
        getSignal: function() {
            return this._signal
        },
        _destroy: function() {
            delete this._signal;
            delete this._listener;
            delete this.context
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    };
    c.SignalBinding.prototype.constructor = c.SignalBinding;
    c.Filter = function(a, b, d) {
        this.game = a;
        this.type = c.WEBGL_FILTER;
        this.passes = [this];
        this.shaders = [];
        this.dirty = !0;
        this.padding = 0;
        this.uniforms = {
            time: {
                type: "1f",
                value: 0
            },
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            }
        };
        this.fragmentSrc = d || []
    };
    c.Filter.prototype = {
        init: function() {},
        setResolution: function(a, b) {
            this.uniforms.resolution.value.x = a;
            this.uniforms.resolution.value.y = b
        },
        update: function(a) {
            "undefined" !== typeof a && (0 < a.x && (this.uniforms.mouse.x = a.x.toFixed(2)), 0 < a.y &&
                (this.uniforms.mouse.y = a.y.toFixed(2)));
            this.uniforms.time.value = this.game.time.totalElapsedSeconds()
        },
        destroy: function() {
            this.game = null
        }
    };
    c.Filter.prototype.constructor = c.Filter;
    Object.defineProperty(c.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x
        },
        set: function(a) {
            this.uniforms.resolution.value.x = a
        }
    });
    Object.defineProperty(c.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y
        },
        set: function(a) {
            this.uniforms.resolution.value.y = a
        }
    });
    c.Plugin =
        function(a, b) {
            "undefined" === typeof b && (b = null);
            this.game = a;
            this.parent = b;
            this.hasPostRender = this.hasRender = this.hasPostUpdate = this.hasUpdate = this.hasPreUpdate = this.visible = this.active = !1
        };
    c.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.parent = this.game = null;
            this.visible = this.active = !1
        }
    };
    c.Plugin.prototype.constructor = c.Plugin;
    c.PluginManager = function(a) {
        this.game = a;
        this.plugins = [];
        this._i = this._len = 0
    };
    c.PluginManager.prototype = {
        add: function(a) {
            var b = Array.prototype.splice.call(arguments, 1),
                c = !1;
            "function" === typeof a ? a = new a(this.game, this) : (a.game = this.game, a.parent = this);
            "function" === typeof a.preUpdate && (c = a.hasPreUpdate = !0);
            "function" === typeof a.update && (c = a.hasUpdate = !0);
            "function" === typeof a.postUpdate && (c = a.hasPostUpdate = !0);
            "function" === typeof a.render && (c = a.hasRender = !0);
            "function" === typeof a.postRender && (c = a.hasPostRender = !0);
            if (c) {
                if (a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) a.active = !0;
                if (a.hasRender || a.hasPostRender) a.visible = !0;
                this._len = this.plugins.push(a);
                "function" === typeof a.init && a.init.apply(a, b);
                return a
            }
            return null
        },
        remove: function(a) {
            for (this._i = this._len; this._i--;)
                if (this.plugins[this._i] === a) {
                    a.destroy();
                    this.plugins.splice(this._i, 1);
                    this._len--;
                    break
                }
        },
        removeAll: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
            this._len = this.plugins.length = 0
        },
        preUpdate: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
        },
        update: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
        },
        postUpdate: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
        },
        render: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
        },
        postRender: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible &&
                this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
        },
        destroy: function() {
            this.removeAll();
            this.game = null
        }
    };
    c.PluginManager.prototype.constructor = c.PluginManager;
    c.Stage = function(a, b, d) {
        this.game = a;
        this.offset = new c.Point;
        this.bounds = new c.Rectangle(0, 0, b, d);
        PIXI.Stage.call(this, 0, !1);
        this.name = "_stage_root";
        this.disableVisibilityChange = this.interactive = !1;
        this.checkOffsetInterval = 2500;
        this.exists = !0;
        this.currentRenderOrderID = 0;
        this._hiddenVar = "hidden";
        this._backgroundColor = this._nextOffsetCheck =
            0;
        a.config ? this.parseConfig(a.config) : (this.game.canvas = c.Canvas.create(b, d), this.game.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%")
    };
    c.Stage.prototype = Object.create(PIXI.Stage.prototype);
    c.Stage.prototype.constructor = c.Stage;
    c.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for (var a = this.children.length, b = 0; b < a; b++) this.children[b].preUpdate()
    };
    c.Stage.prototype.update = function() {
        for (var a = this.children.length; a--;) this.children[a].update()
    };
    c.Stage.prototype.postUpdate =
        function() {
            if (this.game.world.camera.target) {
                this.game.world.camera.target.postUpdate();
                this.game.world.camera.update();
                for (var a = this.children.length; a--;) this.children[a] !== this.game.world.camera.target && this.children[a].postUpdate()
            } else {
                this.game.world.camera.update();
                for (a = this.children.length; a--;) this.children[a].postUpdate()
            }!1 !== this.checkOffsetInterval && this.game.time.now > this._nextOffsetCheck && (c.Canvas.getOffset(this.game.canvas, this.offset), this.bounds.x = this.offset.x, this.bounds.y = this.offset.y,
                this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval)
        };
    c.Stage.prototype.parseConfig = function(a) {
        this.game.canvas = a.canvasID ? c.Canvas.create(this.game.width, this.game.height, a.canvasID) : c.Canvas.create(this.game.width, this.game.height);
        a.canvasStyle ? this.game.canvas.stlye = a.canvasStyle : this.game.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
        a.checkOffsetInterval && (this.checkOffsetInterval = a.checkOffsetInterval);
        a.disableVisibilityChange && (this.disableVisibilityChange =
            a.disableVisibilityChange);
        a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode);
        a.scaleMode && (this.scaleMode = a.scaleMode);
        a.backgroundColor && (this.backgroundColor = a.backgroundColor)
    };
    c.Stage.prototype.boot = function() {
        c.Canvas.getOffset(this.game.canvas, this.offset);
        this.bounds.setTo(this.offset.x, this.offset.y, this.game.width, this.game.height);
        var a = this;
        this._onChange = function(b) {
            return a.visibilityChange(b)
        };
        c.Canvas.setUserSelect(this.game.canvas, "none");
        c.Canvas.setTouchAction(this.game.canvas,
            "none");
        this.checkVisibility()
    };
    c.Stage.prototype.checkVisibility = function() {
        (this._hiddenVar = void 0 !== document.webkitHidden ? "webkitvisibilitychange" : void 0 !== document.mozHidden ? "mozvisibilitychange" : void 0 !== document.msHidden ? "msvisibilitychange" : void 0 !== document.hidden ? "visibilitychange" : null) && document.addEventListener(this._hiddenVar, this._onChange, !1);
        window.onpagehide = this._onChange;
        window.onpageshow = this._onChange;
        window.onblur = this._onChange;
        window.onfocus = this._onChange
    };
    c.Stage.prototype.visibilityChange =
        function(a) {
            this.disableVisibilityChange || ("pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type ? "pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : ("pageshow" === a.type || "focus" === a.type) && this.game.focusGain(a) : document.hidden || document.mozHidden || document.msHidden || document.webkitHidden ? this.game.gamePaused(a) : this.game.gameResumed(a))
        };
    c.Stage.prototype.setBackgroundColor = function(a) {
        if ("string" === typeof a) {
            var b = c.Color.hexToColor(a);
            this._backgroundColor = c.Color.getColor(b.r,
                b.g, b.b)
        } else b = c.Color.getRGB(a), this._backgroundColor = a;
        this.backgroundColorSplit = [b.r / 255, b.g / 255, b.b / 255];
        this.backgroundColorString = c.Color.RGBtoString(b.r, b.g, b.b, 255, "#")
    };
    Object.defineProperty(c.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor
        },
        set: function(a) {
            this.game.transparent || this.setBackgroundColor(a)
        }
    });
    Object.defineProperty(c.Stage.prototype, "smoothed", {
        get: function() {
            return !PIXI.scaleModes.LINEAR
        },
        set: function(a) {
            PIXI.scaleModes.LINEAR = a ? 0 : 1
        }
    });
    c.Group =
        function(a, b, d, e, f, h) {
            "undefined" === typeof e && (e = !1);
            "undefined" === typeof f && (f = !1);
            "undefined" === typeof h && (h = c.Physics.ARCADE);
            this.game = a;
            "undefined" === typeof b && (b = a.world);
            this.name = d || "group";
            PIXI.DisplayObjectContainer.call(this);
            e ? this.game.stage.addChild(this) : b && b.addChild(this);
            this.z = 0;
            this.type = c.GROUP;
            this.exists = this.alive = !0;
            this.classType = c.Sprite;
            this.scale = new c.Point(1, 1);
            this.cursor = null;
            this.cameraOffset = new c.Point;
            this.enableBody = f;
            this.enableBodyDebug = !1;
            this.physicsBodyType =
                h;
            this._sortProperty = "z";
            this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]
        };
    c.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    c.Group.prototype.constructor = c.Group;
    c.Group.RETURN_NONE = 0;
    c.Group.RETURN_TOTAL = 1;
    c.Group.RETURN_CHILD = 2;
    c.Group.SORT_ASCENDING = -1;
    c.Group.SORT_DESCENDING = 1;
    c.Group.prototype.add = function(a) {
        a.parent !== this && (this.enableBody && this.game.physics.enable(a, this.physicsBodyType), this.addChild(a), a.z = this.children.length, a.events && a.events.onAddedToGroup.dispatch(a, this), null ===
            this.cursor && (this.cursor = a));
        return a
    };
    c.Group.prototype.addAt = function(a, b) {
        a.parent !== this && (this.enableBody && this.game.physics.enable(a, this.physicsBodyType), this.addChildAt(a, b), this.updateZ(), a.events && a.events.onAddedToGroup.dispatch(a, this), null === this.cursor && (this.cursor = a));
        return a
    };
    c.Group.prototype.getAt = function(a) {
        return 0 > a || a >= this.children.length ? -1 : this.getChildAt(a)
    };
    c.Group.prototype.create = function(a, b, c, e, f) {
        "undefined" === typeof f && (f = !0);
        a = new this.classType(this.game, a, b,
            c, e);
        this.enableBody && this.game.physics.enable(a, this.physicsBodyType);
        a.exists = f;
        a.visible = f;
        a.alive = f;
        this.addChild(a);
        a.z = this.children.length;
        a.events && a.events.onAddedToGroup.dispatch(a, this);
        null === this.cursor && (this.cursor = a);
        return a
    };
    c.Group.prototype.createMultiple = function(a, b, c, e) {
        "undefined" === typeof e && (e = !1);
        for (var f = 0; f < a; f++) this.create(0, 0, b, c, e)
    };
    c.Group.prototype.updateZ = function() {
        for (var a = this.children.length; a--;) this.children[a].z = a
    };
    c.Group.prototype.resetCursor = function(a) {
        "undefined" ===
        typeof a && (a = 0);
        a > this.children.length - 1 && (a = 0);
        if (this.cursor) return this._cache[8] = a, this.cursor = this.children[this._cache[8]]
    };
    c.Group.prototype.next = function() {
        if (this.cursor) return this._cache[8] >= this.children.length - 1 ? this._cache[8] = 0 : this._cache[8]++, this.cursor = this.children[this._cache[8]]
    };
    c.Group.prototype.previous = function() {
        if (this.cursor) return 0 === this._cache[8] ? this._cache[8] = this.children.length - 1 : this._cache[8]--, this.cursor = this.children[this._cache[8]]
    };
    c.Group.prototype.swap =
        function(a, b) {
            var c = this.swapChildren(a, b);
            c && this.updateZ();
            return c
        };
    c.Group.prototype.bringToTop = function(a) {
        a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a), this.add(a));
        return a
    };
    c.Group.prototype.sendToBack = function(a) {
        a.parent === this && 0 < this.getIndex(a) && (this.remove(a), this.addAt(a, 0));
        return a
    };
    c.Group.prototype.moveUp = function(a) {
        if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
            var b = this.getIndex(a);
            (b = this.getAt(b + 1)) && this.swap(a, b)
        }
        return a
    };
    c.Group.prototype.moveDown =
        function(a) {
            if (a.parent === this && 0 < this.getIndex(a)) {
                var b = this.getIndex(a);
                (b = this.getAt(b - 1)) && this.swap(a, b)
            }
            return a
        };
    c.Group.prototype.xy = function(a, b, c) {
        if (0 > a || a > this.children.length) return -1;
        this.getChildAt(a).x = b;
        this.getChildAt(a).y = c
    };
    c.Group.prototype.reverse = function() {
        this.children.reverse();
        this.updateZ()
    };
    c.Group.prototype.getIndex = function(a) {
        return this.children.indexOf(a)
    };
    c.Group.prototype.replace = function(a, b) {
        var d = this.getIndex(a);
        if (-1 !== d) return void 0 !== b.parent && (b.events.onRemovedFromGroup.dispatch(b,
            this), b.parent.removeChild(b), b.parent instanceof c.Group && b.parent.updateZ()), this.remove(a), this.addAt(b, d), a
    };
    c.Group.prototype.hasProperty = function(a, b) {
        var c = b.length;
        return 1 === c && b[0] in a || 2 === c && b[0] in a && b[1] in a[b[0]] || 3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] || 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]] ? !0 : !1
    };
    c.Group.prototype.setProperty = function(a, b, c, e, f) {
        "undefined" === typeof f && (f = !1);
        e = e || 0;
        if (!this.hasProperty(a, b) && (!f || 0 < e)) return !1;
        f = b.length;
        1 === f ? 0 === e ? a[b[0]] = c : 1 == e ? a[b[0]] += c : 2 == e ? a[b[0]] -= c : 3 == e ? a[b[0]] *= c : 4 == e && (a[b[0]] /= c) : 2 === f ? 0 === e ? a[b[0]][b[1]] = c : 1 == e ? a[b[0]][b[1]] += c : 2 == e ? a[b[0]][b[1]] -= c : 3 == e ? a[b[0]][b[1]] *= c : 4 == e && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === e ? a[b[0]][b[1]][b[2]] = c : 1 == e ? a[b[0]][b[1]][b[2]] += c : 2 == e ? a[b[0]][b[1]][b[2]] -= c : 3 == e ? a[b[0]][b[1]][b[2]] *= c : 4 == e && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === e ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 == e ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 == e ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 == e ? a[b[0]][b[1]][b[2]][b[3]] *=
            c : 4 == e && (a[b[0]][b[1]][b[2]][b[3]] /= c));
        return !0
    };
    c.Group.prototype.set = function(a, b, c, e, f, h, k) {
        "undefined" === typeof k && (k = !1);
        b = b.split(".");
        "undefined" === typeof e && (e = !1);
        "undefined" === typeof f && (f = !1);
        if ((!1 === e || e && a.alive) && (!1 === f || f && a.visible)) return this.setProperty(a, b, c, h, k)
    };
    c.Group.prototype.setAll = function(a, b, c, e, f, h) {
        "undefined" === typeof c && (c = !1);
        "undefined" === typeof e && (e = !1);
        "undefined" === typeof h && (h = !1);
        a = a.split(".");
        f = f || 0;
        for (var k = 0, g = this.children.length; k < g; k++)(!c || c &&
            this.children[k].alive) && (!e || e && this.children[k].visible) && this.setProperty(this.children[k], a, b, f, h)
    };
    c.Group.prototype.setAllChildren = function(a, b, d, e, f, h) {
        "undefined" === typeof d && (d = !1);
        "undefined" === typeof e && (e = !1);
        "undefined" === typeof h && (h = !1);
        f = f || 0;
        for (var k = 0, g = this.children.length; k < g; k++)
            if ((!d || d && this.children[k].alive) && (!e || e && this.children[k].visible)) this.children[k] instanceof c.Group ? this.children[k].setAllChildren(a, b, d, e, f, h) : this.setProperty(this.children[k], a.split("."), b,
                f, h)
    };
    c.Group.prototype.addAll = function(a, b, c, e) {
        this.setAll(a, b, c, e, 1)
    };
    c.Group.prototype.subAll = function(a, b, c, e) {
        this.setAll(a, b, c, e, 2)
    };
    c.Group.prototype.multiplyAll = function(a, b, c, e) {
        this.setAll(a, b, c, e, 3)
    };
    c.Group.prototype.divideAll = function(a, b, c, e) {
        this.setAll(a, b, c, e, 4)
    };
    c.Group.prototype.callAllExists = function(a, b) {
        for (var c = Array.prototype.splice.call(arguments, 2), e = 0, f = this.children.length; e < f; e++) this.children[e].exists === b && this.children[e][a] && this.children[e][a].apply(this.children[e],
            c)
    };
    c.Group.prototype.callbackFromArray = function(a, b, c) {
        if (1 == c) {
            if (a[b[0]]) return a[b[0]]
        } else if (2 == c) {
            if (a[b[0]][b[1]]) return a[b[0]][b[1]]
        } else if (3 == c) {
            if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]]
        } else if (4 == c) {
            if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]]
        } else if (a[b]) return a[b];
        return !1
    };
    c.Group.prototype.callAll = function(a, b) {
        if ("undefined" !== typeof a) {
            a = a.split(".");
            var c = a.length;
            if ("undefined" === typeof b || null === b || "" === b) b = null;
            else if ("string" === typeof b) {
                b = b.split(".");
                var e = b.length
            }
            for (var f = Array.prototype.splice.call(arguments, 2), h = null, k = null, g = 0, l = this.children.length; g < l; g++) h = this.callbackFromArray(this.children[g], a, c), b && h ? (k = this.callbackFromArray(this.children[g], b, e), h && h.apply(k, f)) : h && h.apply(this.children[g], f)
        }
    };
    c.Group.prototype.preUpdate = function() {
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        for (var a = this.children.length; a--;) this.children[a].preUpdate();
        return !0
    };
    c.Group.prototype.update = function() {
        for (var a = this.children.length; a--;) this.children[a].update()
    };
    c.Group.prototype.postUpdate = function() {
        1 === this._cache[7] && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
        for (var a = this.children.length; a--;) this.children[a].postUpdate()
    };
    c.Group.prototype.forEach = function(a, b, c) {
        "undefined" === typeof c && (c = !1);
        var e = Array.prototype.splice.call(arguments, 3);
        e.unshift(null);
        for (var f = 0, h = this.children.length; f < h; f++)
            if (!c || c && this.children[f].exists) e[0] = this.children[f], a.apply(b, e)
    };
    c.Group.prototype.forEachExists =
        function(a, b) {
            var d = Array.prototype.splice.call(arguments, 2);
            d.unshift(null);
            this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d)
        };
    c.Group.prototype.forEachAlive = function(a, b) {
        var d = Array.prototype.splice.call(arguments, 2);
        d.unshift(null);
        this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d)
    };
    c.Group.prototype.forEachDead = function(a, b) {
        var d = Array.prototype.splice.call(arguments, 2);
        d.unshift(null);
        this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d)
    };
    c.Group.prototype.sort = function(a, b) {
        2 > this.children.length ||
            ("undefined" === typeof a && (a = "z"), "undefined" === typeof b && (b = c.Group.SORT_ASCENDING), this._sortProperty = a, b === c.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
    };
    c.Group.prototype.customSort = function(a, b) {
        2 > this.children.length || (this.children.sort(a.bind(b)), this.updateZ())
    };
    c.Group.prototype.ascendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] >
            b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1
    };
    c.Group.prototype.descendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0
    };
    c.Group.prototype.iterate = function(a, b, d, e, f, h) {
        if (d === c.Group.RETURN_TOTAL && 0 === this.children.length) return 0;
        "undefined" === typeof e && (e = !1);
        for (var k = 0, g = 0, l = this.children.length; g < l; g++)
            if (this.children[g][a] === b && (k++, e && (h[0] = this.children[g], e.apply(f, h)), d === c.Group.RETURN_CHILD)) return this.children[g];
        if (d === c.Group.RETURN_TOTAL) return k;
        if (d === c.Group.RETURN_CHILD) return null
    };
    c.Group.prototype.getFirstExists = function(a) {
        "boolean" !== typeof a && (a = !0);
        return this.iterate("exists", a, c.Group.RETURN_CHILD)
    };
    c.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", !0, c.Group.RETURN_CHILD)
    };
    c.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", !1, c.Group.RETURN_CHILD)
    };
    c.Group.prototype.getTop = function() {
        if (0 < this.children.length) return this.children[this.children.length -
            1]
    };
    c.Group.prototype.getBottom = function() {
        if (0 < this.children.length) return this.children[0]
    };
    c.Group.prototype.countLiving = function() {
        return this.iterate("alive", !0, c.Group.RETURN_TOTAL)
    };
    c.Group.prototype.countDead = function() {
        return this.iterate("alive", !1, c.Group.RETURN_TOTAL)
    };
    c.Group.prototype.getRandom = function(a, b) {
        if (0 === this.children.length) return null;
        b = b || this.children.length;
        return this.game.math.getRandom(this.children, a || 0, b)
    };
    c.Group.prototype.remove = function(a, b) {
        "undefined" === typeof b &&
            (b = !1);
        if (0 === this.children.length || -1 === this.children.indexOf(a)) return !1;
        a.events && !a.destroyPhase && a.events.onRemovedFromGroup.dispatch(a, this);
        var c = this.removeChild(a);
        this.updateZ();
        this.cursor === a && this.next();
        b && c && c.destroy(!0);
        return !0
    };
    c.Group.prototype.removeAll = function(a) {
        "undefined" === typeof a && (a = !1);
        if (0 !== this.children.length) {
            do {
                this.children[0].events && this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this);
                var b = this.removeChild(this.children[0]);
                a && b && b.destroy(!0)
            } while (0 <
                this.children.length);
            this.cursor = null
        }
    };
    c.Group.prototype.removeBetween = function(a, b, c) {
        "undefined" === typeof b && (b = this.children.length);
        "undefined" === typeof c && (c = !1);
        if (0 !== this.children.length) {
            if (a > b || 0 > a || b > this.children.length) return !1;
            for (; b >= a;) {
                this.children[b].events && this.children[b].events.onRemovedFromGroup.dispatch(this.children[b], this);
                var e = this.removeChild(this.children[b]);
                c && e && e.destroy(!0);
                this.cursor === this.children[b] && (this.cursor = null);
                b--
            }
            this.updateZ()
        }
    };
    c.Group.prototype.destroy =
        function(a, b) {
            null !== this.game && ("undefined" === typeof a && (a = !0), "undefined" === typeof b && (b = !1), this.removeAll(a), this.cursor = null, b || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        };
    Object.defineProperty(c.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", !0, c.Group.RETURN_TOTAL)
        }
    });
    Object.defineProperty(c.Group.prototype, "length", {
        get: function() {
            return this.children.length
        }
    });
    Object.defineProperty(c.Group.prototype, "angle", {
        get: function() {
            return c.Math.radToDeg(this.rotation)
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(a)
        }
    });
    Object.defineProperty(c.Group.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    c.World = function(a) {
        c.Group.call(this, a, null, "__world", !1);
        this.bounds = new c.Rectangle(0, 0, a.width, a.height);
        this.camera = null
    };
    c.World.prototype = Object.create(c.Group.prototype);
    c.World.prototype.constructor = c.World;
    c.World.prototype.boot = function() {
        this.camera =
            new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this;
        this.camera.scale = this.scale;
        this.game.camera = this.camera;
        this.game.stage.addChild(this)
    };
    c.World.prototype.setBounds = function(a, b, c, e) {
        c < this.game.width && (c = this.game.width);
        e < this.game.height && (e = this.game.height);
        this.bounds.setTo(a, b, c, e);
        this.camera.bounds && this.camera.bounds.setTo(a, b, c, e);
        this.game.physics.setBoundsToWorld()
    };
    c.World.prototype.shutdown = function() {
        this.destroy(!0, !0)
    };
    c.World.prototype.wrap =
        function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = !1);
            c ? (a.getBounds(), a._currentBounds.right < this.bounds.x ? a.x = this.bounds.right : a._currentBounds.x > this.bounds.right && (a.x = this.bounds.left), a._currentBounds.bottom < this.bounds.top ? a.y = this.bounds.bottom : a._currentBounds.top > this.bounds.bottom && (a.y = this.bounds.top)) : (a.x + b < this.bounds.x ? a.x = this.bounds.right + b : a.x - b > this.bounds.right && (a.x = this.bounds.left - b), a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : a.y - b > this.bounds.bottom &&
                (a.y = this.bounds.top - b))
        };
    Object.defineProperty(c.World.prototype, "width", {
        get: function() {
            return this.bounds.width
        },
        set: function(a) {
            this.bounds.width = a
        }
    });
    Object.defineProperty(c.World.prototype, "height", {
        get: function() {
            return this.bounds.height
        },
        set: function(a) {
            this.bounds.height = a
        }
    });
    Object.defineProperty(c.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth
        }
    });
    Object.defineProperty(c.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight
        }
    });
    Object.defineProperty(c.World.prototype,
        "randomX", {
            get: function() {
                return 0 > this.bounds.x ? this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.integerInRange(this.bounds.x, this.bounds.width)
            }
        });
    Object.defineProperty(c.World.prototype, "randomY", {
        get: function() {
            return 0 > this.bounds.y ? this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.integerInRange(this.bounds.y, this.bounds.height)
        }
    });
    c.ScaleManager = function(a, b, d) {
        this.game = a;
        this.width = b;
        this.height =
            d;
        this.maxHeight = this.minHeight = this.maxWidth = this.minWidth = null;
        this.pageAlignVertically = this.pageAlignHorizontally = this.incorrectOrientation = this.forcePortrait = this.forceLandscape = !1;
        this.maxIterations = 5;
        this.orientationSprite = null;
        this.enterLandscape = new c.Signal;
        this.enterPortrait = new c.Signal;
        this.enterIncorrectOrientation = new c.Signal;
        this.leaveIncorrectOrientation = new c.Signal;
        this.hasResized = new c.Signal;
        this.fullScreenTarget = this.game.canvas;
        this.enterFullScreen = new c.Signal;
        this.leaveFullScreen =
            new c.Signal;
        this.orientation = 0;
        window.orientation ? this.orientation = window.orientation : window.outerWidth > window.outerHeight && (this.orientation = 90);
        this.scaleFactor = new c.Point(1, 1);
        this.scaleFactorInversed = new c.Point(1, 1);
        this.margin = new c.Point(0, 0);
        this.bounds = new c.Rectangle(0, 0, b, d);
        this.aspectRatio = 0;
        this.sourceAspectRatio = b / d;
        this.event = null;
        this.fullScreenScaleMode = this.scaleMode = c.ScaleManager.NO_SCALE;
        this._height = this._width = this._startHeight = 0;
        this._check = null;
        var e = this;
        window.addEventListener("orientationchange",
            function(a) {
                return e.checkOrientation(a)
            }, !1);
        window.addEventListener("resize", function(a) {
            return e.checkResize(a)
        }, !1);
        document.addEventListener("webkitfullscreenchange", function(a) {
            return e.fullScreenChange(a)
        }, !1);
        document.addEventListener("mozfullscreenchange", function(a) {
            return e.fullScreenChange(a)
        }, !1);
        document.addEventListener("fullscreenchange", function(a) {
            return e.fullScreenChange(a)
        }, !1)
    };
    c.ScaleManager.EXACT_FIT = 0;
    c.ScaleManager.NO_SCALE = 1;
    c.ScaleManager.SHOW_ALL = 2;
    c.ScaleManager.prototype = {
        startFullScreen: function(a) {
            if (!this.isFullScreen && this.game.device.fullscreen)
                if ("undefined" !== typeof a && this.game.renderType === c.CANVAS && (this.game.stage.smoothed = a), this._width = this.width, this._height = this.height, this.game.device.fullscreenKeyboard) this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
                else this.fullScreenTarget[this.game.device.requestFullscreen]()
        },
        stopFullScreen: function() {
            this.fullScreenTarget[this.game.device.cancelFullscreen]()
        },
        fullScreenChange: function(a) {
            this.event =
                a;
            this.isFullScreen ? (this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT ? (this.fullScreenTarget.style.width = "100%", this.fullScreenTarget.style.height = "100%", this.width = window.outerWidth, this.height = window.outerHeight, this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height), this.aspectRatio = this.width / this.height, this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.checkResize()) : this.fullScreenScaleMode === c.ScaleManager.SHOW_ALL &&
                (this.setShowAll(), this.refresh()), this.enterFullScreen.dispatch(this.width, this.height)) : (this.fullScreenTarget.style.width = this.game.width + "px", this.fullScreenTarget.style.height = this.game.height + "px", this.width = this._width, this.height = this._height, this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height), this.aspectRatio = this.width / this.height, this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.leaveFullScreen.dispatch(this.width,
                this.height))
        },
        forceOrientation: function(a, b, d) {
            "undefined" === typeof b && (b = !1);
            this.forceLandscape = a;
            this.forcePortrait = b;
            if ("undefined" !== typeof d) {
                if (null === d || !1 === this.game.cache.checkImageKey(d)) d = "__default";
                this.orientationSprite = new c.Image(this.game, this.game.width / 2, this.game.height / 2, PIXI.TextureCache[d]);
                this.orientationSprite.anchor.set(0.5);
                this.checkOrientationState();
                this.incorrectOrientation ? (this.orientationSprite.visible = !0, this.game.world.visible = !1) : (this.orientationSprite.visible = !1, this.game.world.visible = !0);
                this.game.stage.addChild(this.orientationSprite)
            }
        },
        checkOrientationState: function() {
            if (this.incorrectOrientation) {
                if (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) this.incorrectOrientation = !1, this.leaveIncorrectOrientation.dispatch(), this.orientationSprite && (this.orientationSprite.visible = !1, this.game.world.visible = !0), this.scaleMode !== c.ScaleManager.NO_SCALE && this.refresh()
            } else if (this.forceLandscape &&
                window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) this.incorrectOrientation = !0, this.enterIncorrectOrientation.dispatch(), this.orientationSprite && !1 === this.orientationSprite.visible && (this.orientationSprite.visible = !0, this.game.world.visible = !1), this.scaleMode !== c.ScaleManager.NO_SCALE && this.refresh()
        },
        checkOrientation: function(a) {
            this.event = a;
            this.orientation = window.orientation;
            this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0);
            this.scaleMode !== c.ScaleManager.NO_SCALE && this.refresh()
        },
        checkResize: function(a) {
            this.event = a;
            this.orientation = window.outerWidth > window.outerHeight ? 90 : 0;
            this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0);
            this.scaleMode !== c.ScaleManager.NO_SCALE && this.refresh();
            this.checkOrientationState()
        },
        refresh: function() {
            !this.game.device.iPad && (!this.game.device.webApp && !this.game.device.desktop) && (this.game.device.android && !this.game.device.chrome ?
                window.scrollTo(0, 1) : window.scrollTo(0, 0));
            if (null === this._check && 0 < this.maxIterations) {
                this._iterations = this.maxIterations;
                var a = this;
                this._check = window.setInterval(function() {
                    return a.setScreenSize()
                }, 10);
                this.setScreenSize()
            }
        },
        setScreenSize: function(a) {
            "undefined" === typeof a && (a = !1);
            !this.game.device.iPad && (!this.game.device.webApp && !this.game.device.desktop) && (this.game.device.android && !this.game.device.chrome ? window.scrollTo(0, 1) : window.scrollTo(0, 0));
            this._iterations--;
            if (a || window.innerHeight >
                this._startHeight || 0 > this._iterations) document.documentElement.style.minHeight = window.innerHeight + "px", this.incorrectOrientation ? this.setMaximum() : this.isFullScreen ? this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT ? this.setExactFit() : this.fullScreenScaleMode === c.ScaleManager.SHOW_ALL && this.setShowAll() : this.scaleMode === c.ScaleManager.EXACT_FIT ? this.setExactFit() : this.scaleMode === c.ScaleManager.SHOW_ALL && this.setShowAll(), this.setSize(), clearInterval(this._check), this._check = null
        },
        setSize: function() {
            this.incorrectOrientation ||
                (this.maxWidth && this.width > this.maxWidth && (this.width = this.maxWidth), this.maxHeight && this.height > this.maxHeight && (this.height = this.maxHeight), this.minWidth && this.width < this.minWidth && (this.width = this.minWidth), this.minHeight && this.height < this.minHeight && (this.height = this.minHeight));
            this.game.canvas.style.width = this.width + "px";
            this.game.canvas.style.height = this.height + "px";
            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
            this.pageAlignHorizontally && (this.width <
                window.innerWidth && !this.incorrectOrientation ? (this.margin.x = Math.round((window.innerWidth - this.width) / 2), this.game.canvas.style.marginLeft = this.margin.x + "px") : (this.margin.x = 0, this.game.canvas.style.marginLeft = "0px"));
            this.pageAlignVertically && (this.height < window.innerHeight && !this.incorrectOrientation ? (this.margin.y = Math.round((window.innerHeight - this.height) / 2), this.game.canvas.style.marginTop = this.margin.y + "px") : (this.margin.y = 0, this.game.canvas.style.marginTop = "0px"));
            c.Canvas.getOffset(this.game.canvas,
                this.game.stage.offset);
            this.bounds.setTo(this.game.stage.offset.x, this.game.stage.offset.y, this.width, this.height);
            this.aspectRatio = this.width / this.height;
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height;
            this.scaleFactorInversed.x = this.width / this.game.width;
            this.scaleFactorInversed.y = this.height / this.game.height;
            this.hasResized.dispatch(this.width, this.height);
            this.checkOrientationState()
        },
        setMaximum: function() {
            this.width = window.innerWidth;
            this.height =
                window.innerHeight
        },
        setShowAll: function() {
            var a = Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
            this.width = Math.round(this.game.width * a);
            this.height = Math.round(this.game.height * a)
        },
        setExactFit: function() {
            var a = window.innerWidth,
                b = window.innerHeight;
            this.width = this.maxWidth && a > this.maxWidth ? this.maxWidth : a;
            this.height = this.maxHeight && b > this.maxHeight ? this.maxHeight : b
        }
    };
    c.ScaleManager.prototype.constructor = c.ScaleManager;
    Object.defineProperty(c.ScaleManager.prototype,
        "isFullScreen", {
            get: function() {
                return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement
            }
        });
    Object.defineProperty(c.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return 0 === this.orientation || 180 === this.orientation
        }
    });
    Object.defineProperty(c.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return 90 === this.orientation || -90 === this.orientation
        }
    });
    c.Game = function(a, b, d, e, f, h, k, g) {
        this.id = c.GAMES.push(this) - 1;
        this.config = null;
        this.physicsConfig = g;
        this.parent =
            "";
        this.width = 800;
        this.height = 600;
        this.transparent = !1;
        this.antialias = !0;
        this.renderer = null;
        this.renderType = c.AUTO;
        this.state = null;
        this.isRunning = this.isBooted = !1;
        this.particles = this.debug = this.context = this.canvas = this.camera = this.device = this.rnd = this.physics = this.world = this.tweens = this.time = this.stage = this.sound = this.scale = this.net = this.math = this.load = this.input = this.cache = this.make = this.add = this.raf = null;
        this.pendingStep = this.stepping = !1;
        this.stepCount = 0;
        this.onFocus = this.onBlur = this.onResume = this.onPause =
            null;
        this._codePaused = this._paused = !1;
        1 === arguments.length && "object" === typeof arguments[0] ? this.parseConfig(arguments[0]) : ("undefined" !== typeof a && (this.width = a), "undefined" !== typeof b && (this.height = b), "undefined" !== typeof d && (this.renderType = this.renderer = d), "undefined" !== typeof e && (this.parent = e), "undefined" !== typeof h && (this.transparent = h), "undefined" !== typeof k && (this.antialias = k), this.rnd = new c.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new c.StateManager(this, f));
        var l = this;
        this._onBoot = function() {
            return l.boot()
        };
        "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(this._onBoot, 0) : (document.addEventListener("DOMContentLoaded", this._onBoot, !1), window.addEventListener("load", this._onBoot, !1));
        return this
    };
    c.Game.prototype = {
        parseConfig: function(a) {
            this.config = a;
            a.width && (this.width = c.Utils.parseDimension(a.width, 0));
            a.height && (this.height = c.Utils.parseDimension(a.height, 1));
            a.renderer && (this.renderType = this.renderer = a.renderer);
            a.parent && (this.parent = a.parent);
            a.transparent && (this.transparent = a.transparent);
            a.antialias && (this.antialias = a.antialias);
            a.physicsConfig && (this.physicsConfig = a.physicsConfig);
            var b = [(Date.now() * Math.random()).toString()];
            a.seed && (b = a.seed);
            this.rnd = new c.RandomDataGenerator(b);
            b = null;
            a.state && (b = a.state);
            this.state = new c.StateManager(this, b)
        },
        boot: function() {
            this.isBooted || (document.body ? (document.removeEventListener("DOMContentLoaded", this._onBoot), window.removeEventListener("load", this._onBoot),
                this.onPause = new c.Signal, this.onResume = new c.Signal, this.onBlur = new c.Signal, this.onFocus = new c.Signal, this.isBooted = !0, this.device = new c.Device(this), this.math = c.Math, this.stage = new c.Stage(this, this.width, this.height), this.scale = new c.ScaleManager(this, this.width, this.height), this.setUpRenderer(), this.device.checkFullScreenSupport(), this.world = new c.World(this), this.add = new c.GameObjectFactory(this), this.make = new c.GameObjectCreator(this), this.cache = new c.Cache(this), this.load = new c.Loader(this),
                this.time = new c.Time(this), this.tweens = new c.TweenManager(this), this.input = new c.Input(this), this.sound = new c.SoundManager(this), this.physics = new c.Physics(this, this.physicsConfig), this.particles = new c.Particles(this), this.plugins = new c.PluginManager(this), this.net = new c.Net(this), this.debug = new c.Utils.Debug(this), this.scratch = new c.BitmapData(this, "__root", 1024, 1024), this.time.boot(), this.stage.boot(), this.world.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.debug.boot(), this.showDebugHeader(),
                this.isRunning = !0, this.raf = this.config && this.config.forceSetTimeOut ? new c.RequestAnimationFrame(this, this.config.forceSetTimeOut) : new c.RequestAnimationFrame(this, !1), this.raf.start()) : window.setTimeout(this._onBoot, 20))
        },
        showDebugHeader: function() {
            var a = c.VERSION,
                b = "Canvas",
                d = "HTML Audio",
                e = 1;
            this.renderType === c.WEBGL ? (b = "WebGL", e++) : this.renderType == c.HEADLESS && (b = "Headless");
            this.device.webAudio && (d = "WebAudio", e++);
            if (this.device.chrome) {
                a = ["%c %c %c Phaser v" + a + " - " + b + " - " + d + "  %c %c  http://phaser.io  %c %c \u2665%c\u2665%c\u2665 ",
                    "background: #0cf300", "background: #00bc17", "color: #ffffff; background: #00711f;", "background: #00bc17", "background: #0cf300", "background: #00bc17"
                ];
                for (b = 0; 3 > b; b++) b < e ? a.push("color: #ff2424; background: #fff") : a.push("color: #959595; background: #fff");
                console.log.apply(console, a)
            } else window.console && console.log("Phaser v" + a + " - Renderer: " + b + " - Audio: " + d + " - http://phaser.io")
        },
        setUpRenderer: function() {
            this.device.trident && (this.renderType = c.CANVAS);
            if (this.renderType === c.HEADLESS || this.renderType ===
                c.CANVAS || this.renderType === c.AUTO && !1 === this.device.webGL)
                if (this.device.canvas) this.renderType === c.AUTO && (this.renderType = c.CANVAS), this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent), this.context = this.renderer.context;
                else throw Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
            else this.renderType = c.WEBGL, this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias), this.context = null;
            this.renderType !==
                c.HEADLESS && (this.stage.smoothed = this.antialias, c.Canvas.addToDOM(this.canvas, this.parent, !0), c.Canvas.setTouchAction(this.canvas))
        },
        update: function(a) {
            this.time.update(a);
            !this._paused && !this.pendingStep ? (this.stepping && (this.pendingStep = !0), this.debug.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(), this.plugins.preUpdate(), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(),
                this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()) : (this.state.pauseUpdate(), this.debug.preUpdate());
            this.renderType != c.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(), this.state.render(), this.plugins.postRender())
        },
        enableStep: function() {
            this.stepping = !0;
            this.pendingStep = !1;
            this.stepCount = 0
        },
        disableStep: function() {
            this.pendingStep = this.stepping = !1
        },
        step: function() {
            this.pendingStep = !1;
            this.stepCount++
        },
        destroy: function() {
            this.raf.stop();
            this.input.destroy();
            this.state.destroy();
            this.physics.destroy();
            this.world = this.time = this.stage = this.sound = this.load = this.input = this.cache = this.state = null;
            this.isBooted = !1
        },
        gamePaused: function(a) {
            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.setMute(), this.onPause.dispatch(a))
        },
        gameResumed: function(a) {
            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.unsetMute(), this.onResume.dispatch(a))
        },
        focusLoss: function(a) {
            this.onBlur.dispatch(a);
            this.gamePaused(a)
        },
        focusGain: function(a) {
            this.onFocus.dispatch(a);
            this.gameResumed(a)
        }
    };
    c.Game.prototype.constructor = c.Game;
    Object.defineProperty(c.Game.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(a) {
            !0 === a ? !1 === this._paused && (this._codePaused = this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)) : this._paused && (this._codePaused = this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this))
        }
    });
    c.Input = function(a) {
        this.game =
            a;
        this.hitContext = this.hitCanvas = null;
        this.moveCallbacks = [];
        this.moveCallback = null;
        this.moveCallbackContext = this;
        this.pollRate = 0;
        this.disabled = !1;
        this.multiInputOverride = c.Input.MOUSE_TOUCH_COMBINE;
        this.scale = this.circle = this.speed = this.position = null;
        this.maxPointers = 10;
        this.currentPointers = 0;
        this.tapRate = 200;
        this.doubleTapRate = 300;
        this.holdRate = 2E3;
        this.justReleasedRate = this.justPressedRate = 200;
        this.recordPointerHistory = !1;
        this.recordLimit = this.recordRate = 100;
        this.gamepad = this.mspointer = this.touch =
            this.keyboard = this.mouse = this.mousePointer = this.activePointer = this.pointer10 = this.pointer9 = this.pointer8 = this.pointer7 = this.pointer6 = this.pointer5 = this.pointer4 = this.pointer3 = this.pointer2 = this.pointer1 = null;
        this.resetLocked = !1;
        this.onHold = this.onTap = this.onUp = this.onDown = null;
        this.minPriorityID = 0;
        this.interactiveItems = new c.ArrayList;
        this._localPoint = new c.Point;
        this._pollCounter = 0;
        this._oldPosition = null;
        this._y = this._x = 0
    };
    c.Input.MOUSE_OVERRIDES_TOUCH = 0;
    c.Input.TOUCH_OVERRIDES_MOUSE = 1;
    c.Input.MOUSE_TOUCH_COMBINE =
        2;
    c.Input.prototype = {
        boot: function() {
            this.mousePointer = new c.Pointer(this.game, 0);
            this.pointer1 = new c.Pointer(this.game, 1);
            this.pointer2 = new c.Pointer(this.game, 2);
            this.mouse = new c.Mouse(this.game);
            this.keyboard = new c.Keyboard(this.game);
            this.touch = new c.Touch(this.game);
            this.mspointer = new c.MSPointer(this.game);
            this.gamepad = new c.Gamepad(this.game);
            this.onDown = new c.Signal;
            this.onUp = new c.Signal;
            this.onTap = new c.Signal;
            this.onHold = new c.Signal;
            this.scale = new c.Point(1, 1);
            this.speed = new c.Point;
            this.position =
                new c.Point;
            this._oldPosition = new c.Point;
            this.circle = new c.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.currentPointers = 0;
            this.hitCanvas = document.createElement("canvas");
            this.hitCanvas.width = 1;
            this.hitCanvas.height = 1;
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.keyboard.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = !0
        },
        destroy: function() {
            this.mouse.stop();
            this.keyboard.stop();
            this.touch.stop();
            this.mspointer.stop();
            this.gamepad.stop();
            this.moveCallbacks = [];
            this.moveCallback = null
        },
        setMoveCallback: function(a, b) {
            this.moveCallback = a;
            this.moveCallbackContext = b
        },
        addMoveCallback: function(a, b) {
            return this.moveCallbacks.push({
                callback: a,
                context: b
            }) - 1
        },
        deleteMoveCallback: function(a) {
            this.moveCallbacks[a] && this.moveCallbacks.splice(a, 1)
        },
        addPointer: function() {
            for (var a = 0, b = 10; 0 < b; b--) null === this["pointer" + b] && (a = b);
            if (0 === a) return console.warn("You can only have 10 Pointer objects"), null;
            this["pointer" + a] = new c.Pointer(this.game, a);
            return this["pointer" +
                a]
        },
        update: function() {
            this.keyboard.update();
            0 < this.pollRate && this._pollCounter < this.pollRate ? this._pollCounter++ : (this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad.active && this.gamepad.update(), this.pointer1.update(), this.pointer2.update(), this.pointer3 && this.pointer3.update(), this.pointer4 && this.pointer4.update(), this.pointer5 && this.pointer5.update(), this.pointer6 && this.pointer6.update(),
                this.pointer7 && this.pointer7.update(), this.pointer8 && this.pointer8.update(), this.pointer9 && this.pointer9.update(), this.pointer10 && this.pointer10.update(), this._pollCounter = 0)
        },
        reset: function(a) {
            if (this.game.isBooted && !this.resetLocked) {
                "undefined" === typeof a && (a = !1);
                this.keyboard.reset(a);
                this.mousePointer.reset();
                this.gamepad.reset();
                for (var b = 1; 10 >= b; b++) this["pointer" + b] && this["pointer" + b].reset();
                this.currentPointers = 0;
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit");
                a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.moveCallbacks = []);
                this._pollCounter = 0
            }
        },
        resetSpeed: function(a, b) {
            this._oldPosition.setTo(a, b);
            this.speed.setTo(0, 0)
        },
        startPointer: function(a) {
            if (10 > this.maxPointers && this.totalActivePointers == this.maxPointers) return null;
            if (!1 === this.pointer1.active) return this.pointer1.start(a);
            if (!1 === this.pointer2.active) return this.pointer2.start(a);
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && !1 === this["pointer" + b].active) return this["pointer" + b].start(a);
            return null
        },
        updatePointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier == a.identifier) return this.pointer1.move(a);
            if (this.pointer2.active && this.pointer2.identifier == a.identifier) return this.pointer2.move(a);
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == a.identifier) return this["pointer" + b].move(a);
            return null
        },
        stopPointer: function(a) {
            if (this.pointer1.active &&
                this.pointer1.identifier == a.identifier) return this.pointer1.stop(a);
            if (this.pointer2.active && this.pointer2.identifier == a.identifier) return this.pointer2.stop(a);
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == a.identifier) return this["pointer" + b].stop(a);
            return null
        },
        getPointer: function(a) {
            a = a || !1;
            if (this.pointer1.active == a) return this.pointer1;
            if (this.pointer2.active == a) return this.pointer2;
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && this["pointer" +
                        b].active == a) return this["pointer" + b];
            return null
        },
        getPointerFromIdentifier: function(a) {
            if (this.pointer1.identifier === a) return this.pointer1;
            if (this.pointer2.identifier === a) return this.pointer2;
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && this["pointer" + b].identifier === a) return this["pointer" + b];
            return null
        },
        getPointerFromId: function(a) {
            if (this.pointer1.pointerId === a) return this.pointer1;
            if (this.pointer2.pointerId === a) return this.pointer2;
            for (var b = 3; 10 >= b; b++)
                if (this["pointer" + b] && this["pointer" +
                        b].pointerId === a) return this["pointer" + b];
            return null
        },
        getLocalPosition: function(a, b, d) {
            "undefined" === typeof d && (d = new c.Point);
            a = a.worldTransform;
            var e = 1 / (a.a * a.d + a.b * -a.c);
            return d.setTo(a.d * e * b.x + -a.b * e * b.y + (a.ty * a.b - a.tx * a.d) * e, a.a * e * b.y + -a.c * e * b.x + (-a.ty * a.a + a.tx * a.c) * e)
        },
        hitTest: function(a, b, d) {
            if (!a.worldVisible) return !1;
            this.getLocalPosition(a, b, this._localPoint);
            d.copyFrom(this._localPoint);
            if (a.hitArea && a.hitArea.contains) return a.hitArea.contains(this._localPoint.x, this._localPoint.y) ?
                !0 : !1;
            if (a instanceof c.TileSprite) {
                var e = a.width,
                    f = a.height,
                    h = -e * a.anchor.x;
                if (this._localPoint.x > h && this._localPoint.x < h + e && (e = -f * a.anchor.y, this._localPoint.y > e && this._localPoint.y < e + f)) return !0
            } else if (a instanceof PIXI.Sprite && (e = a.texture.frame.width, f = a.texture.frame.height, h = -e * a.anchor.x, this._localPoint.x > h && this._localPoint.x < h + e && (e = -f * a.anchor.y, this._localPoint.y > e && this._localPoint.y < e + f))) return !0;
            f = 0;
            for (e = a.children.length; f < e; f++)
                if (this.hitTest(a.children[f], b, d)) return !0;
            return !1
        }
    };
    c.Input.prototype.constructor = c.Input;
    Object.defineProperty(c.Input.prototype, "x", {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = Math.floor(a)
        }
    });
    Object.defineProperty(c.Input.prototype, "y", {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = Math.floor(a)
        }
    });
    Object.defineProperty(c.Input.prototype, "pollLocked", {
        get: function() {
            return 0 < this.pollRate && this._pollCounter < this.pollRate
        }
    });
    Object.defineProperty(c.Input.prototype, "totalInactivePointers", {
        get: function() {
            return 10 - this.currentPointers
        }
    });
    Object.defineProperty(c.Input.prototype, "totalActivePointers", {
        get: function() {
            this.currentPointers = 0;
            for (var a = 1; 10 >= a; a++) this["pointer" + a] && this["pointer" + a].active && this.currentPointers++;
            return this.currentPointers
        }
    });
    Object.defineProperty(c.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x
        }
    });
    Object.defineProperty(c.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y
        }
    });
    c.Key = function(a, b) {
        this.game = a;
        this.enabled = !0;
        this.event = null;
        this.isDown = !1;
        this.isUp = !0;
        this.shiftKey = this.ctrlKey = this.altKey = !1;
        this.duration = this.timeDown = 0;
        this.timeUp = -2500;
        this.repeats = 0;
        this.keyCode = b;
        this.onDown = new c.Signal;
        this.onHoldContext = this.onHoldCallback = null;
        this.onUp = new c.Signal
    };
    c.Key.prototype = {
        update: function() {
            this.enabled && this.isDown && (this.duration = this.game.time.now - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
        },
        processKeyDown: function(a) {
            this.enabled && (this.event = a, this.isDown || (this.altKey =
                a.altKey, this.ctrlKey = a.ctrlKey, this.shiftKey = a.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.now, this.repeats = this.duration = 0, this.onDown.dispatch(this)))
        },
        processKeyUp: function(a) {
            this.enabled && (this.event = a, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.now, this.duration = this.game.time.now - this.timeDown, this.onUp.dispatch(this)))
        },
        reset: function(a) {
            "undefined" === typeof a && (a = !0);
            this.isDown = !1;
            this.isUp = !0;
            this.timeUp = this.game.time.now;
            this.duration = this.game.time.now -
                this.timeDown;
            this.enabled = !0;
            a && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldContext = this.onHoldCallback = null)
        },
        justPressed: function(a) {
            "undefined" === typeof a && (a = 50);
            return this.isDown && this.duration < a
        },
        justReleased: function(a) {
            "undefined" === typeof a && (a = 50);
            return !this.isDown && this.game.time.now - this.timeUp < a
        }
    };
    c.Key.prototype.constructor = c.Key;
    c.Keyboard = function(a) {
        this.game = a;
        this.disabled = !1;
        this.event = null;
        this.callbackContext = this;
        this.onUpCallback = this.onDownCallback = null;
        this._keys = [];
        this._capture = [];
        this._onKeyUp = this._onKeyDown = null;
        this._i = 0
    };
    c.Keyboard.prototype = {
        addCallbacks: function(a, b, c) {
            this.callbackContext = a;
            this.onDownCallback = b;
            "undefined" !== typeof c && (this.onUpCallback = c)
        },
        addKey: function(a) {
            this._keys[a] || (this._keys[a] = new c.Key(this.game, a), this.addKeyCapture(a));
            return this._keys[a]
        },
        removeKey: function(a) {
            this._keys[a] && (this._keys[a] = null, this.removeKeyCapture(a))
        },
        createCursorKeys: function() {
            return {
                up: this.addKey(c.Keyboard.UP),
                down: this.addKey(c.Keyboard.DOWN),
                left: this.addKey(c.Keyboard.LEFT),
                right: this.addKey(c.Keyboard.RIGHT)
            }
        },
        start: function() {
            if (null === this._onKeyDown) {
                var a = this;
                this._onKeyDown = function(b) {
                    return a.processKeyDown(b)
                };
                this._onKeyUp = function(b) {
                    return a.processKeyUp(b)
                };
                window.addEventListener("keydown", this._onKeyDown, !1);
                window.addEventListener("keyup", this._onKeyUp, !1)
            }
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown);
            window.removeEventListener("keyup", this._onKeyUp);
            this._onKeyUp = this._onKeyDown = null
        },
        destroy: function() {
            this.stop();
            this.clearCaptures();
            this._i = this._keys.length = 0
        },
        addKeyCapture: function(a) {
            if ("object" === typeof a)
                for (var b in a) this._capture[a[b]] = !0;
            else this._capture[a] = !0
        },
        removeKeyCapture: function(a) {
            delete this._capture[a]
        },
        clearCaptures: function() {
            this._capture = {}
        },
        update: function() {
            for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
        },
        processKeyDown: function(a) {
            this.event = a;
            !this.game.input.disabled && !this.disabled && (this._capture[a.keyCode] && a.preventDefault(), this.onDownCallback &&
                this.onDownCallback.call(this.callbackContext, a), this._keys[a.keyCode] || (this._keys[a.keyCode] = new c.Key(this.game, a.keyCode)), this._keys[a.keyCode].processKeyDown(a))
        },
        processKeyUp: function(a) {
            this.event = a;
            !this.game.input.disabled && !this.disabled && (this._capture[a.keyCode] && a.preventDefault(), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a), this._keys[a.keyCode] || (this._keys[a.keyCode] = new c.Key(this.game, a.keyCode)), this._keys[a.keyCode].processKeyUp(a))
        },
        reset: function(a) {
            "undefined" ===
            typeof a && (a = !0);
            this.event = null;
            for (var b = this._keys.length; b--;) this._keys[b] && this._keys[b].reset(a)
        },
        justPressed: function(a, b) {
            "undefined" === typeof b && (b = 50);
            return this._keys[a] ? this._keys[a].justPressed(b) : !1
        },
        justReleased: function(a, b) {
            "undefined" === typeof b && (b = 50);
            return this._keys[a] ? this._keys[a].justReleased(b) : !1
        },
        isDown: function(a) {
            return this._keys[a] ? this._keys[a].isDown : !1
        }
    };
    c.Keyboard.prototype.constructor = c.Keyboard;
    c.Keyboard.A = 65;
    c.Keyboard.B = 66;
    c.Keyboard.C = 67;
    c.Keyboard.D = 68;
    c.Keyboard.E = 69;
    c.Keyboard.F = 70;
    c.Keyboard.G = 71;
    c.Keyboard.H = 72;
    c.Keyboard.I = 73;
    c.Keyboard.J = 74;
    c.Keyboard.K = 75;
    c.Keyboard.L = 76;
    c.Keyboard.M = 77;
    c.Keyboard.N = 78;
    c.Keyboard.O = 79;
    c.Keyboard.P = 80;
    c.Keyboard.Q = 81;
    c.Keyboard.R = 82;
    c.Keyboard.S = 83;
    c.Keyboard.T = 84;
    c.Keyboard.U = 85;
    c.Keyboard.V = 86;
    c.Keyboard.W = 87;
    c.Keyboard.X = 88;
    c.Keyboard.Y = 89;
    c.Keyboard.Z = 90;
    c.Keyboard.ZERO = 48;
    c.Keyboard.ONE = 49;
    c.Keyboard.TWO = 50;
    c.Keyboard.THREE = 51;
    c.Keyboard.FOUR = 52;
    c.Keyboard.FIVE = 53;
    c.Keyboard.SIX = 54;
    c.Keyboard.SEVEN = 55;
    c.Keyboard.EIGHT = 56;
    c.Keyboard.NINE = 57;
    c.Keyboard.NUMPAD_0 = 96;
    c.Keyboard.NUMPAD_1 = 97;
    c.Keyboard.NUMPAD_2 = 98;
    c.Keyboard.NUMPAD_3 = 99;
    c.Keyboard.NUMPAD_4 = 100;
    c.Keyboard.NUMPAD_5 = 101;
    c.Keyboard.NUMPAD_6 = 102;
    c.Keyboard.NUMPAD_7 = 103;
    c.Keyboard.NUMPAD_8 = 104;
    c.Keyboard.NUMPAD_9 = 105;
    c.Keyboard.NUMPAD_MULTIPLY = 106;
    c.Keyboard.NUMPAD_ADD = 107;
    c.Keyboard.NUMPAD_ENTER = 108;
    c.Keyboard.NUMPAD_SUBTRACT = 109;
    c.Keyboard.NUMPAD_DECIMAL = 110;
    c.Keyboard.NUMPAD_DIVIDE = 111;
    c.Keyboard.F1 = 112;
    c.Keyboard.F2 = 113;
    c.Keyboard.F3 = 114;
    c.Keyboard.F4 = 115;
    c.Keyboard.F5 = 116;
    c.Keyboard.F6 = 117;
    c.Keyboard.F7 = 118;
    c.Keyboard.F8 = 119;
    c.Keyboard.F9 = 120;
    c.Keyboard.F10 = 121;
    c.Keyboard.F11 = 122;
    c.Keyboard.F12 = 123;
    c.Keyboard.F13 = 124;
    c.Keyboard.F14 = 125;
    c.Keyboard.F15 = 126;
    c.Keyboard.COLON = 186;
    c.Keyboard.EQUALS = 187;
    c.Keyboard.UNDERSCORE = 189;
    c.Keyboard.QUESTION_MARK = 191;
    c.Keyboard.TILDE = 192;
    c.Keyboard.OPEN_BRACKET = 219;
    c.Keyboard.BACKWARD_SLASH = 220;
    c.Keyboard.CLOSED_BRACKET = 221;
    c.Keyboard.QUOTES = 222;
    c.Keyboard.BACKSPACE = 8;
    c.Keyboard.TAB = 9;
    c.Keyboard.CLEAR =
        12;
    c.Keyboard.ENTER = 13;
    c.Keyboard.SHIFT = 16;
    c.Keyboard.CONTROL = 17;
    c.Keyboard.ALT = 18;
    c.Keyboard.CAPS_LOCK = 20;
    c.Keyboard.ESC = 27;
    c.Keyboard.SPACEBAR = 32;
    c.Keyboard.PAGE_UP = 33;
    c.Keyboard.PAGE_DOWN = 34;
    c.Keyboard.END = 35;
    c.Keyboard.HOME = 36;
    c.Keyboard.LEFT = 37;
    c.Keyboard.UP = 38;
    c.Keyboard.RIGHT = 39;
    c.Keyboard.DOWN = 40;
    c.Keyboard.INSERT = 45;
    c.Keyboard.DELETE = 46;
    c.Keyboard.HELP = 47;
    c.Keyboard.NUM_LOCK = 144;
    c.Mouse = function(a) {
        this.callbackContext = this.game = a;
        this.mouseOverCallback = this.mouseOutCallback = this.mouseUpCallback =
            this.mouseMoveCallback = this.mouseDownCallback = null;
        this.capture = !1;
        this.button = -1;
        this.stopOnGameOut = this.locked = this.disabled = !1;
        this.pointerLock = new c.Signal;
        this._onMouseOver = this._onMouseOut = this._onMouseUp = this._onMouseMove = this._onMouseDown = this.event = null
    };
    c.Mouse.NO_BUTTON = -1;
    c.Mouse.LEFT_BUTTON = 0;
    c.Mouse.MIDDLE_BUTTON = 1;
    c.Mouse.RIGHT_BUTTON = 2;
    c.Mouse.prototype = {
        start: function() {
            if (!(this.game.device.android && !1 === this.game.device.chrome) && null === this._onMouseDown) {
                var a = this;
                this._onMouseDown =
                    function(b) {
                        return a.onMouseDown(b)
                    };
                this._onMouseMove = function(b) {
                    return a.onMouseMove(b)
                };
                this._onMouseUp = function(b) {
                    return a.onMouseUp(b)
                };
                this._onMouseOut = function(b) {
                    return a.onMouseOut(b)
                };
                this._onMouseOver = function(b) {
                    return a.onMouseOver(b)
                };
                this.game.canvas.addEventListener("mousedown", this._onMouseDown, !0);
                this.game.canvas.addEventListener("mousemove", this._onMouseMove, !0);
                this.game.canvas.addEventListener("mouseup", this._onMouseUp, !0);
                this.game.canvas.addEventListener("mouseover", this._onMouseOver, !0);
                this.game.canvas.addEventListener("mouseout", this._onMouseOut, !0)
            }
        },
        onMouseDown: function(a) {
            this.event = a;
            this.capture && a.preventDefault();
            this.button = a.button;
            this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a);
            !this.game.input.disabled && !this.disabled && (a.identifier = 0, this.game.input.mousePointer.start(a))
        },
        onMouseMove: function(a) {
            this.event = a;
            this.capture && a.preventDefault();
            this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a);
            !this.game.input.disabled &&
                !this.disabled && (a.identifier = 0, this.game.input.mousePointer.move(a))
        },
        onMouseUp: function(a) {
            this.event = a;
            this.capture && a.preventDefault();
            this.button = c.Mouse.NO_BUTTON;
            this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a);
            !this.game.input.disabled && !this.disabled && (a.identifier = 0, this.game.input.mousePointer.stop(a))
        },
        onMouseOut: function(a) {
            this.event = a;
            this.capture && a.preventDefault();
            this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a);
            !this.game.input.disabled &&
                !this.disabled && (this.game.input.mousePointer.withinGame = !1, this.stopOnGameOut && (a.identifier = 0, this.game.input.mousePointer.stop(a)))
        },
        onMouseOver: function(a) {
            this.event = a;
            this.capture && a.preventDefault();
            this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a);
            !this.game.input.disabled && !this.disabled && (this.game.input.mousePointer.withinGame = !0)
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var a = this.game.canvas;
                a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock ||
                    a.webkitRequestPointerLock;
                a.requestPointerLock();
                var b = this;
                this._pointerLockChange = function(a) {
                    return b.pointerLockChange(a)
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, !0);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        },
        pointerLockChange: function(a) {
            var b = this.game.canvas;
            document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement ===
                b ? (this.locked = !0, this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a))
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
        },
        stop: function() {
            this.game.canvas.removeEventListener("mousedown", this._onMouseDown, !0);
            this.game.canvas.removeEventListener("mousemove", this._onMouseMove, !0);
            this.game.canvas.removeEventListener("mouseup", this._onMouseUp, !0);
            this.game.canvas.removeEventListener("mouseover", this._onMouseOver, !0);
            this.game.canvas.removeEventListener("mouseout", this._onMouseOut, !0)
        }
    };
    c.Mouse.prototype.constructor = c.Mouse;
    c.MSPointer = function(a) {
        this.callbackContext = this.game = a;
        this.disabled = !1;
        this._onMSPointerUp =
            this._onMSPointerMove = this._onMSPointerDown = null
    };
    c.MSPointer.prototype = {
        start: function() {
            if (null === this._onMSPointerDown) {
                var a = this;
                !0 === this.game.device.mspointer && (this._onMSPointerDown = function(b) {
                    return a.onPointerDown(b)
                }, this._onMSPointerMove = function(b) {
                    return a.onPointerMove(b)
                }, this._onMSPointerUp = function(b) {
                    return a.onPointerUp(b)
                }, this.game.renderer.view.addEventListener("MSPointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("MSPointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("MSPointerUp", this._onMSPointerUp, !1), this.game.renderer.view.addEventListener("pointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("pointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("pointerUp", this._onMSPointerUp, !1), this.game.renderer.view.style["-ms-content-zooming"] = "none", this.game.renderer.view.style["-ms-touch-action"] = "none")
            }
        },
        onPointerDown: function(a) {
            !this.game.input.disabled && !this.disabled &&
                (a.preventDefault(), a.identifier = a.pointerId, this.game.input.startPointer(a))
        },
        onPointerMove: function(a) {
            !this.game.input.disabled && !this.disabled && (a.preventDefault(), a.identifier = a.pointerId, this.game.input.updatePointer(a))
        },
        onPointerUp: function(a) {
            !this.game.input.disabled && !this.disabled && (a.preventDefault(), a.identifier = a.pointerId, this.game.input.stopPointer(a))
        },
        stop: function() {
            this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("MSPointerMove",
                this._onMSPointerMove);
            this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
            this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp)
        }
    };
    c.MSPointer.prototype.constructor = c.MSPointer;
    c.Pointer = function(a, b) {
        this.game = a;
        this.id = b;
        this.type = c.POINTER;
        this.exists = !0;
        this.identifier = 0;
        this.button = this.target = this.pointerId = null;
        this._holdSent = !1;
        this._history = [];
        this._nextDrop = 0;
        this.withinGame = this._stateReset = !1;
        this.screenY = this.screenX = this.pageY = this.pageX = this.clientY = this.clientX = -1;
        this.movementY = this.movementX = this.rawMovementY = this.rawMovementX = 0;
        this.y = this.x = -1;
        this.isDown = this.isMouse = !1;
        this.isUp = !0;
        this.totalTouches = this.previousTapTime = this.timeUp = this.timeDown = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = !1;
        this.position = new c.Point;
        this.positionDown = new c.Point;
        this.positionUp =
            new c.Point;
        this.circle = new c.Circle(0, 0, 44);
        0 === b && (this.isMouse = !0)
    };
    c.Pointer.prototype = {
        start: function(a) {
            a.pointerId && (this.pointerId = a.pointerId);
            this.identifier = a.identifier;
            this.target = a.target;
            "undefined" !== typeof a.button && (this.button = a.button);
            this._history = [];
            this.isDown = this.withinGame = this.active = !0;
            this.isUp = !1;
            this.msSinceLastClick = this.game.time.now - this.timeDown;
            this.timeDown = this.game.time.now;
            this._holdSent = !1;
            this.move(a, !0);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride ===
                c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.x, this.y), this.game.input.onDown.dispatch(this, a), this.game.input.resetSpeed(this.x, this.y);
            this._stateReset = !1;
            this.totalTouches++;
            this.isMouse || this.game.input.currentPointers++;
            null !== this.targetObject && this.targetObject._touchedHandler(this);
            return this
        },
        update: function() {
            this.active && (!1 === this._holdSent && this.duration >= this.game.input.holdRate && ((this.game.input.multiInputOverride == c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && this.game.input.onHold.dispatch(this), this._holdSent = !0), this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop && (this._nextDrop = this.game.time.now +
                this.game.input.recordRate, this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }), this._history.length > this.game.input.recordLimit && this._history.shift()))
        },
        move: function(a, b) {
            if (!this.game.input.pollLocked) {
                "undefined" === typeof b && (b = !1);
                "undefined" !== typeof a.button && (this.button = a.button);
                this.clientX = a.clientX;
                this.clientY = a.clientY;
                this.pageX = a.pageX;
                this.pageY = a.pageY;
                this.screenX = a.screenX;
                this.screenY = a.screenY;
                this.isMouse && (this.game.input.mouse.locked && !b) && (this.rawMovementX = a.movementX ||
                    a.mozMovementX || a.webkitMovementX || 0, this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY);
                this.x = (this.pageX - this.game.stage.offset.x) * this.game.input.scale.x;
                this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y;
                this.position.setTo(this.x, this.y);
                this.circle.x = this.x;
                this.circle.y = this.y;
                if (this.game.input.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE ||
                    this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.activePointer = this, this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.game.input.x, this.game.input.y), this.game.input.circle.x = this.game.input.x, this.game.input.circle.y = this.game.input.y;
                this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                if (this.game.paused) return this;
                this.game.input.moveCallback && this.game.input.moveCallback.call(this.game.input.moveCallbackContext,
                    this, this.x, this.y);
                for (var d = this.game.input.moveCallbacks.length; d--;) this.game.input.moveCallbacks[d].callback.call(this.game.input.moveCallbacks[d].context, this, this.x, this.y);
                if (null !== this.targetObject && !0 === this.targetObject.isDragged) return !1 === this.targetObject.update(this) && (this.targetObject = null), this;
                this._highestRenderOrderID = Number.MAX_SAFE_INTEGER;
                this._highestRenderObject = null;
                this._highestInputPriorityID = -1;
                if (0 < this.game.input.interactiveItems.total) {
                    d = this.game.input.interactiveItems.first;
                    do {
                        if (d && d.validForInput(this._highestInputPriorityID, this._highestRenderOrderID) && (!b && d.checkPointerOver(this) || b && d.checkPointerDown(this))) this._highestRenderOrderID = d.sprite._cache[3], this._highestInputPriorityID = d.priorityID, this._highestRenderObject = d;
                        d = this.game.input.interactiveItems.next
                    } while (null !== d)
                }
                null === this._highestRenderObject ? this.targetObject && (this.targetObject._pointerOutHandler(this), this.targetObject = null) : null === this.targetObject ? (this.targetObject = this._highestRenderObject,
                    this._highestRenderObject._pointerOverHandler(this)) : this.targetObject === this._highestRenderObject ? !1 === this._highestRenderObject.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this), this.targetObject = this._highestRenderObject, this.targetObject._pointerOverHandler(this));
                return this
            }
        },
        leave: function(a) {
            this.withinGame = !1;
            this.move(a, !1)
        },
        stop: function(a) {
            if (this._stateReset) a.preventDefault();
            else {
                this.timeUp = this.game.time.now;
                if (this.game.input.multiInputOverride ===
                    c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.onUp.dispatch(this, a), 0 <= this.duration && this.duration <= this.game.input.tapRate && (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate ? this.game.input.onTap.dispatch(this, !0) : this.game.input.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp);
                0 < this.id && (this.active = !1);
                this.isDown = this.withinGame = !1;
                this.isUp = !0;
                this.identifier = this.pointerId = null;
                this.positionUp.setTo(this.x, this.y);
                !1 === this.isMouse && this.game.input.currentPointers--;
                this.game.input.interactiveItems.callAll("_releasedHandler", this);
                this.targetObject = null;
                return this
            }
        },
        justPressed: function(a) {
            a = a || this.game.input.justPressedRate;
            return !0 === this.isDown && this.timeDown + a > this.game.time.now
        },
        justReleased: function(a) {
            a = a || this.game.input.justReleasedRate;
            return !0 === this.isUp && this.timeUp + a > this.game.time.now
        },
        reset: function() {
            !1 === this.isMouse && (this.active = !1);
            this.identifier = this.pointerId = null;
            this.isDown = !1;
            this.isUp = !0;
            this.totalTouches = 0;
            this._holdSent = !1;
            this._history.length = 0;
            this._stateReset = !0;
            this.targetObject && this.targetObject._releasedHandler(this);
            this.targetObject = null
        },
        resetMovement: function() {
            this.movementY = this.movementX = 0
        }
    };
    c.Pointer.prototype.constructor = c.Pointer;
    Object.defineProperty(c.Pointer.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.now - this.timeDown
        }
    });
    Object.defineProperty(c.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x
        }
    });
    Object.defineProperty(c.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y
        }
    });
    c.Touch = function(a) {
        this.game = a;
        this.disabled = !1;
        this.callbackContext = this.game;
        this.touchCancelCallback = this.touchLeaveCallback = this.touchEnterCallback = this.touchEndCallback = this.touchMoveCallback = this.touchStartCallback = null;
        this.preventDefault = !0;
        this._onTouchMove = this._onTouchCancel =
            this._onTouchLeave = this._onTouchEnter = this._onTouchEnd = this._onTouchMove = this._onTouchStart = this.event = null
    };
    c.Touch.prototype = {
        start: function() {
            if (null === this._onTouchStart) {
                var a = this;
                this.game.device.touch && (this._onTouchStart = function(b) {
                        return a.onTouchStart(b)
                    }, this._onTouchMove = function(b) {
                        return a.onTouchMove(b)
                    }, this._onTouchEnd = function(b) {
                        return a.onTouchEnd(b)
                    }, this._onTouchEnter = function(b) {
                        return a.onTouchEnter(b)
                    }, this._onTouchLeave = function(b) {
                        return a.onTouchLeave(b)
                    }, this._onTouchCancel =
                    function(b) {
                        return a.onTouchCancel(b)
                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1))
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove =
                function(a) {
                    a.preventDefault()
                };
            document.addEventListener("touchmove", this._documentTouchMove, !1)
        },
        onTouchStart: function(a) {
            this.event = a;
            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a);
            if (!this.game.input.disabled && !this.disabled) {
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b])
            }
        },
        onTouchCancel: function(a) {
            this.event = a;
            this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext,
                a);
            if (!this.game.input.disabled && !this.disabled) {
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
            }
        },
        onTouchEnter: function(a) {
            console.log("touch enter", a);
            this.event = a;
            this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a);
            !this.game.input.disabled && !this.disabled && this.preventDefault && a.preventDefault()
        },
        onTouchLeave: function(a) {
            this.event = a;
            this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext,
                a);
            this.preventDefault && a.preventDefault()
        },
        onTouchMove: function(a) {
            this.event = a;
            this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a);
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b])
        },
        onTouchEnd: function(a) {
            this.event = a;
            this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a);
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
        },
        stop: function() {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
        }
    };
    c.Touch.prototype.constructor = c.Touch;
    c.Gamepad =
        function(a) {
            this.game = a;
            this._gamepads = [new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this)];
            this._gamepadIndexMap = {};
            this._rawPads = [];
            this.disabled = this._active = !1;
            this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 != navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads;
            this._prevRawGamepadTypes = [];
            this._prevTimestamps = [];
            this.callbackContext = this;
            this._gamepaddisconnected = this._ongamepadconnected = this.onFloatCallback =
                this.onAxisCallback = this.onUpCallback = this.onDownCallback = this.onDisconnectCallback = this.onConnectCallback = null
        };
    c.Gamepad.prototype = {
        addCallbacks: function(a, b) {
            "undefined" !== typeof b && (this.onConnectCallback = "function" === typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" === typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" === typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" === typeof b.onUp ?
                b.onUp : this.onUpCallback, this.onAxisCallback = "function" === typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" === typeof b.onFloat ? b.onFloat : this.onFloatCallback)
        },
        start: function() {
            if (!this._active) {
                this._active = !0;
                var a = this;
                this._ongamepadconnected = function(b) {
                    b = b.gamepad;
                    a._rawPads.push(b);
                    a._gamepads[b.index].connect(b)
                };
                window.addEventListener("gamepadconnected", this._ongamepadconnected, !1);
                this._ongamepaddisconnected = function(b) {
                    b = b.gamepad;
                    for (var c in a._rawPads) a._rawPads[c].index ===
                        b.index && a._rawPads.splice(c, 1);
                    a._gamepads[b.index].disconnect()
                };
                window.addEventListener("gamepaddisconnected", this._ongamepaddisconnected, !1)
            }
        },
        update: function() {
            this._pollGamepads();
            for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a]._connected && this._gamepads[a].pollStatus()
        },
        _pollGamepads: function() {
            var a = navigator.getGamepads || navigator.webkitGetGamepads && navigator.webkitGetGamepads() || navigator.webkitGamepads;
            if (a) {
                this._rawPads = [];
                for (var b = !1, c = 0; c < a.length && !(typeof a[c] !== this._prevRawGamepadTypes[c] &&
                        (b = !0, this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 === c); c++);
                if (b) {
                    for (var a = {}, b = {}, e = 0; e < this._gamepads.length; e++)
                        if (c = this._gamepads[e], c.connected)
                            for (var f = 0; f < this._rawPads.length; f++) this._rawPads[f].index === c.index && (a[c.index] = !0, b[e] = !0);
                    for (e = 0; e < this._gamepads.length; e++)
                        if (c = this._gamepads[e], !b[e]) {
                            1 > this._rawPads.length && c.disconnect();
                            for (f = 0; f < this._rawPads.length && !b[e]; f++) {
                                var h = this._rawPads[f];
                                h ? a[h.index] ? c.disconnect() : (c.connect(h), a[h.index] = !0, b[e] = !0) : c.disconnect()
                            }
                        }
                }
            }
        },
        setDeadZones: function(a) {
            for (var b = 0; b < this._gamepads.length; b++) this._gamepads[b].deadZone = a
        },
        stop: function() {
            this._active = !1;
            window.removeEventListener("gamepadconnected", this._ongamepadconnected);
            window.removeEventListener("gamepaddisconnected", this._ongamepaddisconnected)
        },
        reset: function() {
            this.update();
            for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].reset()
        },
        justPressed: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++)
                if (!0 === this._gamepads[c].justPressed(a,
                        b)) return !0;
            return !1
        },
        justReleased: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++)
                if (!0 === this._gamepads[c].justReleased(a, b)) return !0;
            return !1
        },
        isDown: function(a) {
            for (var b = 0; b < this._gamepads.length; b++)
                if (!0 === this._gamepads[b].isDown(a)) return !0;
            return !1
        }
    };
    c.Gamepad.prototype.constructor = c.Gamepad;
    Object.defineProperty(c.Gamepad.prototype, "active", {
        get: function() {
            return this._active
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0]
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1]
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2]
        }
    });
    Object.defineProperty(c.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3]
        }
    });
    c.Gamepad.BUTTON_0 = 0;
    c.Gamepad.BUTTON_1 =
        1;
    c.Gamepad.BUTTON_2 = 2;
    c.Gamepad.BUTTON_3 = 3;
    c.Gamepad.BUTTON_4 = 4;
    c.Gamepad.BUTTON_5 = 5;
    c.Gamepad.BUTTON_6 = 6;
    c.Gamepad.BUTTON_7 = 7;
    c.Gamepad.BUTTON_8 = 8;
    c.Gamepad.BUTTON_9 = 9;
    c.Gamepad.BUTTON_10 = 10;
    c.Gamepad.BUTTON_11 = 11;
    c.Gamepad.BUTTON_12 = 12;
    c.Gamepad.BUTTON_13 = 13;
    c.Gamepad.BUTTON_14 = 14;
    c.Gamepad.BUTTON_15 = 15;
    c.Gamepad.AXIS_0 = 0;
    c.Gamepad.AXIS_1 = 1;
    c.Gamepad.AXIS_2 = 2;
    c.Gamepad.AXIS_3 = 3;
    c.Gamepad.AXIS_4 = 4;
    c.Gamepad.AXIS_5 = 5;
    c.Gamepad.AXIS_6 = 6;
    c.Gamepad.AXIS_7 = 7;
    c.Gamepad.AXIS_8 = 8;
    c.Gamepad.AXIS_9 = 9;
    c.Gamepad.XBOX360_A =
        0;
    c.Gamepad.XBOX360_B = 1;
    c.Gamepad.XBOX360_X = 2;
    c.Gamepad.XBOX360_Y = 3;
    c.Gamepad.XBOX360_LEFT_BUMPER = 4;
    c.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    c.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    c.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    c.Gamepad.XBOX360_BACK = 8;
    c.Gamepad.XBOX360_START = 9;
    c.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    c.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    c.Gamepad.XBOX360_DPAD_LEFT = 14;
    c.Gamepad.XBOX360_DPAD_RIGHT = 15;
    c.Gamepad.XBOX360_DPAD_UP = 12;
    c.Gamepad.XBOX360_DPAD_DOWN = 13;
    c.Gamepad.XBOX360_STICK_LEFT_X = 0;
    c.Gamepad.XBOX360_STICK_LEFT_Y =
        1;
    c.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    c.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    c.SinglePad = function(a, b) {
        this.game = a;
        this._padParent = b;
        this._rawPad = this._index = null;
        this._connected = !1;
        this._prevTimestamp = null;
        this._rawButtons = [];
        this._buttons = [];
        this._axes = [];
        this._hotkeys = [];
        this.callbackContext = this;
        this.onFloatCallback = this.onAxisCallback = this.onUpCallback = this.onDownCallback = this.onDisconnectCallback = this.onConnectCallback = null;
        this.deadZone = 0.26
    };
    c.SinglePad.prototype = {
        addCallbacks: function(a, b) {
            "undefined" !==
            typeof b && (this.onConnectCallback = "function" === typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" === typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" === typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" === typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" === typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" === typeof b.onFloat ? b.onFloat : this.onFloatCallback)
        },
        addButton: function(a) {
            this._hotkeys[a] = new c.GamepadButton(this.game, a);
            return this._hotkeys[a]
        },
        pollStatus: function() {
            if (!(this._rawPad.timestamp && this._rawPad.timestamp == this._prevTimestamp)) {
                for (var a = 0; a < this._rawPad.buttons.length; a += 1) {
                    var b = this._rawPad.buttons[a];
                    this._rawButtons[a] !== b && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b), this._rawButtons[a] = b)
                }
                a = this._rawPad.axes;
                for (b = 0; b < a.length; b += 1) {
                    var c = a[b];
                    0 < c && c > this.deadZone || 0 > c && c <
                        -this.deadZone ? this.processAxisChange({
                            axis: b,
                            value: c
                        }) : this.processAxisChange({
                            axis: b,
                            value: 0
                        })
                }
                this._prevTimestamp = this._rawPad.timestamp
            }
        },
        connect: function(a) {
            var b = !this._connected;
            this._index = a.index;
            this._connected = !0;
            this._rawPad = a;
            this._rawButtons = a.buttons;
            this._axes = a.axes;
            b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this._index);
            b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
        },
        disconnect: function() {
            var a =
                this._connected;
            this._connected = !1;
            this._rawPad = void 0;
            this._rawButtons = [];
            this._buttons = [];
            var b = this._index;
            this._index = null;
            a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b);
            a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
        },
        processAxisChange: function(a) {
            !this.game.input.disabled && !this.game.input.gamepad.disabled && this._axes[a.axis] !== a.value && (this._axes[a.axis] = a.value, this._padParent.onAxisCallback &&
                this._padParent.onAxisCallback.call(this._padParent.callbackContext, a, this._index), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, a))
        },
        processButtonDown: function(a, b) {
            !this.game.input.disabled && !this.game.input.gamepad.disabled && (this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this._index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].isDown ? this._buttons[a].duration =
                this.game.time.now - this._buttons[a].timeDown : this._buttons[a] ? (this._buttons[a].isDown = !0, this._buttons[a].timeDown = this.game.time.now, this._buttons[a].duration = 0, this._buttons[a].value = b) : this._buttons[a] = {
                    isDown: !0,
                    timeDown: this.game.time.now,
                    timeUp: 0,
                    duration: 0,
                    value: b
                }, this._hotkeys[a] && this._hotkeys[a].processButtonDown(b))
        },
        processButtonUp: function(a, b) {
            !this.game.input.disabled && !this.game.input.gamepad.disabled && (this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext,
                a, b, this._index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b), this._hotkeys[a] && this._hotkeys[a].processButtonUp(b), this._buttons[a] ? (this._buttons[a].isDown = !1, this._buttons[a].timeUp = this.game.time.now, this._buttons[a].value = b) : this._buttons[a] = {
                isDown: !1,
                timeDown: this.game.time.now,
                timeUp: this.game.time.now,
                duration: 0,
                value: b
            })
        },
        processButtonFloat: function(a, b) {
            !this.game.input.disabled && !this.game.input.gamepad.disabled && (this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext,
                a, b, this._index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b), this._buttons[a] ? this._buttons[a].value = b : this._buttons[a] = {
                value: b
            }, this._hotkeys[a] && this._hotkeys[a].processButtonFloat(b))
        },
        axis: function(a) {
            return this._axes[a] ? this._axes[a] : !1
        },
        isDown: function(a) {
            return this._buttons[a] ? this._buttons[a].isDown : !1
        },
        justReleased: function(a, b) {
            "undefined" === typeof b && (b = 250);
            return this._buttons[a] && !1 === this._buttons[a].isDown && this.game.time.now - this._buttons[a].timeUp <
                b
        },
        justPressed: function(a, b) {
            "undefined" === typeof b && (b = 250);
            return this._buttons[a] && this._buttons[a].isDown && this._buttons[a].duration < b
        },
        buttonValue: function(a) {
            return this._buttons[a] ? this._buttons[a].value : !1
        },
        reset: function() {
            for (var a = 0; a < this._buttons.length; a++) this._buttons[a] = 0;
            for (a = 0; a < this._axes.length; a++) this._axes[a] = 0
        }
    };
    c.SinglePad.prototype.constructor = c.SinglePad;
    Object.defineProperty(c.SinglePad.prototype, "connected", {
        get: function() {
            return this._connected
        }
    });
    Object.defineProperty(c.SinglePad.prototype,
        "index", {
            get: function() {
                return this._index
            }
        });
    c.GamepadButton = function(a, b) {
        this.game = a;
        this.isDown = !1;
        this.isUp = !0;
        this.value = this.repeats = this.timeUp = this.duration = this.timeDown = 0;
        this.buttonCode = b;
        this.onDown = new c.Signal;
        this.onUp = new c.Signal;
        this.onFloat = new c.Signal
    };
    c.GamepadButton.prototype = {
        processButtonDown: function(a) {
            this.isDown ? (this.duration = this.game.time.now - this.timeDown, this.repeats++) : (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.now, this.repeats = this.duration = 0, this.value =
                a, this.onDown.dispatch(this, a))
        },
        processButtonUp: function(a) {
            this.isDown = !1;
            this.isUp = !0;
            this.timeUp = this.game.time.now;
            this.value = a;
            this.onUp.dispatch(this, a)
        },
        processButtonFloat: function(a) {
            this.value = a;
            this.onFloat.dispatch(this, a)
        },
        justPressed: function(a) {
            "undefined" === typeof a && (a = 250);
            return this.isDown && this.duration < a
        },
        justReleased: function(a) {
            "undefined" === typeof a && (a = 250);
            return !1 === this.isDown && this.game.time.now - this.timeUp < a
        }
    };
    c.GamepadButton.prototype.constructor = c.GamepadButton;
    c.InputHandler =
        function(a) {
            this.sprite = a;
            this.game = a.game;
            this.enabled = !1;
            this.priorityID = 0;
            this.isDragged = this._setHandCursor = this.useHandCursor = !1;
            this.allowVerticalDrag = this.allowHorizontalDrag = !0;
            this.bringToTop = !1;
            this.snapOffset = null;
            this.snapOnRelease = this.snapOnDrag = !1;
            this.snapOffsetY = this.snapOffsetX = this.snapY = this.snapX = 0;
            this.pixelPerfectClick = this.pixelPerfectOver = !1;
            this.pixelPerfectAlpha = 255;
            this.draggable = !1;
            this.boundsSprite = this.boundsRect = null;
            this._wasEnabled = this._dragPhase = this.consumePointerEvent = !1;
            this._tempPoint = new c.Point;
            this._pointerData = [];
            this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        };
    c.InputHandler.prototype = {
        start: function(a, b) {
            a = a || 0;
            "undefined" === typeof b && (b = !1);
            if (!1 === this.enabled) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = b;
                this.priorityID = a;
                for (var d = 0; 10 > d; d++) this._pointerData[d] = {
                    id: d,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                };
                this.snapOffset = new c.Point;
                this._wasEnabled = this.enabled = !0;
                this.sprite.events && null === this.sprite.events.onInputOver && (this.sprite.events.onInputOver = new c.Signal, this.sprite.events.onInputOut = new c.Signal, this.sprite.events.onInputDown = new c.Signal, this.sprite.events.onInputUp = new c.Signal, this.sprite.events.onDragStart = new c.Signal, this.sprite.events.onDragStop = new c.Signal)
            }
            this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup,
                this);
            return this.sprite
        },
        addedToGroup: function() {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start()
        },
        removedFromGroup: function() {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
        },
        reset: function() {
            this.enabled = !1;
            for (var a = 0; 10 > a; a++) this._pointerData[a] = {
                id: a,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            }
        },
        stop: function() {
            !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
        },
        destroy: function() {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.sprite = this.boundsSprite = this.boundsRect = null)
        },
        validForInput: function(a, b) {
            return 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID ? !1 : this.pixelPerfectClick || this.pixelPerfectOver || this.priorityID > a || this.priorityID === a && this.sprite._cache[3] <
                b ? !0 : !1
        },
        pointerX: function(a) {
            return this._pointerData[a || 0].x
        },
        pointerY: function(a) {
            return this._pointerData[a || 0].y
        },
        pointerDown: function(a) {
            return this._pointerData[a || 0].isDown
        },
        pointerUp: function(a) {
            return this._pointerData[a || 0].isUp
        },
        pointerTimeDown: function(a) {
            return this._pointerData[a || 0].timeDown
        },
        pointerTimeUp: function(a) {
            return this._pointerData[a || 0].timeUp
        },
        pointerOver: function(a) {
            if (this.enabled)
                if ("undefined" === typeof a)
                    for (a = 0; 10 > a; a++) {
                        if (this._pointerData[a].isOver) return !0
                    } else return this._pointerData[a].isOver;
            return !1
        },
        pointerOut: function(a) {
            if (this.enabled)
                if ("undefined" === typeof a)
                    for (a = 0; 10 > a; a++) {
                        if (this._pointerData[a].isOut) return !0
                    } else return this._pointerData[a].isOut;
            return !1
        },
        pointerTimeOver: function(a) {
            return this._pointerData[a || 0].timeOver
        },
        pointerTimeOut: function(a) {
            return this._pointerData[a || 0].timeOut
        },
        pointerDragged: function(a) {
            return this._pointerData[a || 0].isDragged
        },
        checkPointerDown: function(a) {
            return !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible ?
                !1 : this.game.input.hitTest(this.sprite, a, this._tempPoint) ? this.pixelPerfectClick ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0 : !1
        },
        checkPointerOver: function(a) {
            return !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible ? !1 : this.game.input.hitTest(this.sprite, a, this._tempPoint) ? this.pixelPerfectOver ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0 : !1
        },
        checkPixel: function(a, b, c) {
            return this.sprite.texture.baseTexture.source && (this.game.input.hitContext.clearRect(0,
                0, 1, 1), null === a && null === b && (this.game.input.getLocalPosition(this.sprite, c, this._tempPoint), a = this._tempPoint.x, b = this._tempPoint.y), 0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y), a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0,
                0, 1, 1).data[3] >= this.pixelPerfectAlpha) ? !0 : !1
        },
        update: function(a) {
            if (!(null === this.sprite || void 0 === this.sprite.parent)) {
                if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) return this._pointerOutHandler(a), !1;
                if (this.draggable && this._draggedPointerID == a.id) return this.updateDrag(a);
                if (!0 === this._pointerData[a.id].isOver) {
                    if (this.checkPointerOver(a)) return this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, !0;
                    this._pointerOutHandler(a);
                    return !1
                }
            }
        },
        _pointerOverHandler: function(a) {
            null !== this.sprite && !1 === this._pointerData[a.id].isOver && (this._pointerData[a.id].isOver = !0, this._pointerData[a.id].isOut = !1, this._pointerData[a.id].timeOver = this.game.time.now, this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, this.useHandCursor && !1 === this._pointerData[a.id].isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), this.sprite && this.sprite.events && this.sprite.events.onInputOver.dispatch(this.sprite,
                a))
        },
        _pointerOutHandler: function(a) {
            null !== this.sprite && (this._pointerData[a.id].isOver = !1, this._pointerData[a.id].isOut = !0, this._pointerData[a.id].timeOut = this.game.time.now, this.useHandCursor && !1 === this._pointerData[a.id].isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.sprite && this.sprite.events && this.sprite.events.onInputOut.dispatch(this.sprite, a))
        },
        _touchedHandler: function(a) {
            if (null !== this.sprite) {
                if (!1 === this._pointerData[a.id].isDown && !0 === this._pointerData[a.id].isOver) {
                    if (this.pixelPerfectClick &&
                        !this.checkPixel(null, null, a)) return;
                    this._pointerData[a.id].isDown = !0;
                    this._pointerData[a.id].isUp = !1;
                    this._pointerData[a.id].timeDown = this.game.time.now;
                    this.sprite && this.sprite.events && this.sprite.events.onInputDown.dispatch(this.sprite, a);
                    this.draggable && !1 === this.isDragged && this.startDrag(a);
                    this.bringToTop && this.sprite.bringToTop()
                }
                return this.consumePointerEvent
            }
        },
        _releasedHandler: function(a) {
            null !== this.sprite && (this._pointerData[a.id].isDown && a.isUp) && (this._pointerData[a.id].isDown = !1, this._pointerData[a.id].isUp = !0, this._pointerData[a.id].timeUp = this.game.time.now, this._pointerData[a.id].downDuration = this._pointerData[a.id].timeUp - this._pointerData[a.id].timeDown, this.checkPointerOver(a) ? this.sprite && this.sprite.events && this.sprite.events.onInputUp.dispatch(this.sprite, a, !0) : (this.sprite && this.sprite.events && this.sprite.events.onInputUp.dispatch(this.sprite, a, !1), this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1)), this.draggable && (this.isDragged && this._draggedPointerID ===
                a.id) && this.stopDrag(a))
        },
        updateDrag: function(a) {
            if (a.isUp) return this.stopDrag(a), !1;
            this.sprite.fixedToCamera ? (this.allowHorizontalDrag && (this.sprite.cameraOffset.x = a.x + this._dragPoint.x + this.dragOffset.x), this.allowVerticalDrag && (this.sprite.cameraOffset.y = a.y + this._dragPoint.y + this.dragOffset.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) *
                this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)) : (this.allowHorizontalDrag && (this.sprite.x = a.x + this._dragPoint.x + this.dragOffset.x), this.allowVerticalDrag && (this.sprite.y = a.y + this._dragPoint.y + this.dragOffset.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX %
                this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY));
            return !0
        },
        justOver: function(a, b) {
            a = a || 0;
            return this._pointerData[a].isOver && this.overDuration(a) < (b || 500)
        },
        justOut: function(a, b) {
            a = a || 0;
            return this._pointerData[a].isOut && this.game.time.now - this._pointerData[a].timeOut < (b || 500)
        },
        justPressed: function(a, b) {
            a = a || 0;
            return this._pointerData[a].isDown && this.downDuration(a) <
                (b || 500)
        },
        justReleased: function(a, b) {
            a = a || 0;
            return this._pointerData[a].isUp && this.game.time.now - this._pointerData[a].timeUp < (b || 500)
        },
        overDuration: function(a) {
            a = a || 0;
            return this._pointerData[a].isOver ? this.game.time.now - this._pointerData[a].timeOver : -1
        },
        downDuration: function(a) {
            a = a || 0;
            return this._pointerData[a].isDown ? this.game.time.now - this._pointerData[a].timeDown : -1
        },
        enableDrag: function(a, b, d, e, f, h) {
            "undefined" == typeof a && (a = !1);
            "undefined" == typeof b && (b = !1);
            "undefined" == typeof d && (d = !1);
            "undefined" ==
            typeof e && (e = 255);
            "undefined" == typeof f && (f = null);
            "undefined" == typeof h && (h = null);
            this._dragPoint = new c.Point;
            this.draggable = !0;
            this.bringToTop = b;
            this.dragOffset = new c.Point;
            this.dragFromCenter = a;
            this.pixelPerfect = d;
            this.pixelPerfectAlpha = e;
            f && (this.boundsRect = f);
            h && (this.boundsSprite = h)
        },
        disableDrag: function() {
            if (this._pointerData)
                for (var a = 0; 10 > a; a++) this._pointerData[a].isDragged = !1;
            this.isDragged = this.draggable = !1;
            this._draggedPointerID = -1
        },
        startDrag: function(a) {
            this.isDragged = !0;
            this._draggedPointerID =
                a.id;
            this._pointerData[a.id].isDragged = !0;
            if (this.sprite.fixedToCamera) this.dragFromCenter && this.sprite.centerOn(a.x, a.y), this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y);
            else {
                if (this.dragFromCenter) {
                    var b = this.sprite.getBounds();
                    this.sprite.x = a.x + (this.sprite.x - b.centerX);
                    this.sprite.y = a.y + (this.sprite.y - b.centerY)
                }
                this._dragPoint.setTo(this.sprite.x - a.x, this.sprite.y - a.y)
            }
            this.updateDrag(a);
            this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop());
            this.sprite.events.onDragStart.dispatch(this.sprite,
                a)
        },
        stopDrag: function(a) {
            this.isDragged = !1;
            this._draggedPointerID = -1;
            this._dragPhase = this._pointerData[a.id].isDragged = !1;
            this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x -
                this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY));
            this.sprite.events.onDragStop.dispatch(this.sprite, a);
            !1 === this.checkPointerOver(a) && this._pointerOutHandler(a)
        },
        setDragLock: function(a, b) {
            "undefined" == typeof a && (a = !0);
            "undefined" == typeof b && (b = !0);
            this.allowHorizontalDrag = a;
            this.allowVerticalDrag = b
        },
        enableSnap: function(a, b, c, e, f, h) {
            "undefined" == typeof c &&
                (c = !0);
            "undefined" == typeof e && (e = !1);
            "undefined" == typeof f && (f = 0);
            "undefined" == typeof h && (h = 0);
            this.snapX = a;
            this.snapY = b;
            this.snapOffsetX = f;
            this.snapOffsetY = h;
            this.snapOnDrag = c;
            this.snapOnRelease = e
        },
        disableSnap: function() {
            this.snapOnRelease = this.snapOnDrag = !1
        },
        checkBoundsRect: function() {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x =
                this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.x < this.boundsRect.left ? this.sprite.x = this.boundsRect.x : this.sprite.x + this.sprite.width > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - this.sprite.width), this.sprite.y < this.boundsRect.top ? this.sprite.y =
                this.boundsRect.top : this.sprite.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - this.sprite.height))
        },
        checkBoundsSprite: function() {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x +
                this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.x < this.boundsSprite.x ? this.sprite.x = this.boundsSprite.x : this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width &&
                (this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width), this.sprite.y < this.boundsSprite.y ? this.sprite.y = this.boundsSprite.y : this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height && (this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height))
        }
    };
    c.InputHandler.prototype.constructor = c.InputHandler;
    c.Events = function(a) {
        this.parent = a;
        this.onAddedToGroup = new c.Signal;
        this.onRemovedFromGroup = new c.Signal;
        this.onKilled = new c.Signal;
        this.onRevived =
            new c.Signal;
        this.onOutOfBounds = new c.Signal;
        this.onEnterBounds = new c.Signal;
        this.onAnimationLoop = this.onAnimationComplete = this.onAnimationStart = this.onDragStop = this.onDragStart = this.onInputUp = this.onInputDown = this.onInputOut = this.onInputOver = null
    };
    c.Events.prototype = {
        destroy: function() {
            this.parent = null;
            this.onAddedToGroup.dispose();
            this.onRemovedFromGroup.dispose();
            this.onKilled.dispose();
            this.onRevived.dispose();
            this.onOutOfBounds.dispose();
            this.onInputOver && (this.onInputOver.dispose(), this.onInputOut.dispose(),
                this.onInputDown.dispose(), this.onInputUp.dispose(), this.onDragStart.dispose(), this.onDragStop.dispose());
            this.onAnimationStart && (this.onAnimationStart.dispose(), this.onAnimationComplete.dispose(), this.onAnimationLoop.dispose())
        }
    };
    c.Events.prototype.constructor = c.Events;
    c.GameObjectFactory = function(a) {
        this.game = a;
        this.world = this.game.world
    };
    c.GameObjectFactory.prototype = {
        existing: function(a) {
            return this.world.add(a)
        },
        image: function(a, b, d, e, f) {
            "undefined" === typeof f && (f = this.world);
            return f.add(new c.Image(this.game,
                a, b, d, e))
        },
        sprite: function(a, b, c, e, f) {
            "undefined" === typeof f && (f = this.world);
            return f.create(a, b, c, e)
        },
        tween: function(a) {
            return this.game.tweens.create(a)
        },
        group: function(a, b, d, e, f) {
            return new c.Group(this.game, a, b, d, e, f)
        },
        physicsGroup: function(a, b, d, e) {
            return new c.Group(this.game, b, d, e, !0, a)
        },
        spriteBatch: function(a, b, d) {
            "undefined" === typeof b && (b = "group");
            "undefined" === typeof d && (d = !1);
            return new c.SpriteBatch(this.game, a, b, d)
        },
        audio: function(a, b, c, e) {
            return this.game.sound.add(a, b, c, e)
        },
        sound: function(a,
            b, c, e) {
            return this.game.sound.add(a, b, c, e)
        },
        tileSprite: function(a, b, d, e, f, h, k) {
            "undefined" === typeof k && (k = this.world);
            return k.add(new c.TileSprite(this.game, a, b, d, e, f, h))
        },
        text: function(a, b, d, e, f) {
            "undefined" === typeof f && (f = this.world);
            return f.add(new c.Text(this.game, a, b, d, e))
        },
        button: function(a, b, d, e, f, h, k, g, l, m) {
            "undefined" === typeof m && (m = this.world);
            return m.add(new c.Button(this.game, a, b, d, e, f, h, k, g, l))
        },
        graphics: function(a, b, d) {
            "undefined" === typeof d && (d = this.world);
            return d.add(new c.Graphics(this.game,
                a, b))
        },
        emitter: function(a, b, d) {
            return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game, a, b, d))
        },
        retroFont: function(a, b, d, e, f, h, k, g, l) {
            return new c.RetroFont(this.game, a, b, d, e, f, h, k, g, l)
        },
        bitmapText: function(a, b, d, e, f, h) {
            "undefined" === typeof h && (h = this.world);
            return h.add(new c.BitmapText(this.game, a, b, d, e, f))
        },
        tilemap: function(a, b, d, e, f) {
            return new c.Tilemap(this.game, a, b, d, e, f)
        },
        renderTexture: function(a, b, d, e) {
            if ("undefined" === typeof d || "" === d) d = this.game.rnd.uuid();
            "undefined" ===
            typeof e && (e = !1);
            a = new c.RenderTexture(this.game, a, b, d);
            e && this.game.cache.addRenderTexture(d, a);
            return a
        },
        bitmapData: function(a, b, d, e) {
            "undefined" === typeof e && (e = !1);
            if ("undefined" === typeof d || "" === d) d = this.game.rnd.uuid();
            a = new c.BitmapData(this.game, d, a, b);
            e && this.game.cache.addBitmapData(d, a);
            return a
        },
        filter: function(a) {
            var b = Array.prototype.splice.call(arguments, 1);
            a = new c.Filter[a](this.game);
            a.init.apply(a, b);
            return a
        }
    };
    c.GameObjectFactory.prototype.constructor = c.GameObjectFactory;
    c.GameObjectCreator =
        function(a) {
            this.game = a;
            this.world = this.game.world
        };
    c.GameObjectCreator.prototype = {
        image: function(a, b, d, e) {
            return new c.Image(this.game, a, b, d, e)
        },
        sprite: function(a, b, d, e) {
            return new c.Sprite(this.game, a, b, d, e)
        },
        tween: function(a) {
            return new c.Tween(a, this.game)
        },
        group: function(a, b, d, e, f) {
            return new c.Group(this.game, null, b, d, e, f)
        },
        spriteBatch: function(a, b, d) {
            "undefined" === typeof b && (b = "group");
            "undefined" === typeof d && (d = !1);
            return new c.SpriteBatch(this.game, a, b, d)
        },
        audio: function(a, b, c, e) {
            return this.game.sound.add(a,
                b, c, e)
        },
        sound: function(a, b, c, e) {
            return this.game.sound.add(a, b, c, e)
        },
        tileSprite: function(a, b, d, e, f, h) {
            return new c.TileSprite(this.game, a, b, d, e, f, h)
        },
        text: function(a, b, d, e) {
            return new c.Text(this.game, a, b, d, e)
        },
        button: function(a, b, d, e, f, h, k, g, l) {
            return new c.Button(this.game, a, b, d, e, f, h, k, g, l)
        },
        graphics: function(a, b) {
            return new c.Graphics(this.game, a, b)
        },
        emitter: function(a, b, d) {
            return new c.Particles.Arcade.Emitter(this.game, a, b, d)
        },
        retroFont: function(a, b, d, e, f, h, k, g, l) {
            return new c.RetroFont(this.game,
                a, b, d, e, f, h, k, g, l)
        },
        bitmapText: function(a, b, d, e, f) {
            return new c.BitmapText(this.game, a, b, d, e, f)
        },
        tilemap: function(a, b, d, e, f) {
            return new c.Tilemap(this.game, a, b, d, e, f)
        },
        renderTexture: function(a, b, d, e) {
            if ("undefined" === typeof d || "" === d) d = this.game.rnd.uuid();
            "undefined" === typeof e && (e = !1);
            a = new c.RenderTexture(this.game, a, b, d);
            e && this.game.cache.addRenderTexture(d, a);
            return a
        },
        bitmapData: function(a, b, d, e) {
            "undefined" === typeof e && (e = !1);
            if ("undefined" === typeof d || "" === d) d = this.game.rnd.uuid();
            a = new c.BitmapData(this.game,
                d, a, b);
            e && this.game.cache.addBitmapData(d, a);
            return a
        },
        filter: function(a) {
            var b = Array.prototype.splice.call(arguments, 1);
            a = new c.Filter[a](this.game);
            a.init.apply(a, b);
            return a
        }
    };
    c.GameObjectCreator.prototype.constructor = c.GameObjectCreator;
    c.BitmapData = function(a, b, d, e) {
        "undefined" === typeof d && (d = 100);
        "undefined" === typeof e && (e = 100);
        this.game = a;
        this.key = b;
        this.width = d;
        this.height = e;
        this.canvas = c.Canvas.create(d, e, "", !0);
        this.ctx = this.context = this.canvas.getContext("2d");
        this.imageData = this.context.getImageData(0,
            0, d, e);
        this.data = this.imageData.data;
        this.pixels = null;
        this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data;
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new c.Frame(0, 0, 0, d, e, "bitmapData", a.rnd.uuid());
        this.type = c.BITMAPDATA;
        this.dirty = this.disableTextureUpload = !1;
        this.cls = this.clear;
        this.update = this.refreshBuffer;
        this._tempB = this._tempG = this._tempR = 0
    };
    c.BitmapData.prototype = {
        add: function(a) {
            if (Array.isArray(a))
                for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
            else a.loadTexture(this)
        },
        clear: function() {
            this.context.clearRect(0, 0, this.width, this.height);
            this.dirty = !0
        },
        fill: function(a, b, c, e) {
            "undefined" === typeof e && (e = 1);
            this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + e + ")";
            this.context.fillRect(0, 0,
                this.width, this.height);
            this.dirty = !0
        },
        resize: function(a, b) {
            if (a !== this.width || b !== this.height) this.width = a, this.height = b, this.canvas.width = a, this.canvas.height = b, this.textureFrame.width = a, this.textureFrame.height = b, this.refreshBuffer();
            this.dirty = !0
        },
        refreshBuffer: function(a, b, c, e) {
            "undefined" === typeof a && (a = 0);
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = this.width);
            "undefined" === typeof e && (e = this.height);
            this.imageData = this.context.getImageData(a, b, c, e);
            this.data = this.imageData.data;
            this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data
        },
        processPixelRGB: function(a, b, d, e, f, h) {
            "undefined" === typeof d && (d = 0);
            "undefined" === typeof e && (e = 0);
            "undefined" === typeof f && (f = this.width);
            "undefined" === typeof h && (h = this.height);
            f = d + f;
            h = e + h;
            for (var k = c.Color.createColor(), g = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    },
                    l = !1; e < h; e++)
                for (var m = d; m < f; m++) c.Color.unpackPixel(this.getPixel32(m, e), k), g = a.call(b, k, m, e), !1 !== g && (null !== g && void 0 !== g) && (this.setPixel32(m, e, g.r, g.g, g.b, g.a, !1), l = !0);
            l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)
        },
        processPixel: function(a, b, c, e, f, h) {
            "undefined" === typeof c && (c = 0);
            "undefined" === typeof e && (e = 0);
            "undefined" === typeof f && (f = this.width);
            "undefined" === typeof h && (h = this.height);
            f = c + f;
            h = e + h;
            for (var k = 0, g = 0, l = !1; e < h; e++)
                for (var m = c; m < f; m++) k = this.getPixel32(m, e), g = a.call(b,
                    k, m, e), g !== k && (this.pixels[e * this.width + m] = g, l = !0);
            l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)
        },
        replaceRGB: function(a, b, d, e, f, h, k, g, l) {
            var m = 0,
                n = 0,
                q = this.width,
                s = this.height;
            a = c.Color.packPixel(a, b, d, e);
            void 0 !== l && l instanceof c.Rectangle && (m = l.x, n = l.y, q = l.width, s = l.height);
            for (l = 0; l < s; l++)
                for (b = 0; b < q; b++) this.getPixel32(m + b, n + l) === a && this.setPixel32(m + b, n + l, f, h, k, g, !1);
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = !0
        },
        setHSL: function(a, b, d, e) {
            if ("undefined" === typeof a ||
                null === a) a = !1;
            if ("undefined" === typeof b || null === b) b = !1;
            if ("undefined" === typeof d || null === d) d = !1;
            if (a || b || d) {
                "undefined" === typeof e && (e = new c.Rectangle(0, 0, this.width, this.height));
                for (var f = c.Color.createColor(), h = e.y; h < e.bottom; h++)
                    for (var k = e.x; k < e.right; k++) c.Color.unpackPixel(this.getPixel32(k, h), f, !0), a && (f.h = a), b && (f.s = b), d && (f.l = d), c.Color.HSLtoRGB(f.h, f.s, f.l, f), this.setPixel32(k, h, f.r, f.g, f.b, f.a, !1);
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = !0
            }
        },
        shiftHSL: function(a, b, d, e) {
            if ("undefined" ===
                typeof a || null === a) a = !1;
            if ("undefined" === typeof b || null === b) b = !1;
            if ("undefined" === typeof d || null === d) d = !1;
            if (a || b || d) {
                "undefined" === typeof e && (e = new c.Rectangle(0, 0, this.width, this.height));
                for (var f = c.Color.createColor(), h = e.y; h < e.bottom; h++)
                    for (var k = e.x; k < e.right; k++) c.Color.unpackPixel(this.getPixel32(k, h), f, !0), a && (f.h = this.game.math.wrap(f.h + a, 0, 1)), b && (f.s = this.game.math.limitValue(f.s + b, 0, 1)), d && (f.l = this.game.math.limitValue(f.l + d, 0, 1)), c.Color.HSLtoRGB(f.h, f.s, f.l, f), this.setPixel32(k, h,
                        f.r, f.g, f.b, f.a, !1);
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = !0
            }
        },
        setPixel32: function(a, b, d, e, f, h, k) {
            "undefined" === typeof k && (k = !0);
            0 <= a && (a <= this.width && 0 <= b && b <= this.height) && (this.pixels[b * this.width + a] = c.Device.LITTLE_ENDIAN ? h << 24 | f << 16 | e << 8 | d : d << 24 | e << 16 | f << 8 | h, k && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0))
        },
        setPixel: function(a, b, c, e, f, h) {
            this.setPixel32(a, b, c, e, f, 255, h)
        },
        getPixel: function(a, b, d) {
            d || (d = c.Color.createColor());
            a = ~~(a + b * this.width);
            a *= 4;
            this.data[a] &&
                (d.r = this.data[a], d.g = this.data[++a], d.b = this.data[++a], d.a = this.data[++a]);
            return d
        },
        getPixel32: function(a, b) {
            if (0 <= a && a <= this.width && 0 <= b && b <= this.height) return this.pixels[b * this.width + a]
        },
        getPixelRGB: function(a, b, d, e, f) {
            return c.Color.unpackPixel(this.getPixel32(a, b), d, e, f)
        },
        getPixels: function(a) {
            return this.context.getImageData(a.x, a.y, a.width, a.height)
        },
        copyPixels: function(a, b, c, e) {
            "string" === typeof a && (a = this.game.cache.getImage(a));
            a && this.context.drawImage(a, b.x, b.y, b.width, b.height, c, e,
                b.width, b.height);
            this.dirty = !0
        },
        draw: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 0);
            "string" === typeof a && (a = this.game.cache.getImage(a));
            a && this.context.drawImage(a, 0, 0, a.width, a.height, b, c, a.width, a.height);
            this.dirty = !0
        },
        drawSprite: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 0);
            var e = a.texture.frame;
            this.context.drawImage(a.texture.baseTexture.source, e.x, e.y, e.width, e.height, b, c, e.width, e.height);
            this.dirty = !0
        },
        alphaMask: function(a, b) {
            var c =
                this.context.globalCompositeOperation;
            "string" === typeof b && (b = this.game.cache.getImage(b));
            b && this.context.drawImage(b, 0, 0);
            this.context.globalCompositeOperation = "source-atop";
            "string" === typeof a && (a = this.game.cache.getImage(a));
            a && this.context.drawImage(a, 0, 0);
            this.context.globalCompositeOperation = c;
            this.dirty = !0
        },
        extract: function(a, b, c, e, f) {
            "undefined" === typeof f && (f = 255);
            this.processPixelRGB(function(h, k, g) {
                h.r === b && (h.g === c && h.b === e) && a.setPixel32(k, g, b, c, e, f, !1);
                return !1
            }, this);
            a.context.putImageData(a.imageData,
                0, 0);
            a.dirty = !0;
            return a
        },
        rect: function(a, b, c, e, f) {
            "undefined" !== typeof f && (this.context.fillStyle = f);
            this.context.fillRect(a, b, c, e);
            this.context.fill()
        },
        circle: function(a, b, c, e) {
            "undefined" !== typeof e && (this.context.fillStyle = e);
            this.context.beginPath();
            this.context.arc(a, b, c, 0, 2 * Math.PI, !1);
            this.context.closePath();
            this.context.fill()
        },
        render: function() {
            !this.disableTextureUpload && (this.game.renderType === c.WEBGL && this.dirty) && (PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl), this.dirty = !1)
        }
    };
    c.BitmapData.prototype.constructor = c.BitmapData;
    c.Sprite = function(a, b, d, e, f) {
        b = b || 0;
        d = d || 0;
        e = e || null;
        f = f || null;
        this.game = a;
        this.name = "";
        this.type = c.SPRITE;
        this.z = 0;
        this.events = new c.Events(this);
        this.animations = new c.AnimationManager(this);
        this.key = e;
        this._frame = 0;
        this._frameName = "";
        PIXI.Sprite.call(this, PIXI.TextureCache.__default);
        this.loadTexture(e, f);
        this.position.set(b, d);
        this.world = new c.Point(b, d);
        this.autoCull = !1;
        this.body = this.input = null;
        this.health = 1;
        this.lifespan = 0;
        this.debug = this.outOfBoundsKill =
            this.checkWorldBounds = !1;
        this.cameraOffset = new c.Point;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
        this._bounds = new c.Rectangle
    };
    c.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    c.Sprite.prototype.constructor = c.Sprite;
    c.Sprite.prototype.preUpdate = function() {
        if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, this._cache[1] =
            this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), this._cache[4] = 0, !1;
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
        if (0 < this.lifespan && (this.lifespan -= this.game.time.elapsed, 0 >= this.lifespan)) return this.kill(), !1;
        (this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds());
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds));
        if (this.checkWorldBounds)
            if (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds)) this._cache[5] = 0, this.events.onEnterBounds.dispatch(this);
            else if (0 === this._cache[5] && !this.game.world.bounds.intersects(this._bounds) && (this._cache[5] = 1, this.events.onOutOfBounds.dispatch(this), this.outOfBoundsKill)) return this.kill(), !1;
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        this.animations.update();
        this.body && this.body.preUpdate();
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].preUpdate();
        return !0
    };
    c.Sprite.prototype.update = function() {};
    c.Sprite.prototype.postUpdate = function() {
        this.key instanceof c.BitmapData && this.key.render();
        this.exists && this.body && this.body.postUpdate();
        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].postUpdate()
    };
    c.Sprite.prototype.loadTexture = function(a, b) {
        b = b || 0;
        a instanceof c.RenderTexture ? (this.key = a.key, this.setTexture(a)) : a instanceof c.BitmapData ? (this.key = a, this.setTexture(a.texture)) : a instanceof PIXI.Texture ? (this.key = a, this.setTexture(a)) : null === a || "undefined" === typeof a ? (this.key = "__default", this.setTexture(PIXI.TextureCache[this.key])) : "string" === typeof a && !this.game.cache.checkImageKey(a) ? (this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])) :
            this.game.cache.isSpriteSheet(a) ? (this.key = a, this.animations.loadFrameData(this.game.cache.getFrameData(a)), "string" === typeof b ? this.frameName = b : this.frame = b) : (this.key = a, this.setTexture(PIXI.TextureCache[a]))
    };
    c.Sprite.prototype.crop = function(a) {
        if ("undefined" === typeof a || null === a) this.texture.hasOwnProperty("sourceWidth") && this.texture.setFrame(new c.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight));
        else if (this.texture instanceof PIXI.Texture) {
            var b = {};
            c.Utils.extend(!0, b, this.texture);
            b.sourceWidth = b.width;
            b.sourceHeight = b.height;
            b.frame = a;
            b.width = a.width;
            b.height = a.height;
            this.texture = b;
            this.texture.updateFrame = !0;
            PIXI.Texture.frameUpdates.push(this.texture)
        } else this.texture.setFrame(a)
    };
    c.Sprite.prototype.revive = function(a) {
        "undefined" === typeof a && (a = 1);
        this.visible = this.exists = this.alive = !0;
        this.health = a;
        this.events && this.events.onRevived.dispatch(this);
        return this
    };
    c.Sprite.prototype.kill = function() {
        this.visible = this.exists = this.alive = !1;
        this.events && this.events.onKilled.dispatch(this);
        return this
    };
    c.Sprite.prototype.destroy = function(a) {
        if (!(null === this.game || 1 === this._cache[8])) {
            "undefined" === typeof a && (a = !0);
            this._cache[8] = 1;
            this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            this.input && this.input.destroy();
            this.animations && this.animations.destroy();
            this.body && this.body.destroy();
            this.events && this.events.destroy();
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy(a);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = this.alive = !1;
            this.game = this.mask = this.filters = null;
            this._cache[8] = 0
        }
    };
    c.Sprite.prototype.damage = function(a) {
        this.alive && (this.health -= a, 0 >= this.health && this.kill());
        return this
    };
    c.Sprite.prototype.reset = function(a, b, c) {
        "undefined" === typeof c && (c = 1);
        this.world.setTo(a, b);
        this.position.x = a;
        this.position.y = b;
        this.renderable = this.visible = this.exists = this.alive = !0;
        this._outOfBoundsFired = !1;
        this.health = c;
        this.body && this.body.reset(a, b, !1, !1);
        this._cache[4] = 1;
        return this
    };
    c.Sprite.prototype.bringToTop =
        function() {
            this.parent && this.parent.bringToTop(this);
            return this
        };
    c.Sprite.prototype.play = function(a, b, c, e) {
        if (this.animations) return this.animations.play(a, b, c, e)
    };
    c.Sprite.prototype.overlap = function(a) {
        return c.Rectangle.intersects(this.getBounds(), a.getBounds())
    };
    Object.defineProperty(c.Sprite.prototype, "angle", {
        get: function() {
            return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
        }
    });
    Object.defineProperty(c.Sprite.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0]
        }
    });
    Object.defineProperty(c.Sprite.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1]
        }
    });
    Object.defineProperty(c.Sprite.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2]
        }
    });
    Object.defineProperty(c.Sprite.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds())
        }
    });
    Object.defineProperty(c.Sprite.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds())
        }
    });
    Object.defineProperty(c.Sprite.prototype, "frame", {
        get: function() {
            return this.animations.frame
        },
        set: function(a) {
            this.animations.frame = a
        }
    });
    Object.defineProperty(c.Sprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName
        },
        set: function(a) {
            this.animations.frameName = a
        }
    });
    Object.defineProperty(c.Sprite.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3]
        }
    });
    Object.defineProperty(c.Sprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(a) {
            a ?
                null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
        }
    });
    Object.defineProperty(c.Sprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6]
        },
        set: function(a) {
            a ? (this._cache[6] = 1, this.body && this.body.type === c.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === c.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
        }
    });
    Object.defineProperty(c.Sprite.prototype,
        "fixedToCamera", {
            get: function() {
                return !!this._cache[7]
            },
            set: function(a) {
                a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
            }
        });
    Object.defineProperty(c.Sprite.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode
        },
        set: function(a) {
            a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
        }
    });
    Object.defineProperty(c.Sprite.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(a) {
            this.position.x =
                a;
            this.body && (this.body.type === c.Physics.ARCADE && 2 === this.body.phase) && (this.body._reset = 1)
        }
    });
    Object.defineProperty(c.Sprite.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(a) {
            this.position.y = a;
            this.body && (this.body.type === c.Physics.ARCADE && 2 === this.body.phase) && (this.body._reset = 1)
        }
    });
    Object.defineProperty(c.Sprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.Image = function(a, b, d, e, f) {
        b = b || 0;
        d = d || 0;
        e = e || null;
        f = f || null;
        this.game = a;
        this.exists = !0;
        this.name =
            "";
        this.type = c.IMAGE;
        this.z = 0;
        this.events = new c.Events(this);
        this.key = e;
        this._frame = 0;
        this._frameName = "";
        PIXI.Sprite.call(this, PIXI.TextureCache.__default);
        this.loadTexture(e, f);
        this.position.set(b, d);
        this.world = new c.Point(b, d);
        this.autoCull = !1;
        this.input = null;
        this.cameraOffset = new c.Point;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    c.Image.prototype = Object.create(PIXI.Sprite.prototype);
    c.Image.prototype.constructor = c.Image;
    c.Image.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds()));
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].preUpdate();
        return !0
    };
    c.Image.prototype.update = function() {};
    c.Image.prototype.postUpdate =
        function() {
            this.key instanceof c.BitmapData && this.key.render();
            1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
            for (var a = 0, b = this.children.length; a < b; a++) this.children[a].postUpdate()
        };
    c.Image.prototype.loadTexture = function(a, b) {
        b = b || 0;
        if (a instanceof c.RenderTexture) this.key = a.key, this.setTexture(a);
        else if (a instanceof c.BitmapData) this.key = a, this.setTexture(a.texture);
        else if (a instanceof PIXI.Texture) this.key = a, this.setTexture(a);
        else if (null === a || "undefined" === typeof a) this.key = "__default", this.setTexture(PIXI.TextureCache[this.key]);
        else if ("string" === typeof a && !this.game.cache.checkImageKey(a)) this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key]);
        else if (this.game.cache.isSpriteSheet(a)) {
            this.key = a;
            var d = this.game.cache.getFrameData(a);
            "string" === typeof b ? (this._frame = 0, this._frameName = b, this.setTexture(PIXI.TextureCache[d.getFrameByName(b).uuid])) :
                (this._frame = b, this._frameName = "", this.setTexture(PIXI.TextureCache[d.getFrame(b).uuid]))
        } else this.key = a, this.setTexture(PIXI.TextureCache[a])
    };
    c.Image.prototype.crop = function(a) {
        if ("undefined" === typeof a || null === a) this.texture.hasOwnProperty("sourceWidth") && this.texture.setFrame(new c.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight));
        else if (this.texture instanceof PIXI.Texture) {
            var b = {};
            c.Utils.extend(!0, b, this.texture);
            b.sourceWidth = b.width;
            b.sourceHeight = b.height;
            b.frame = a;
            b.width =
                a.width;
            b.height = a.height;
            this.texture = b;
            this.texture.updateFrame = !0;
            PIXI.Texture.frameUpdates.push(this.texture)
        } else this.texture.setFrame(a)
    };
    c.Image.prototype.revive = function() {
        this.visible = this.exists = this.alive = !0;
        this.events && this.events.onRevived.dispatch(this);
        return this
    };
    c.Image.prototype.kill = function() {
        this.visible = this.exists = this.alive = !1;
        this.events && this.events.onKilled.dispatch(this);
        return this
    };
    c.Image.prototype.destroy = function(a) {
        if (!(null === this.game || this.destroyPhase)) {
            "undefined" ===
            typeof a && (a = !0);
            this._cache[8] = 1;
            this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            this.events && this.events.destroy();
            this.input && this.input.destroy();
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy(a);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = this.alive = !1;
            this.game = this.mask = this.filters = null;
            this._cache[8] = 0
        }
    };
    c.Image.prototype.reset = function(a, b) {
        this.world.setTo(a, b);
        this.position.x = a;
        this.position.y =
            b;
        this.renderable = this.visible = this.exists = this.alive = !0;
        return this
    };
    c.Image.prototype.bringToTop = function() {
        this.parent && this.parent.bringToTop(this);
        return this
    };
    Object.defineProperty(c.Image.prototype, "angle", {
        get: function() {
            return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
        }
    });
    Object.defineProperty(c.Image.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0]
        }
    });
    Object.defineProperty(c.Image.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1]
        }
    });
    Object.defineProperty(c.Image.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2]
        }
    });
    Object.defineProperty(c.Image.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds())
        }
    });
    Object.defineProperty(c.Image.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds())
        }
    });
    Object.defineProperty(c.Image.prototype, "frame", {
        get: function() {
            return this._frame
        },
        set: function(a) {
            if (a !== this.frame && this.game.cache.isSpriteSheet(this.key)) {
                var b = this.game.cache.getFrameData(this.key);
                b && (a < b.total && b.getFrame(a)) && (this.setTexture(PIXI.TextureCache[b.getFrame(a).uuid]), this._frame = a)
            }
        }
    });
    Object.defineProperty(c.Image.prototype, "frameName", {
        get: function() {
            return this._frameName
        },
        set: function(a) {
            if (a !== this.frameName && this.game.cache.isSpriteSheet(this.key)) {
                var b = this.game.cache.getFrameData(this.key);
                b && b.getFrameByName(a) && (this.setTexture(PIXI.TextureCache[b.getFrameByName(a).uuid]),
                    this._frameName = a)
            }
        }
    });
    Object.defineProperty(c.Image.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3]
        }
    });
    Object.defineProperty(c.Image.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(a) {
            a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
        }
    });
    Object.defineProperty(c.Image.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    Object.defineProperty(c.Image.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode
        },
        set: function(a) {
            a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
        }
    });
    Object.defineProperty(c.Image.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.TileSprite = function(a, b, d, e, f, h, k) {
        b = b || 0;
        d = d || 0;
        e = e || 256;
        f = f || 256;
        h = h ||
            null;
        k = k || null;
        this.game = a;
        this.name = "";
        this.type = c.TILESPRITE;
        this.z = 0;
        this.events = new c.Events(this);
        this.animations = new c.AnimationManager(this);
        this.key = h;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new c.Point;
        PIXI.TilingSprite.call(this, PIXI.TextureCache.__default, e, f);
        this.loadTexture(h, k);
        this.position.set(b, d);
        this.input = null;
        this.world = new c.Point(b, d);
        this.checkWorldBounds = this.autoCull = !1;
        this.cameraOffset = new c.Point;
        this.body = null;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    c.TileSprite.prototype =
        Object.create(PIXI.TilingSprite.prototype);
    c.TileSprite.prototype.constructor = c.TileSprite;
    c.TileSprite.prototype.preUpdate = function() {
        if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), this._cache[4] = 0, !1;
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
        (this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds());
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds));
        this.checkWorldBounds && (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds) ? (this._cache[5] = 0, this.events.onEnterBounds.dispatch(this)) : 0 === this._cache[5] && !this.game.world.bounds.intersects(this._bounds) &&
            (this._cache[5] = 1, this.events.onOutOfBounds.dispatch(this)));
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        this.animations.update();
        0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed);
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed);
        this.body && this.body.preUpdate();
        for (var a = 0, b = this.children.length; a <
            b; a++) this.children[a].preUpdate();
        return !0
    };
    c.TileSprite.prototype.update = function() {};
    c.TileSprite.prototype.postUpdate = function() {
        this.exists && this.body && this.body.postUpdate();
        1 === this._cache[7] && (this.position.x = this.game.camera.view.x + this.cameraOffset.x, this.position.y = this.game.camera.view.y + this.cameraOffset.y);
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].postUpdate()
    };
    c.TileSprite.prototype.autoScroll = function(a, b) {
        this._scroll.set(a, b)
    };
    c.TileSprite.prototype.stopScroll =
        function() {
            this._scroll.set(0, 0)
        };
    c.TileSprite.prototype.loadTexture = function(a, b) {
        b = b || 0;
        a instanceof c.RenderTexture ? (this.key = a.key, this.setTexture(a)) : a instanceof c.BitmapData ? (this.key = a, this.setTexture(a.texture)) : a instanceof PIXI.Texture ? (this.key = a, this.setTexture(a)) : null === a || "undefined" === typeof a ? (this.key = "__default", this.setTexture(PIXI.TextureCache[this.key])) : "string" === typeof a && !this.game.cache.checkImageKey(a) ? (this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])) :
            this.game.cache.isSpriteSheet(a) ? (this.key = a, this.animations.loadFrameData(this.game.cache.getFrameData(a)), "string" === typeof b ? this.frameName = b : this.frame = b) : (this.key = a, this.setTexture(PIXI.TextureCache[a]))
    };
    c.TileSprite.prototype.destroy = function(a) {
        if (!(null === this.game || this.destroyPhase)) {
            "undefined" === typeof a && (a = !0);
            this._cache[8] = 1;
            this.filters && (this.filters = null);
            this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            this.animations.destroy();
            this.events.destroy();
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy(a);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = !1;
            this.game = this.mask = this.filters = null;
            this._cache[8] = 0
        }
    };
    c.TileSprite.prototype.play = function(a, b, c, e) {
        return this.animations.play(a, b, c, e)
    };
    c.TileSprite.prototype.reset = function(a, b) {
        this.world.setTo(a, b);
        this.position.x = a;
        this.position.y = b;
        this.renderable = this.visible = this.exists = this.alive = !0;
        this._outOfBoundsFired = !1;
        this.tilePosition.x =
            0;
        this.tilePosition.y = 0;
        this.body && this.body.reset(a, b, !1, !1);
        this._cache[4] = 1;
        return this
    };
    Object.defineProperty(c.TileSprite.prototype, "angle", {
        get: function() {
            return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
        }
    });
    Object.defineProperty(c.TileSprite.prototype, "frame", {
        get: function() {
            return this.animations.frame
        },
        set: function(a) {
            a !== this.animations.frame && (this.animations.frame = a)
        }
    });
    Object.defineProperty(c.TileSprite.prototype,
        "frameName", {
            get: function() {
                return this.animations.frameName
            },
            set: function(a) {
                a !== this.animations.frameName && (this.animations.frameName = a)
            }
        });
    Object.defineProperty(c.TileSprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    Object.defineProperty(c.TileSprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6]
        },
        set: function(a) {
            a ? (this._cache[6] = 1, this.body && this.body.type === c.Physics.P2JS &&
                this.body.addToWorld(), this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === c.Physics.P2JS && (this.body.safeRemove = !0), this.visible = !1)
        }
    });
    Object.defineProperty(c.TileSprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(a) {
            a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
        }
    });
    Object.defineProperty(c.TileSprite.prototype,
        "x", {
            get: function() {
                return this.position.x
            },
            set: function(a) {
                this.position.x = a;
                this.body && (this.body.type === c.Physics.ARCADE && 2 === this.body.phase) && (this.body._reset = 1)
            }
        });
    Object.defineProperty(c.TileSprite.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(a) {
            this.position.y = a;
            this.body && (this.body.type === c.Physics.ARCADE && 2 === this.body.phase) && (this.body._reset = 1)
        }
    });
    Object.defineProperty(c.TileSprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.Text = function(a,
        b, d, e, f) {
        b = b || 0;
        d = d || 0;
        e = e || " ";
        f = f || {};
        e = 0 === e.length ? " " : e.toString();
        this.game = a;
        this.exists = !0;
        this.name = "";
        this.type = c.TEXT;
        this.z = 0;
        this.world = new c.Point(b, d);
        this._text = e;
        this._font = "";
        this._fontSize = 32;
        this._fontWeight = "normal";
        this._lineSpacing = 0;
        this.events = new c.Events(this);
        this.input = null;
        this.cameraOffset = new c.Point;
        this.setStyle(f);
        PIXI.Text.call(this, e, this.style);
        this.position.set(b, d);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    c.Text.prototype = Object.create(PIXI.Text.prototype);
    c.Text.prototype.constructor =
        c.Text;
    c.Text.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds()));
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        for (var a = 0, b = this.children.length; a <
            b; a++) this.children[a].preUpdate();
        return !0
    };
    c.Text.prototype.update = function() {};
    c.Text.prototype.postUpdate = function() {
        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
        for (var a = 0, b = this.children.length; a < b; a++) this.children[a].postUpdate()
    };
    c.Text.prototype.destroy = function(a) {
        if (!(null === this.game || this.destroyPhase)) {
            "undefined" === typeof a && (a = !0);
            this._cache[8] = 1;
            this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            this.texture.destroy();
            this.canvas.parentNode ? this.canvas.parentNode.removeChild(this.canvas) : this.context = this.canvas = null;
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy(a);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = !1;
            this.game = this.mask = this.filters = null;
            this._cache[8] = 0
        }
    };
    c.Text.prototype.setShadow = function(a, b, c, e) {
        this.style.shadowOffsetX =
            a || 0;
        this.style.shadowOffsetY = b || 0;
        this.style.shadowColor = c || "rgba(0,0,0,0)";
        this.style.shadowBlur = e || 0;
        this.dirty = !0
    };
    c.Text.prototype.setStyle = function(a) {
        a = a || {};
        a.font = a.font || "bold 20pt Arial";
        a.fill = a.fill || "black";
        a.align = a.align || "left";
        a.stroke = a.stroke || "black";
        a.strokeThickness = a.strokeThickness || 0;
        a.wordWrap = a.wordWrap || !1;
        a.wordWrapWidth = a.wordWrapWidth || 100;
        a.shadowOffsetX = a.shadowOffsetX || 0;
        a.shadowOffsetY = a.shadowOffsetY || 0;
        a.shadowColor = a.shadowColor || "rgba(0,0,0,0)";
        a.shadowBlur =
            a.shadowBlur || 0;
        this.style = a;
        this.dirty = !0
    };
    c.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var a = this.text;
        this.style.wordWrap && (a = this.runWordWrap(this.text));
        for (var a = a.split(/(?:\r\n|\r|\n)/), b = [], c = 0, e = 0; e < a.length; e++) {
            var f = this.context.measureText(a[e]).width;
            b[e] = f;
            c = Math.max(c, f)
        }
        this.canvas.width = c + this.style.strokeThickness;
        f = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;
        this.canvas.height =
            f * a.length;
        navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.shadowOffsetX = this.style.shadowOffsetX;
        this.context.shadowOffsetY = this.style.shadowOffsetY;
        this.context.shadowColor = this.style.shadowColor;
        this.context.shadowBlur = this.style.shadowBlur;
        this.context.textBaseline = "top";
        this.context.lineCap =
            "round";
        this.context.lineJoin = "round";
        for (e = 0; e < a.length; e++) {
            var h = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + e * f);
            "right" === this.style.align ? h.x += c - b[e] : "center" === this.style.align && (h.x += (c - b[e]) / 2);
            h.y += this._lineSpacing;
            this.style.stroke && this.style.strokeThickness && this.context.strokeText(a[e], h.x, h.y);
            this.style.fill && this.context.fillText(a[e], h.x, h.y)
        }
        this.updateTexture()
    };
    c.Text.prototype.runWordWrap = function(a) {
        var b = "";
        a = a.split("\n");
        for (var c = 0; c < a.length; c++) {
            for (var e =
                    this.style.wordWrapWidth, f = a[c].split(" "), h = 0; h < f.length; h++) {
                var k = this.context.measureText(f[h]).width,
                    g = k + this.context.measureText(" ").width;
                g > e ? (0 < h && (b += "\n"), b += f[h] + " ", e = this.style.wordWrapWidth - k) : (e -= g, b += f[h] + " ")
            }
            c < a.length - 1 && (b += "\n")
        }
        return b
    };
    Object.defineProperty(c.Text.prototype, "angle", {
        get: function() {
            return c.Math.radToDeg(this.rotation)
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(a)
        }
    });
    Object.defineProperty(c.Text.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            a !==
                this._text && (this._text = a.toString() || " ", this.dirty = !0, this.updateTransform())
        }
    });
    Object.defineProperty(c.Text.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(a) {
            a !== this._font && (this._font = a.trim(), this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
        }
    });
    Object.defineProperty(c.Text.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(a) {
            a = parseInt(a, 10);
            a !== this._fontSize && (this._fontSize = a, this.style.font =
                this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
        }
    });
    Object.defineProperty(c.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontWeight
        },
        set: function(a) {
            a !== this._fontWeight && (this._fontWeight = a, this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
        }
    });
    Object.defineProperty(c.Text.prototype, "fill", {
        get: function() {
            return this.style.fill
        },
        set: function(a) {
            a !== this.style.fill && (this.style.fill =
                a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "align", {
        get: function() {
            return this.style.align
        },
        set: function(a) {
            a !== this.style.align && (this.style.align = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke
        },
        set: function(a) {
            a !== this.style.stroke && (this.style.stroke = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness
        },
        set: function(a) {
            a !== this.style.strokeThickness &&
                (this.style.strokeThickness = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap
        },
        set: function(a) {
            a !== this.style.wordWrap && (this.style.wordWrap = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth
        },
        set: function(a) {
            a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing
        },
        set: function(a) {
            a !== this._lineSpacing && (this._lineSpacing = parseFloat(a), this.dirty = !0, this.updateTransform())
        }
    });
    Object.defineProperty(c.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX
        },
        set: function(a) {
            a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY
        },
        set: function(a) {
            a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor
        },
        set: function(a) {
            a !== this.style.shadowColor && (this.style.shadowColor = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur
        },
        set: function(a) {
            a !== this.style.shadowBlur && (this.style.shadowBlur = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.Text.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(a) {
            a ? null ===
                this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
        }
    });
    Object.defineProperty(c.Text.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    Object.defineProperty(c.Text.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.BitmapText = function(a, b, d, e, f, h) {
        b = b || 0;
        d =
            d || 0;
        e = e || "";
        f = f || "";
        h = h || 32;
        this.game = a;
        this.exists = !0;
        this.name = "";
        this.type = c.BITMAPTEXT;
        this.z = 0;
        this.world = new c.Point(b, d);
        this._text = f;
        this._font = e;
        this._fontSize = h;
        this._align = "left";
        this._tint = 16777215;
        this.events = new c.Events(this);
        this.input = null;
        this.cameraOffset = new c.Point;
        PIXI.BitmapText.call(this, f);
        this.position.set(b, d);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    c.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype);
    c.BitmapText.prototype.constructor = c.BitmapText;
    c.BitmapText.prototype.setStyle =
        function() {
            this.style = {
                align: this._align
            };
            this.fontName = this._font;
            this.fontSize = this._fontSize;
            this.dirty = !0
        };
    c.BitmapText.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds()));
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        return !0
    };
    c.BitmapText.prototype.update = function() {};
    c.BitmapText.prototype.postUpdate = function() {
        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    };
    c.BitmapText.prototype.destroy = function(a) {
        if (!(null === this.game || this.destroyPhase)) {
            "undefined" === typeof a && (a = !0);
            this._cache[8] = 1;
            this.parent &&
                (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy ? this.children[b].destroy(a) : this.removeChild(this.children[b]);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = !1;
            this.game = this.mask = this.filters = null;
            this._cache[8] = 0
        }
    };
    Object.defineProperty(c.BitmapText.prototype, "align", {
        get: function() {
            return this._align
        },
        set: function(a) {
            a !== this._align && (this._align = a, this.setStyle())
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint
        },
        set: function(a) {
            a !== this._tint && (this._tint = a, this.dirty = !0)
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "angle", {
        get: function() {
            return c.Math.radToDeg(this.rotation)
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(a)
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(a) {
            a !== this._font && (this._font = a.trim(), this.style.font = this._fontSize + "px '" + this._font + "'",
                this.dirty = !0)
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(a) {
            a = parseInt(a, 10);
            a !== this._fontSize && (this._fontSize = a, this.style.font = this._fontSize + "px '" + this._font + "'", this.dirty = !0)
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || " ", this.dirty = !0)
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "inputEnabled", {
        get: function() {
            return this.input &&
                this.input.enabled
        },
        set: function(a) {
            a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    Object.defineProperty(c.BitmapText.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.Button = function(a, b, d, e, f, h, k, g, l, m) {
        f = f || null;
        h = h || this;
        c.Image.call(this, a, b || 0, d || 0, e || null, g);
        this.type = c.BUTTON;
        this._onUpFrameID = this._onDownFrameID = this._onOutFrameID = this._onOverFrameID = this._onUpFrameName = this._onDownFrameName = this._onOutFrameName = this._onOverFrameName = null;
        this.onOverMouseOnly = !1;
        this.onUpSound = this.onDownSound = this.onOutSound = this.onOverSound = null;
        this.onUpSoundMarker = this.onDownSoundMarker = this.onOutSoundMarker = this.onOverSoundMarker = "";
        this.onInputOver = new c.Signal;
        this.onInputOut = new c.Signal;
        this.onInputDown = new c.Signal;
        this.onInputUp = new c.Signal;
        this.forceOut = this.freezeFrames = !1;
        this.inputEnabled = !0;
        this.input.start(0, !0);
        this.setFrames(k, g, l, m);
        null !== f && this.onInputUp.add(f, h);
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this)
    };
    c.Button.prototype = Object.create(c.Image.prototype);
    c.Button.prototype.constructor = c.Button;
    c.Button.prototype.clearFrames = function() {
        this._onUpFrameID = this._onUpFrameName = this._onDownFrameID = this._onDownFrameName = this._onOutFrameID = this._onOutFrameName = this._onOverFrameID = this._onOverFrameName = null
    };
    c.Button.prototype.setFrames = function(a, b, c, e) {
        this.clearFrames();
        null !== a && ("string" === typeof a ? (this._onOverFrameName = a, this.input.pointerOver() && (this.frameName = a)) : (this._onOverFrameID = a, this.input.pointerOver() && (this.frame = a)));
        null !== b && ("string" ===
            typeof b ? (this._onOutFrameName = b, !1 === this.input.pointerOver() && (this.frameName = b)) : (this._onOutFrameID = b, !1 === this.input.pointerOver() && (this.frame = b)));
        null !== c && ("string" === typeof c ? (this._onDownFrameName = c, this.input.pointerDown() && (this.frameName = c)) : (this._onDownFrameID = c, this.input.pointerDown() && (this.frame = c)));
        null !== e && ("string" === typeof e ? (this._onUpFrameName = e, this.input.pointerUp() && (this.frameName = e)) : (this._onUpFrameID = e, this.input.pointerUp() && (this.frame = e)))
    };
    c.Button.prototype.setSounds =
        function(a, b, c, e, f, h, k, g) {
            this.setOverSound(a, b);
            this.setOutSound(f, h);
            this.setDownSound(c, e);
            this.setUpSound(k, g)
        };
    c.Button.prototype.setOverSound = function(a, b) {
        this.onOverSound = null;
        this.onOverSoundMarker = "";
        a instanceof c.Sound && (this.onOverSound = a);
        "string" === typeof b && (this.onOverSoundMarker = b)
    };
    c.Button.prototype.setOutSound = function(a, b) {
        this.onOutSound = null;
        this.onOutSoundMarker = "";
        a instanceof c.Sound && (this.onOutSound = a);
        "string" === typeof b && (this.onOutSoundMarker = b)
    };
    c.Button.prototype.setDownSound =
        function(a, b) {
            this.onDownSound = null;
            this.onDownSoundMarker = "";
            a instanceof c.Sound && (this.onDownSound = a);
            "string" === typeof b && (this.onDownSoundMarker = b)
        };
    c.Button.prototype.setUpSound = function(a, b) {
        this.onUpSound = null;
        this.onUpSoundMarker = "";
        a instanceof c.Sound && (this.onUpSound = a);
        "string" === typeof b && (this.onUpSoundMarker = b)
    };
    c.Button.prototype.onInputOverHandler = function(a, b) {
        !1 === this.freezeFrames && this.setState(1);
        if (!this.onOverMouseOnly || b.isMouse) this.onOverSound && this.onOverSound.play(this.onOverSoundMarker),
            this.onInputOver && this.onInputOver.dispatch(this, b)
    };
    c.Button.prototype.onInputOutHandler = function(a, b) {
        !1 === this.freezeFrames && this.setState(2);
        this.onOutSound && this.onOutSound.play(this.onOutSoundMarker);
        this.onInputOut && this.onInputOut.dispatch(this, b)
    };
    c.Button.prototype.onInputDownHandler = function(a, b) {
        !1 === this.freezeFrames && this.setState(3);
        this.onDownSound && this.onDownSound.play(this.onDownSoundMarker);
        this.onInputDown && this.onInputDown.dispatch(this, b)
    };
    c.Button.prototype.onInputUpHandler =
        function(a, b, c) {
            this.onUpSound && this.onUpSound.play(this.onUpSoundMarker);
            this.onInputUp && this.onInputUp.dispatch(this, b, c);
            this.freezeFrames || (this.forceOut ? this.setState(2) : null !== this._onUpFrameName || null !== this._onUpFrameID ? this.setState(4) : c ? this.setState(1) : this.setState(2))
        };
    c.Button.prototype.setState = function(a) {
        1 === a ? null != this._onOverFrameName ? this.frameName = this._onOverFrameName : null != this._onOverFrameID && (this.frame = this._onOverFrameID) : 2 === a ? null != this._onOutFrameName ? this.frameName =
            this._onOutFrameName : null != this._onOutFrameID && (this.frame = this._onOutFrameID) : 3 === a ? null != this._onDownFrameName ? this.frameName = this._onDownFrameName : null != this._onDownFrameID && (this.frame = this._onDownFrameID) : 4 === a && (null != this._onUpFrameName ? this.frameName = this._onUpFrameName : null != this._onUpFrameID && (this.frame = this._onUpFrameID))
    };
    c.Graphics = function(a, b, d) {
        b = b || 0;
        d = d || 0;
        this.game = a;
        this.exists = !0;
        this.name = "";
        this.type = c.GRAPHICS;
        this.z = 0;
        this.world = new c.Point(b, d);
        this.cameraOffset = new c.Point;
        PIXI.Graphics.call(this);
        this.position.set(b, d);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    c.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    c.Graphics.prototype.constructor = c.Graphics;
    c.Graphics.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds()));
        this.world.setTo(this.game.camera.x +
            this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
        return !0
    };
    c.Graphics.prototype.update = function() {};
    c.Graphics.prototype.postUpdate = function() {
        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    };
    c.Graphics.prototype.destroy = function(a) {
        if (!(null === this.game || this.destroyPhase)) {
            "undefined" ===
            typeof a && (a = !0);
            this._cache[8] = 1;
            this.clear();
            this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this));
            var b = this.children.length;
            if (a)
                for (; b--;) this.children[b].destroy(a);
            else
                for (; b--;) this.removeChild(this.children[b]);
            this.visible = this.exists = !1;
            this.game = null;
            this._cache[8] = 0
        }
    };
    c.Graphics.prototype.drawPolygon = function(a) {
        this.moveTo(a.points[0].x, a.points[0].y);
        for (var b = 1; b < a.points.length; b += 1) this.lineTo(a.points[b].x, a.points[b].y);
        this.lineTo(a.points[0].x,
            a.points[0].y)
    };
    c.Graphics.prototype.drawTriangle = function(a, b) {
        "undefined" === typeof b && (b = !1);
        var d = new c.Polygon(a);
        if (b) {
            var e = new c.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y),
                f = new c.Point(a[1].x - a[0].x, a[1].y - a[0].y),
                f = (new c.Point(a[1].x - a[2].x, a[1].y - a[2].y)).cross(f);
            0 < e.dot(f) && this.drawPolygon(d)
        } else this.drawPolygon(d)
    };
    c.Graphics.prototype.drawTriangles = function(a, b, d) {
        "undefined" === typeof d && (d = !1);
        var e = new c.Point,
            f = new c.Point,
            h = new c.Point,
            k = [],
            g;
        if (b)
            if (a[0] instanceof c.Point)
                for (g = 0; g < b.length / 3; g++) k.push(a[b[3 * g]]), k.push(a[b[3 * g + 1]]), k.push(a[b[3 * g + 2]]), 3 === k.length && (this.drawTriangle(k, d), k = []);
            else
                for (g = 0; g < b.length; g++) e.x = a[2 * b[g]], e.y = a[2 * b[g] + 1], k.push(e.copyTo({})), 3 === k.length && (this.drawTriangle(k, d), k = []);
        else if (a[0] instanceof c.Point)
            for (g = 0; g < a.length / 3; g++) this.drawTriangle([a[3 * g], a[3 * g + 1], a[3 * g + 2]], d);
        else
            for (g = 0; g < a.length / 6; g++) e.x = a[6 * g + 0], e.y = a[6 * g + 1], f.x = a[6 * g + 2], f.y = a[6 * g + 3], h.x = a[6 * g + 4], h.y = a[6 * g + 5], this.drawTriangle([e, f, h], d)
    };
    Object.defineProperty(c.Graphics.prototype,
        "angle", {
            get: function() {
                return c.Math.radToDeg(this.rotation)
            },
            set: function(a) {
                this.rotation = c.Math.degToRad(a)
            }
        });
    Object.defineProperty(c.Graphics.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(a) {
            a ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
        }
    });
    Object.defineProperty(c.Graphics.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    c.RenderTexture = function(a, b, d, e, f) {
        "undefined" === typeof e && (e = "");
        "undefined" === typeof f && (f =
            c.scaleModes.DEFAULT);
        this.game = a;
        this.key = e;
        this.type = c.RENDERTEXTURE;
        this._temp = new c.Point;
        PIXI.RenderTexture.call(this, b, d, f)
    };
    c.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    c.RenderTexture.prototype.constructor = c.RenderTexture;
    c.RenderTexture.prototype.renderXY = function(a, b, c, e) {
        this._temp.set(b, c);
        this.render(a, this._temp, e)
    };
    c.SpriteBatch = function(a, b, d, e) {
        PIXI.SpriteBatch.call(this);
        c.Group.call(this, a, b, d, e);
        this.type = c.SPRITEBATCH
    };
    c.SpriteBatch.prototype = c.Utils.extend(!0,
        c.SpriteBatch.prototype, c.Group.prototype, PIXI.SpriteBatch.prototype);
    c.SpriteBatch.prototype.constructor = c.SpriteBatch;
    c.RetroFont = function(a, b, d, e, f, h, k, g, l, m) {
        this.characterWidth = d;
        this.characterHeight = e;
        this.characterSpacingX = k || 0;
        this.characterSpacingY = g || 0;
        this.characterPerRow = h;
        this.offsetX = l || 0;
        this.offsetY = m || 0;
        this.align = "left";
        this.multiLine = !1;
        this.autoUpperCase = !0;
        this.fixedWidth = this.customSpacingY = this.customSpacingX = 0;
        this.fontSet = a.cache.getImage(b);
        this._text = "";
        this.grabData = [];
        d = this.offsetX;
        e = this.offsetY;
        h = 0;
        k = new c.FrameData;
        for (g = 0; g < f.length; g++) l = a.rnd.uuid(), m = k.addFrame(new c.Frame(g, d, e, this.characterWidth, this.characterHeight, "", l)), this.grabData[f.charCodeAt(g)] = m.index, PIXI.TextureCache[l] = new PIXI.Texture(PIXI.BaseTextureCache[b], {
            x: d,
            y: e,
            width: this.characterWidth,
            height: this.characterHeight
        }), h++, h == this.characterPerRow ? (h = 0, d = this.offsetX, e += this.characterHeight + this.characterSpacingY) : d += this.characterWidth + this.characterSpacingX;
        a.cache.updateFrameData(b,
            k);
        this.stamp = new c.Image(a, 0, 0, b, 0);
        c.RenderTexture.call(this, a);
        this.type = c.RETROFONT
    };
    c.RetroFont.prototype = Object.create(c.RenderTexture.prototype);
    c.RetroFont.prototype.constructor = c.RetroFont;
    c.RetroFont.ALIGN_LEFT = "left";
    c.RetroFont.ALIGN_RIGHT = "right";
    c.RetroFont.ALIGN_CENTER = "center";
    c.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    c.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    c.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    c.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    c.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    c.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    c.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    c.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    c.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    c.RetroFont.TEXT_SET10 =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    c.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    c.RetroFont.prototype.setFixedWidth = function(a, b) {
        "undefined" === typeof b && (b = "left");
        this.fixedWidth = a;
        this.align = b
    };
    c.RetroFont.prototype.setText = function(a, b, c, e, f, h) {
        this.multiLine = b || !1;
        this.customSpacingX = c || 0;
        this.customSpacingY = e || 0;
        this.align = f || "left";
        this.autoUpperCase = h ? !1 : !0;
        0 < a.length && (this.text = a)
    };
    c.RetroFont.prototype.buildRetroFontText = function() {
        var a = 0,
            b = 0;
        this.clear();
        if (this.multiLine) {
            var d =
                this._text.split("\n");
            0 < this.fixedWidth ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
            for (var e = 0; e < d.length; e++) {
                switch (this.align) {
                    case c.RetroFont.ALIGN_LEFT:
                        a = 0;
                        break;
                    case c.RetroFont.ALIGN_RIGHT:
                        a = this.width - d[e].length * (this.characterWidth + this.customSpacingX);
                        break;
                    case c.RetroFont.ALIGN_CENTER:
                        a =
                            this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2
                }
                0 > a && (a = 0);
                this.pasteLine(d[e], a, b, this.customSpacingX);
                b += this.characterHeight + this.customSpacingY
            }
        } else {
            0 < this.fixedWidth ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0);
            switch (this.align) {
                case c.RetroFont.ALIGN_LEFT:
                    a = 0;
                    break;
                case c.RetroFont.ALIGN_RIGHT:
                    a = this.width - this._text.length * (this.characterWidth +
                        this.customSpacingX);
                    break;
                case c.RetroFont.ALIGN_CENTER:
                    a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2
            }
            this.textureBuffer.clear();
            this.pasteLine(this._text, a, 0, this.customSpacingX)
        }
    };
    c.RetroFont.prototype.pasteLine = function(a, b, d, e) {
        for (var f = new c.Point, h = 0; h < a.length; h++)
            if (" " == a.charAt(h)) b += this.characterWidth + e;
            else if (0 <= this.grabData[a.charCodeAt(h)] && (this.stamp.frame = this.grabData[a.charCodeAt(h)], f.set(b, d), this.render(this.stamp,
                f, !1), b += this.characterWidth + e, b > this.width)) break
    };
    c.RetroFont.prototype.getLongestLine = function() {
        var a = 0;
        if (0 < this._text.length)
            for (var b = this._text.split("\n"), c = 0; c < b.length; c++) b[c].length > a && (a = b[c].length);
        return a
    };
    c.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
        for (var b = "", c = 0; c < this._text.length; c++) {
            var e = this._text[c],
                f = e.charCodeAt(0);
            if (0 <= this.grabData[f] || !a && "\n" === e) b = b.concat(e)
        }
        return b
    };
    Object.defineProperty(c.RetroFont.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            a = this.autoUpperCase ? a.toUpperCase() : a;
            a !== this._text && (this._text = a, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
        }
    });
    c.Particle = function(a, b, d, e, f) {
        c.Sprite.call(this, a, b, d, e, f);
        this.autoScale = !1;
        this.scaleData = null;
        this._s = 0;
        this.autoAlpha = !1;
        this.alphaData = null;
        this._a = 0
    };
    c.Particle.prototype = Object.create(c.Sprite.prototype);
    c.Particle.prototype.constructor = c.Particle;
    c.Particle.prototype.update = function() {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x,
            this.scaleData[this._s].y) : this.autoScale = !1);
        this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
    };
    c.Particle.prototype.onEmit = function() {};
    c.Particle.prototype.setAlphaData = function(a) {
        this.alphaData = a;
        this._a = a.length - 1;
        this.alpha = this.alphaData[this._a].v;
        this.autoAlpha = !0
    };
    c.Particle.prototype.setScaleData = function(a) {
        this.scaleData = a;
        this._s = a.length - 1;
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        this.autoScale = !0
    };
    c.Particle.prototype.reset =
        function(a, b, c) {
            "undefined" === typeof c && (c = 1);
            this.world.setTo(a, b);
            this.position.x = a;
            this.position.y = b;
            this.renderable = this.visible = this.exists = this.alive = !0;
            this._outOfBoundsFired = !1;
            this.health = c;
            this.body && this.body.reset(a, b, !1, !1);
            this.alpha = this._cache[4] = 1;
            this.scale.set(1);
            this.autoAlpha = this.autoScale = !1;
            return this
        };
    c.Canvas = {
        create: function(a, b, c, e) {
            "undefined" === typeof e && (e = !1);
            a = a || 256;
            b = b || 256;
            e = e ? document.createElement("canvas") : document.createElement(navigator.isCocoonJS ? "screencanvas" :
                "canvas");
            "string" === typeof c && "" !== c && (e.id = c);
            e.width = a;
            e.height = b;
            e.style.display = "block";
            return e
        },
        getOffset: function(a, b) {
            b = b || new c.Point;
            var d = a.getBoundingClientRect(),
                e = a.clientTop || document.body.clientTop || 0,
                f = a.clientLeft || document.body.clientLeft || 0,
                h = 0,
                k = 0;
            "CSS1Compat" === document.compatMode ? (h = window.pageYOffset || document.documentElement.scrollTop || a.scrollTop || 0, k = window.pageXOffset || document.documentElement.scrollLeft || a.scrollLeft || 0) : (h = window.pageYOffset || document.body.scrollTop ||
                a.scrollTop || 0, k = window.pageXOffset || document.body.scrollLeft || a.scrollLeft || 0);
            b.x = d.left + k - f;
            b.y = d.top + h - e;
            return b
        },
        getAspectRatio: function(a) {
            return a.width / a.height
        },
        setBackgroundColor: function(a, b) {
            a.style.backgroundColor = b || "rgb(0,0,0)";
            return a
        },
        setTouchAction: function(a, b) {
            b = b || "none";
            a.style.msTouchAction = b;
            a.style["ms-touch-action"] = b;
            a.style["touch-action"] = b;
            return a
        },
        setUserSelect: function(a, b) {
            b = b || "none";
            a.style["-webkit-touch-callout"] = b;
            a.style["-webkit-user-select"] = b;
            a.style["-khtml-user-select"] =
                b;
            a.style["-moz-user-select"] = b;
            a.style["-ms-user-select"] = b;
            a.style["user-select"] = b;
            a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return a
        },
        addToDOM: function(a, b, c) {
            var e;
            "undefined" === typeof c && (c = !0);
            b && ("string" === typeof b ? e = document.getElementById(b) : "object" === typeof b && 1 === b.nodeType && (e = b));
            e || (e = document.body);
            c && e.style && (e.style.overflow = "hidden");
            e.appendChild(a);
            return a
        },
        setTransform: function(a, b, c, e, f, h, k) {
            a.setTransform(e, h, k, f, b, c);
            return a
        },
        setSmoothingEnabled: function(a,
            b) {
            a.imageSmoothingEnabled = b;
            a.mozImageSmoothingEnabled = b;
            a.oImageSmoothingEnabled = b;
            a.webkitImageSmoothingEnabled = b;
            a.msImageSmoothingEnabled = b;
            return a
        },
        setImageRenderingCrisp: function(a) {
            a.style["image-rendering"] = "optimizeSpeed";
            a.style["image-rendering"] = "crisp-edges";
            a.style["image-rendering"] = "-moz-crisp-edges";
            a.style["image-rendering"] = "-webkit-optimize-contrast";
            a.style["image-rendering"] = "optimize-contrast";
            a.style.msInterpolationMode = "nearest-neighbor";
            return a
        },
        setImageRenderingBicubic: function(a) {
            a.style["image-rendering"] =
                "auto";
            a.style.msInterpolationMode = "bicubic";
            return a
        }
    };
    c.Device = function(a) {
        this.game = a;
        this.ie = this.firefox = this.epiphany = this.chrome = this.arora = this.quirksMode = this.getUserMedia = this.vibration = this.typedArray = this.pointerLock = this.css3D = this.mspointer = this.touch = this.worker = this.webGL = this.localStorage = this.fileSystem = this.file = this.canvas = this.windowsPhone = this.windows = this.macOS = this.linux = this.chromeOS = this.android = this.crosswalk = this.ejecta = this.cocoonJS = this.iOS = this.desktop = !1;
        this.ieVersion =
            0;
        this.trident = !1;
        this.tridentVersion = 0;
        this.iPad = this.iPhone4 = this.iPhone = this.webm = this.m4a = this.wav = this.mp3 = this.opus = this.ogg = this.webAudio = this.audioData = this.silk = this.webApp = this.safari = this.opera = this.midori = this.mobileSafari = !1;
        this.pixelRatio = 0;
        this.fullscreen = this.support32bit = this.littleEndian = !1;
        this.cancelFullscreen = this.requestFullscreen = "";
        this.fullscreenKeyboard = !1;
        this._checkAudio();
        this._checkBrowser();
        this._checkCSS3D();
        this._checkDevice();
        this._checkFeatures();
        this._checkOS()
    };
    c.Device.LITTLE_ENDIAN = !1;
    c.Device.prototype = {
        _checkOS: function() {
            var a = navigator.userAgent;
            /Android/.test(a) ? this.android = !0 : /CrOS/.test(a) ? this.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? this.iOS = !0 : /Linux/.test(a) ? this.linux = !0 : /Mac OS/.test(a) ? this.macOS = !0 : /Windows/.test(a) && (this.windows = !0, /Windows Phone/i.test(a) && (this.windowsPhone = !0));
            if (this.windows || this.macOS || this.linux && !1 === this.silk) this.desktop = !0;
            if (this.windowsPhone || /Windows NT/i.test(a) && /Touch/i.test(a)) this.desktop = !1
        },
        _checkFeatures: function() {
            this.canvas = !!window.CanvasRenderingContext2D || this.cocoonJS;
            try {
                this.localStorage = !!localStorage.getItem
            } catch (a) {
                this.localStorage = !1
            }
            this.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob;
            this.fileSystem = !!window.requestFileSystem;
            var b;
            try {
                var c = document.createElement("canvas");
                b = !!window.WebGLRenderingContext && (c.getContext("webgl") || c.getContext("experimental-webgl"))
            } catch (e) {
                b = !1
            }
            this.webGL = b;
            this.webGL = null === this.webGL || !1 === this.webGL ? !1 : !0;
            this.worker = !!window.Worker;
            if ("ontouchstart" in
                document.documentElement || window.navigator.maxTouchPoints && 1 < window.navigator.maxTouchPoints) this.touch = !0;
            if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) this.mspointer = !0;
            this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            this.quirksMode = "CSS1Compat" === document.compatMode ? !1 : !0;
            this.getUserMedia = !(!navigator.getUserMedia && !navigator.webkitGetUserMedia && !navigator.mozGetUserMedia && !navigator.msGetUserMedia)
        },
        checkFullScreenSupport: function() {
            for (var a = "requestFullscreen requestFullScreen webkitRequestFullscreen webkitRequestFullScreen msRequestFullscreen msRequestFullScreen mozRequestFullScreen mozRequestFullscreen".split(" "), b = 0; b < a.length; b++) this.game.canvas[a[b]] && (this.fullscreen = !0, this.requestFullscreen = a[b]);
            a = "cancelFullScreen exitFullscreen webkitCancelFullScreen webkitExitFullscreen msCancelFullScreen msExitFullscreen mozCancelFullScreen mozExitFullscreen".split(" ");
            if (this.fullscreen)
                for (b =
                    0; b < a.length; b++) this.game.canvas[a[b]] && (this.cancelFullscreen = a[b]);
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (this.fullscreenKeyboard = !0)
        },
        _checkBrowser: function() {
            var a = navigator.userAgent;
            /Arora/.test(a) ? this.arora = !0 : /Chrome/.test(a) ? this.chrome = !0 : /Epiphany/.test(a) ? this.epiphany = !0 : /Firefox/.test(a) ? this.firefox = !0 : /Mobile Safari/.test(a) ? this.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (this.ie = !0, this.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? this.midori = !0 : /Opera/.test(a) ? this.opera = !0 : /Safari/.test(a) ? this.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && (this.trident = this.ie = !0, this.tridentVersion = parseInt(RegExp.$1, 10), this.ieVersion = parseInt(RegExp.$3, 10));
            /Silk/.test(a) && (this.silk = !0);
            navigator.standalone && (this.webApp = !0);
            navigator.isCocoonJS && (this.cocoonJS = !0);
            "undefined" !== typeof window.ejecta && (this.ejecta = !0);
            /Crosswalk/.test(a) && (this.crosswalk = !0)
        },
        _checkAudio: function() {
            this.audioData = !!window.Audio;
            this.webAudio = !(!window.webkitAudioContext && !window.AudioContext);
            var a = document.createElement("audio");
            try {
                if (a.canPlayType) {
                    a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (this.ogg = !0);
                    a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") && (this.opus = !0);
                    a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (this.mp3 = !0);
                    a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (this.wav = !0);
                    if (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) this.m4a = !0;
                    a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,
                        "") && (this.webm = !0)
                }
            } catch (b) {}
        },
        _checkDevice: function() {
            this.pixelRatio = window.devicePixelRatio || 1;
            this.iPhone = -1 != navigator.userAgent.toLowerCase().indexOf("iphone");
            this.iPhone4 = 2 == this.pixelRatio && this.iPhone;
            this.iPad = -1 != navigator.userAgent.toLowerCase().indexOf("ipad");
            this.typedArray = "undefined" !== typeof Int8Array ? !0 : !1;
            "undefined" !== typeof ArrayBuffer && ("undefined" !== typeof Uint8Array && "undefined" !== typeof Uint32Array) && (this.littleEndian = this._checkIsLittleEndian(), c.Device.LITTLE_ENDIAN =
                this.littleEndian);
            this.support32bit = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof Uint8ClampedArray && "undefined" !== typeof Int32Array && null !== this.littleEndian && this._checkIsUint8ClampedImageData();
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            navigator.vibrate && (this.vibration = !0)
        },
        _checkIsLittleEndian: function() {
            var a = new ArrayBuffer(4),
                b = new Uint8Array(a),
                a = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            return 3569595041 ==
                a[0] ? !0 : 2712847316 == a[0] ? !1 : null
        },
        _checkIsUint8ClampedImageData: function() {
            if ("undefined" === typeof Uint8ClampedArray) return !1;
            var a = document.createElement("canvas").getContext("2d");
            return !a ? !1 : a.createImageData(1, 1).data instanceof Uint8ClampedArray
        },
        _checkCSS3D: function() {
            var a = document.createElement("p"),
                b, c = {
                    webkitTransform: "-webkit-transform",
                    OTransform: "-o-transform",
                    msTransform: "-ms-transform",
                    MozTransform: "-moz-transform",
                    transform: "transform"
                };
            document.body.insertBefore(a, null);
            for (var e in c) void 0 !==
                a.style[e] && (a.style[e] = "translate3d(1px,1px,1px)", b = window.getComputedStyle(a).getPropertyValue(c[e]));
            document.body.removeChild(a);
            this.css3D = void 0 !== b && 0 < b.length && "none" !== b
        },
        canPlayAudio: function(a) {
            return "mp3" == a && this.mp3 || "ogg" == a && (this.ogg || this.opus) || "m4a" == a && this.m4a || "wav" == a && this.wav || "webm" == a && this.webm ? !0 : !1
        },
        isConsoleOpen: function() {
            return window.console && window.console.firebug ? !0 : window.console && (console.profile(), console.profileEnd(), console.clear && console.clear(), console.profiles) ?
                0 < console.profiles.length : !1
        }
    };
    c.Device.prototype.constructor = c.Device;
    c.RequestAnimationFrame = function(a, b) {
        "undefined" === typeof b && (b = !1);
        this.game = a;
        this.isRunning = !1;
        this.forceSetTimeOut = b;
        for (var c = ["ms", "moz", "webkit", "o"], e = 0; e < c.length && !window.requestAnimationFrame; e++) window.requestAnimationFrame = window[c[e] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c[e] + "CancelAnimationFrame"];
        this._isSetTimeOut = !1;
        this._timeOutID = this._onLoop = null
    };
    c.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = !0;
            var a = this;
            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                return a.updateSetTimeout()
            }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(b) {
                return a.updateRAF(b)
            }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
        },
        updateRAF: function() {
            this.game.update(Date.now());
            this._timeOutID = window.requestAnimationFrame(this._onLoop)
        },
        updateSetTimeout: function() {
            this.game.update(Date.now());
            this._timeOutID =
                window.setTimeout(this._onLoop, this.game.time.timeToCall)
        },
        stop: function() {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID);
            this.isRunning = !1
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut
        },
        isRAF: function() {
            return !1 === this._isSetTimeOut
        }
    };
    c.RequestAnimationFrame.prototype.constructor = c.RequestAnimationFrame;
    c.Math = {
        PI2: 2 * Math.PI,
        fuzzyEqual: function(a, b, c) {
            "undefined" === typeof c && (c = 1E-4);
            return Math.abs(a - b) < c
        },
        fuzzyLessThan: function(a, b, c) {
            "undefined" ===
            typeof c && (c = 1E-4);
            return a < b + c
        },
        fuzzyGreaterThan: function(a, b, c) {
            "undefined" === typeof c && (c = 1E-4);
            return a > b - c
        },
        fuzzyCeil: function(a, b) {
            "undefined" === typeof b && (b = 1E-4);
            return Math.ceil(a - b)
        },
        fuzzyFloor: function(a, b) {
            "undefined" === typeof b && (b = 1E-4);
            return Math.floor(a + b)
        },
        average: function() {
            for (var a = [], b = 0; b < arguments.length - 0; b++) a[b] = arguments[b + 0];
            for (var c = b = 0; c < a.length; c++) b += a[c];
            return b / a.length
        },
        truncate: function(a) {
            return 0 < a ? Math.floor(a) : Math.ceil(a)
        },
        shear: function(a) {
            return a % 1
        },
        snapTo: function(a, b, c) {
            "undefined" === typeof c && (c = 0);
            if (0 === b) return a;
            a = b * Math.round((a - c) / b);
            return c + a
        },
        snapToFloor: function(a, b, c) {
            "undefined" === typeof c && (c = 0);
            if (0 === b) return a;
            a = b * Math.floor((a - c) / b);
            return c + a
        },
        snapToCeil: function(a, b, c) {
            "undefined" === typeof c && (c = 0);
            if (0 === b) return a;
            a = b * Math.ceil((a - c) / b);
            return c + a
        },
        snapToInArray: function(a, b, c) {
            "undefined" === typeof c && (c = !0);
            c && b.sort();
            if (a < b[0]) return b[0];
            for (var e = 1; b[e] < a;) e++;
            c = b[e - 1];
            b = e < b.length ? b[e] : Number.POSITIVE_INFINITY;
            return b -
                a <= a - c ? b : c
        },
        roundTo: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 10);
            b = Math.pow(c, -b);
            return Math.round(a * b) / b
        },
        floorTo: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 10);
            b = Math.pow(c, -b);
            return Math.floor(a * b) / b
        },
        ceilTo: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 10);
            b = Math.pow(c, -b);
            return Math.ceil(a * b) / b
        },
        interpolateFloat: function(a, b, c) {
            return (b - a) * c + a
        },
        angleBetween: function(a, b, c, e) {
            return Math.atan2(e - b, c - a)
        },
        angleBetweenPoints: function(a, b) {
            return Math.atan2(b.y - a.y, b.x - a.x)
        },
        reverseAngle: function(a) {
            return this.normalizeAngle(a + Math.PI, !0)
        },
        normalizeAngle: function(a) {
            a %= 2 * Math.PI;
            return 0 <= a ? a : a + 2 * Math.PI
        },
        normalizeLatitude: function(a) {
            return Math.max(-90, Math.min(90, a))
        },
        normalizeLongitude: function(a) {
            if (180 == a % 360) return 180;
            a %= 360;
            return -180 > a ? a + 360 : 180 < a ? a - 360 : a
        },
        chanceRoll: function(a) {
            "undefined" === typeof a && (a = 50);
            return 0 >= a ? !1 : 100 <= a ? !0 : 100 * Math.random() >= a ? !1 : !0
        },
        numberArray: function(a, b) {
            for (var c = [], e = a; e <= b; e++) c.push(e);
            return c
        },
        maxAdd: function(a, b, c) {
            a += b;
            a > c && (a = c);
            return a
        },
        minSub: function(a, b, c) {
            a -= b;
            a < c && (a = c);
            return a
        },
        wrap: function(a, b, c) {
            c -= b;
            if (0 >= c) return 0;
            a = (a - b) % c;
            0 > a && (a += c);
            return a + b
        },
        wrapValue: function(a, b, c) {
            a = Math.abs(a);
            b = Math.abs(b);
            c = Math.abs(c);
            return (a + b) % c
        },
        limitValue: function(a, b, c) {
            return a < b ? b : a > c ? c : a
        },
        randomSign: function() {
            return 0.5 < Math.random() ? 1 : -1
        },
        isOdd: function(a) {
            return a & 1
        },
        isEven: function(a) {
            return a & 1 ? !1 : !0
        },
        min: function() {
            for (var a = 1 === arguments.length &&
                    "object" === typeof arguments[0] ? arguments[0] : arguments, b = 1, c = 0, e = a.length; b < e; b++) a[b] < a[c] && (c = b);
            return a[c]
        },
        max: function() {
            for (var a = 1 === arguments.length && "object" === typeof arguments[0] ? arguments[0] : arguments, b = 1, c = 0, e = a.length; b < e; b++) a[b] > a[c] && (c = b);
            return a[c]
        },
        minProperty: function(a) {
            for (var b = 2 === arguments.length && "object" === typeof arguments[1] ? arguments[1] : arguments.slice(1), c = 1, e = 0, f = b.length; c < f; c++) b[c][a] < b[e][a] && (e = c);
            return b[e][a]
        },
        maxProperty: function(a) {
            for (var b = 2 === arguments.length &&
                    "object" === typeof arguments[1] ? arguments[1] : arguments.slice(1), c = 1, e = 0, f = b.length; c < f; c++) b[c][a] > b[e][a] && (e = c);
            return b[e][a]
        },
        wrapAngle: function(a, b) {
            var c = b ? Math.PI / 180 : 1;
            return this.wrap(a, -180 * c, 180 * c)
        },
        angleLimit: function(a, b, c) {
            var e = a;
            a > c ? e = c : a < b && (e = b);
            return e
        },
        linearInterpolation: function(a, b) {
            var c = a.length - 1,
                e = c * b,
                f = Math.floor(e);
            return 0 > b ? this.linear(a[0], a[1], e) : 1 < b ? this.linear(a[c], a[c - 1], c - e) : this.linear(a[f], a[f + 1 > c ? c : f + 1], e - f)
        },
        bezierInterpolation: function(a, b) {
            for (var c = 0, e =
                    a.length - 1, f = 0; f <= e; f++) c += Math.pow(1 - b, e - f) * Math.pow(b, f) * a[f] * this.bernstein(e, f);
            return c
        },
        catmullRomInterpolation: function(a, b) {
            var c = a.length - 1,
                e = c * b,
                f = Math.floor(e);
            return a[0] === a[c] ? (0 > b && (f = Math.floor(e = c * (1 + b))), this.catmullRom(a[(f - 1 + c) % c], a[f], a[(f + 1) % c], a[(f + 2) % c], e - f)) : 0 > b ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -e) - a[0]) : 1 < b ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], e - c) - a[c]) : this.catmullRom(a[f ? f - 1 : 0], a[f], a[c < f + 1 ? c : f + 1], a[c < f + 2 ? c : f + 2], e - f)
        },
        linear: function(a, b, c) {
            return (b -
                a) * c + a
        },
        bernstein: function(a, b) {
            return this.factorial(a) / this.factorial(b) / this.factorial(a - b)
        },
        catmullRom: function(a, b, c, e, f) {
            a = 0.5 * (c - a);
            e = 0.5 * (e - b);
            var h = f * f;
            return (2 * b - 2 * c + a + e) * f * h + (-3 * b + 3 * c - 2 * a - e) * h + a * f + b
        },
        difference: function(a, b) {
            return Math.abs(a - b)
        },
        getRandom: function(a, b, c) {
            "undefined" === typeof b && (b = 0);
            "undefined" === typeof c && (c = 0);
            if (null != a) {
                if (0 === c || c > a.length - b) c = a.length - b;
                if (0 < c) return a[b + Math.floor(Math.random() * c)]
            }
            return null
        },
        removeRandom: function(a, b, c) {
            "undefined" === typeof b &&
                (b = 0);
            "undefined" === typeof c && (c = 0);
            if (null != a) {
                if (0 === c || c > a.length - b) c = a.length - b;
                if (0 < c) return b += Math.floor(Math.random() * c), a.splice(b, 1)[0]
            }
            return null
        },
        floor: function(a) {
            var b = a | 0;
            return 0 < a ? b : b != a ? b - 1 : b
        },
        ceil: function(a) {
            var b = a | 0;
            return 0 < a ? b != a ? b + 1 : b : b
        },
        sinCosGenerator: function(a, b, c, e) {
            "undefined" === typeof b && (b = 1);
            "undefined" === typeof c && (c = 1);
            "undefined" === typeof e && (e = 1);
            e = e * Math.PI / a;
            for (var f = [], h = [], k = 0; k < a; k++) c -= b * e, b += c * e, f[k] = c, h[k] = b;
            return {
                sin: h,
                cos: f,
                length: a
            }
        },
        shift: function(a) {
            var b =
                a.shift();
            a.push(b);
            return b
        },
        shuffleArray: function(a) {
            for (var b = a.length - 1; 0 < b; b--) {
                var c = Math.floor(Math.random() * (b + 1)),
                    e = a[b];
                a[b] = a[c];
                a[c] = e
            }
            return a
        },
        distance: function(a, b, c, e) {
            a -= c;
            b -= e;
            return Math.sqrt(a * a + b * b)
        },
        distancePow: function(a, b, c, e, f) {
            "undefined" === typeof f && (f = 2);
            return Math.sqrt(Math.pow(c - a, f) + Math.pow(e - b, f))
        },
        distanceRounded: function(a, b, d, e) {
            return Math.round(c.Math.distance(a, b, d, e))
        },
        clamp: function(a, b, c) {
            return a < b ? b : a > c ? c : a
        },
        clampBottom: function(a, b) {
            return a < b ? b : a
        },
        within: function(a,
            b, c) {
            return Math.abs(a - b) <= c
        },
        mapLinear: function(a, b, c, e, f) {
            return e + (a - b) * (f - e) / (c - b)
        },
        smoothstep: function(a, b, c) {
            a = Math.max(0, Math.min(1, (a - b) / (c - b)));
            return a * a * (3 - 2 * a)
        },
        smootherstep: function(a, b, c) {
            a = Math.max(0, Math.min(1, (a - b) / (c - b)));
            return a * a * a * (a * (6 * a - 15) + 10)
        },
        sign: function(a) {
            return 0 > a ? -1 : 0 < a ? 1 : 0
        },
        percent: function(a, b, c) {
            "undefined" === typeof c && (c = 0);
            return a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b
        },
        degToRad: function() {
            var a = Math.PI / 180;
            return function(b) {
                return b * a
            }
        }(),
        radToDeg: function() {
            var a = 180 /
                Math.PI;
            return function(b) {
                return b * a
            }
        }()
    };
    c.RandomDataGenerator = function(a) {
        "undefined" === typeof a && (a = []);
        this.c = 1;
        this.s2 = this.s1 = this.s0 = 0;
        this.sow(a)
    };
    c.RandomDataGenerator.prototype = {
        rnd: function() {
            var a = 2091639 * this.s0 + 2.3283064365386963E-10 * this.c;
            this.c = a | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            return this.s2 = a - this.c
        },
        sow: function(a) {
            "undefined" === typeof a && (a = []);
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            for (var b, c = 0; b = a[c++];) this.s0 -= this.hash(b),
                this.s0 += ~~(0 > this.s0), this.s1 -= this.hash(b), this.s1 += ~~(0 > this.s1), this.s2 -= this.hash(b), this.s2 += ~~(0 > this.s2)
        },
        hash: function(a) {
            var b, c, e;
            e = 4022871197;
            a = a.toString();
            for (c = 0; c < a.length; c++) e += a.charCodeAt(c), b = 0.02519603282416938 * e, e = b >>> 0, b -= e, b *= e, e = b >>> 0, b -= e, e += 4294967296 * b;
            return 2.3283064365386963E-10 * (e >>> 0)
        },
        integer: function() {
            return 4294967296 * this.rnd.apply(this)
        },
        frac: function() {
            return this.rnd.apply(this) + 1.1102230246251565E-16 * (2097152 * this.rnd.apply(this) | 0)
        },
        real: function() {
            return this.integer() +
                this.frac()
        },
        integerInRange: function(a, b) {
            return Math.floor(this.realInRange(0, b - a + 1) + a)
        },
        realInRange: function(a, b) {
            return this.frac() * (b - a) + a
        },
        normal: function() {
            return 1 - 2 * this.frac()
        },
        uuid: function() {
            for (var a = "", b = "", b = a = ""; 36 > a++; b += ~a % 5 | 3 * a & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-");
            return b
        },
        pick: function(a) {
            return a[this.integerInRange(0, a.length - 1)]
        },
        weightedPick: function(a) {
            return a[~~(Math.pow(this.frac(), 2) * (a.length - 1))]
        },
        timestamp: function(a, b) {
            return this.realInRange(a ||
                9466848E5, b || 1577862E6)
        },
        angle: function() {
            return this.integerInRange(-180, 180)
        }
    };
    c.RandomDataGenerator.prototype.constructor = c.RandomDataGenerator;
    c.QuadTree = function(a, b, c, e, f, h, k) {
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.level = 0;
        this.bounds = {};
        this.objects = [];
        this.nodes = [];
        this._empty = [];
        this.reset(a, b, c, e, f, h, k)
    };
    c.QuadTree.prototype = {
        reset: function(a, b, c, e, f, h, k) {
            this.maxObjects = f || 10;
            this.maxLevels = h || 4;
            this.level = k || 0;
            this.bounds = {
                x: Math.round(a),
                y: Math.round(b),
                width: c,
                height: e,
                subWidth: Math.floor(c /
                    2),
                subHeight: Math.floor(e / 2),
                right: Math.round(a) + Math.floor(c / 2),
                bottom: Math.round(b) + Math.floor(e / 2)
            };
            this.objects.length = 0;
            this.nodes.length = 0
        },
        populate: function(a) {
            a.forEach(this.populateHandler, this, !0)
        },
        populateHandler: function(a) {
            a.body && a.exists && this.insert(a.body)
        },
        split: function() {
            this.level++;
            this.nodes[0] = new c.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[1] = new c.QuadTree(this.bounds.x, this.bounds.y,
                this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[2] = new c.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[3] = new c.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level)
        },
        insert: function(a) {
            var b = 0,
                c;
            if (null != this.nodes[0] && (c = this.getIndex(a), -1 !== c)) {
                this.nodes[c].insert(a);
                return
            }
            this.objects.push(a);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels)
                for (null == this.nodes[0] && this.split(); b < this.objects.length;) c = this.getIndex(this.objects[b]), -1 !== c ? this.nodes[c].insert(this.objects.splice(b, 1)[0]) : b++
        },
        getIndex: function(a) {
            var b = -1;
            a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3));
            return b
        },
        retrieve: function(a) {
            if (a instanceof c.Rectangle) var b = this.objects,
                d = this.getIndex(a);
            else {
                if (!a.body) return this._empty;
                b = this.objects;
                d = this.getIndex(a.body)
            }
            this.nodes[0] && (-1 !== d ? b = b.concat(this.nodes[d].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), b = b.concat(this.nodes[1].retrieve(a)), b = b.concat(this.nodes[2].retrieve(a)), b = b.concat(this.nodes[3].retrieve(a))));
            return b
        },
        clear: function() {
            this.objects.length = 0;
            for (var a = this.nodes.length; a--;) this.nodes[a].clear(), this.nodes.splice(a,
                1);
            this.nodes.length = 0
        }
    };
    c.QuadTree.prototype.constructor = c.QuadTree;
    c.Net = function(a) {
        this.game = a
    };
    c.Net.prototype = {
        getHostName: function() {
            return window.location && window.location.hostname ? window.location.hostname : null
        },
        checkDomainName: function(a) {
            return -1 !== window.location.hostname.indexOf(a)
        },
        updateQueryString: function(a, b, c, e) {
            "undefined" === typeof c && (c = !1);
            if ("undefined" === typeof e || "" === e) e = window.location.href;
            var f = "",
                f = RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
            if (f.test(e)) f = "undefined" !==
                typeof b && null !== b ? e.replace(f, "$1" + a + "=" + b + "$2$3") : e.replace(f, "$1$3").replace(/(&|\?)$/, "");
            else {
                if ("undefined" !== typeof b && null !== b) {
                    var f = -1 !== e.indexOf("?") ? "&" : "?",
                        h = e.split("#");
                    e = h[0] + f + a + "=" + b;
                    h[1] && (e += "#" + h[1])
                }
                f = e
            }
            if (c) window.location.href = f;
            else return f
        },
        getQueryString: function(a) {
            "undefined" === typeof a && (a = "");
            var b = {},
                c = location.search.substring(1).split("&"),
                e;
            for (e in c) {
                var f = c[e].split("=");
                if (1 < f.length) {
                    if (a && a == this.decodeURI(f[0])) return this.decodeURI(f[1]);
                    b[this.decodeURI(f[0])] =
                        this.decodeURI(f[1])
                }
            }
            return b
        },
        decodeURI: function(a) {
            return decodeURIComponent(a.replace(/\+/g, " "))
        }
    };
    c.Net.prototype.constructor = c.Net;
    c.TweenManager = function(a) {
        this.game = a;
        this._tweens = [];
        this._add = [];
        this.game.onPause.add(this._pauseAll, this);
        this.game.onResume.add(this._resumeAll, this)
    };
    c.TweenManager.prototype = {
        getAll: function() {
            return this._tweens
        },
        removeAll: function() {
            for (var a = 0; a < this._tweens.length; a++) this._tweens[a].pendingDelete = !0;
            this._add = []
        },
        add: function(a) {
            a._manager = this;
            this._add.push(a)
        },
        create: function(a) {
            return new c.Tween(a, this.game, this)
        },
        remove: function(a) {
            a = this._tweens.indexOf(a); - 1 !== a && (this._tweens[a].pendingDelete = !0)
        },
        update: function() {
            if (0 === this._tweens.length && 0 === this._add.length) return !1;
            for (var a = 0, b = this._tweens.length; a < b;) this._tweens[a].update(this.game.time.now) ? a++ : (this._tweens.splice(a, 1), b--);
            0 < this._add.length && (this._tweens = this._tweens.concat(this._add), this._add.length = 0);
            return !0
        },
        isTweening: function(a) {
            return this._tweens.some(function(b) {
                return b._object ===
                    a
            })
        },
        _pauseAll: function() {
            for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a]._pause()
        },
        _resumeAll: function() {
            for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a]._resume()
        },
        pauseAll: function() {
            for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a].pause()
        },
        resumeAll: function() {
            for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a].resume(!0)
        }
    };
    c.TweenManager.prototype.constructor = c.TweenManager;
    c.Tween = function(a, b, d) {
        this._object = a;
        this.game = b;
        this._manager = d;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1E3;
        this._repeat = 0;
        this._reversed = this._yoyo = !1;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = c.Easing.Linear.None;
        this._interpolationFunction = c.Math.linearInterpolation;
        this._chainedTweens = [];
        this._onStartCallbackFired = !1;
        this._onUpdateCallbackContext = this._onUpdateCallback = null;
        this._paused = !1;
        this._pausedTime = 0;
        this.pendingDelete = this._codePaused = !1;
        this.onStart = new c.Signal;
        this.onLoop = new c.Signal;
        this.onComplete = new c.Signal;
        this.isRunning = !1
    };
    c.Tween.prototype = {
        to: function(a, b, c, e, f, h, k) {
            b = b || 1E3;
            c = c || null;
            e = e || !1;
            f = f || 0;
            h = h || 0;
            (k = k || !1) && 0 === h && (h = 1);
            var g;
            this._parent ? (g = this._manager.create(this._object), this._lastChild.chain(g), this._lastChild = g) : (g = this, this._parent = this, this._lastChild = this);
            g._repeat = h;
            g._duration = b;
            g._valuesEnd = a;
            null !== c && (g._easingFunction = c);
            0 < f && (g._delayTime = f);
            g._yoyo = k;
            return e ? this.start() : this
        },
        from: function(a, b, c, e, f, h, k) {
            var g = {},
                l;
            for (l in a) a.hasOwnProperty(l) && (g[l] = this._object[l], this._object[l] =
                a[l]);
            this.to(g, b, c, e, f, h, k)
        },
        start: function() {
            if (!(null === this.game || null === this._object)) {
                this._manager.add(this);
                this.isRunning = !0;
                this._onStartCallbackFired = !1;
                this._startTime = this.game.time.now + this._delayTime;
                for (var a in this._valuesEnd) {
                    if (Array.isArray(this._valuesEnd[a])) {
                        if (0 === this._valuesEnd[a].length) continue;
                        this._valuesEnd[a] = [this._object[a]].concat(this._valuesEnd[a])
                    }
                    this._valuesStart[a] = this._object[a];
                    Array.isArray(this._valuesStart[a]) || (this._valuesStart[a] *= 1);
                    this._valuesStartRepeat[a] =
                        this._valuesStart[a] || 0
                }
                return this
            }
        },
        generateData: function(a, b) {
            if (null === this.game || null === this._object) return null;
            this._startTime = 0;
            for (var c in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[c])) {
                    if (0 === this._valuesEnd[c].length) continue;
                    this._valuesEnd[c] = [this._object[c]].concat(this._valuesEnd[c])
                }
                this._valuesStart[c] = this._object[c];
                Array.isArray(this._valuesStart[c]) || (this._valuesStart[c] *= 1);
                this._valuesStartRepeat[c] = this._valuesStart[c] || 0
            }
            for (var e = 0, f = Math.floor(a * (this._duration /
                    1E3)), h = this._duration / f, k = []; f--;) {
                var g = (e - this._startTime) / this._duration,
                    g = 1 < g ? 1 : g,
                    g = this._easingFunction(g),
                    l = {};
                for (c in this._valuesEnd) {
                    var m = this._valuesStart[c] || 0,
                        n = this._valuesEnd[c];
                    n instanceof Array ? l[c] = this._interpolationFunction(n, g) : ("string" === typeof n && (n = m + parseFloat(n, 10)), "number" === typeof n && (l[c] = m + (n - m) * g))
                }
                k.push(l);
                e += h
            }
            this._yoyo && (c = k.slice(), c.reverse(), k = k.concat(c));
            return "undefined" !== typeof b ? b = b.concat(k) : k
        },
        stop: function() {
            this.isRunning = !1;
            this._onUpdateCallback =
                null;
            this._manager.remove(this);
            return this
        },
        delay: function(a) {
            this._delayTime = a;
            return this
        },
        repeat: function(a) {
            this._repeat = a;
            return this
        },
        yoyo: function(a) {
            if ((this._yoyo = a) && 0 === this._repeat) this._repeat = 1;
            return this
        },
        easing: function(a) {
            this._easingFunction = a;
            return this
        },
        interpolation: function(a) {
            this._interpolationFunction = a;
            return this
        },
        chain: function() {
            this._chainedTweens = arguments;
            return this
        },
        loop: function() {
            this._lastChild.chain(this);
            return this
        },
        onUpdateCallback: function(a, b) {
            this._onUpdateCallback =
                a;
            this._onUpdateCallbackContext = b;
            return this
        },
        pause: function() {
            this._paused = this._codePaused = !0;
            this._pausedTime = this.game.time.now
        },
        _pause: function() {
            this._codePaused || (this._paused = !0, this._pausedTime = this.game.time.now)
        },
        resume: function() {
            this._paused && (this._codePaused = this._paused = !1, this._startTime += this.game.time.now - this._pausedTime)
        },
        _resume: function() {
            this._codePaused || (this._startTime += this.game.time.pauseDuration, this._paused = !1)
        },
        update: function(a) {
            if (this.pendingDelete) return !1;
            if (this._paused ||
                a < this._startTime) return !0;
            var b;
            if (a < this._startTime) return !0;
            !1 === this._onStartCallbackFired && (this.onStart.dispatch(this._object), this._onStartCallbackFired = !0);
            var c = (a - this._startTime) / this._duration,
                c = 1 < c ? 1 : c,
                e = this._easingFunction(c);
            for (b in this._valuesEnd) {
                var f = this._valuesStart[b] || 0,
                    h = this._valuesEnd[b];
                h instanceof Array ? this._object[b] = this._interpolationFunction(h, e) : ("string" === typeof h && (h = f + parseFloat(h, 10)), "number" === typeof h && (this._object[b] = f + (h - f) * e))
            }
            null !== this._onUpdateCallback &&
                this._onUpdateCallback.call(this._onUpdateCallbackContext, this, e);
            if (1 == c)
                if (0 < this._repeat) {
                    isFinite(this._repeat) && this._repeat--;
                    for (b in this._valuesStartRepeat) "string" === typeof this._valuesEnd[b] && (this._valuesStartRepeat[b] += parseFloat(this._valuesEnd[b], 10)), this._yoyo && (c = this._valuesStartRepeat[b], this._valuesStartRepeat[b] = this._valuesEnd[b], this._valuesEnd[b] = c), this._valuesStart[b] = this._valuesStartRepeat[b];
                    this._yoyo && (this._reversed = !this._reversed);
                    this._startTime = a + this._delayTime;
                    this.onLoop.dispatch(this._object)
                } else {
                    this.isRunning = !1;
                    this.onComplete.dispatch(this._object);
                    b = 0;
                    for (c = this._chainedTweens.length; b < c; b++) this._chainedTweens[b].start(a);
                    return !1
                }
            return !0
        }
    };
    c.Tween.prototype.constructor = c.Tween;
    c.Easing = {
        Linear: {
            None: function(a) {
                return a
            }
        },
        Quadratic: {
            In: function(a) {
                return a * a
            },
            Out: function(a) {
                return a * (2 - a)
            },
            InOut: function(a) {
                return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1)
            }
        },
        Cubic: {
            In: function(a) {
                return a * a * a
            },
            Out: function(a) {
                return --a * a * a + 1
            },
            InOut: function(a) {
                return 1 >
                    (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2)
            }
        },
        Quartic: {
            In: function(a) {
                return a * a * a * a
            },
            Out: function(a) {
                return 1 - --a * a * a * a
            },
            InOut: function(a) {
                return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2)
            }
        },
        Quintic: {
            In: function(a) {
                return a * a * a * a * a
            },
            Out: function(a) {
                return --a * a * a * a * a + 1
            },
            InOut: function(a) {
                return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2)
            }
        },
        Sinusoidal: {
            In: function(a) {
                return 1 - Math.cos(a * Math.PI / 2)
            },
            Out: function(a) {
                return Math.sin(a * Math.PI / 2)
            },
            InOut: function(a) {
                return 0.5 * (1 - Math.cos(Math.PI * a))
            }
        },
        Exponential: {
            In: function(a) {
                return 0 ===
                    a ? 0 : Math.pow(1024, a - 1)
            },
            Out: function(a) {
                return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
            }
        },
        Circular: {
            In: function(a) {
                return 1 - Math.sqrt(1 - a * a)
            },
            Out: function(a) {
                return Math.sqrt(1 - --a * a)
            },
            InOut: function(a) {
                return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
            }
        },
        Elastic: {
            In: function(a) {
                var b, c = 0.1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !c || 1 > c ? (c = 1, b = 0.1) : b = 0.4 * Math.asin(1 / c) / (2 * Math.PI);
                return -(c *
                    Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * 2 * Math.PI / 0.4))
            },
            Out: function(a) {
                var b, c = 0.1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !c || 1 > c ? (c = 1, b = 0.1) : b = 0.4 * Math.asin(1 / c) / (2 * Math.PI);
                return c * Math.pow(2, -10 * a) * Math.sin((a - b) * 2 * Math.PI / 0.4) + 1
            },
            InOut: function(a) {
                var b, c = 0.1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !c || 1 > c ? (c = 1, b = 0.1) : b = 0.4 * Math.asin(1 / c) / (2 * Math.PI);
                return 1 > (a *= 2) ? -0.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * 2 * Math.PI / 0.4) : 0.5 * c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * 2 * Math.PI / 0.4) + 1
            }
        },
        Back: {
            In: function(a) {
                return a *
                    a * (2.70158 * a - 1.70158)
            },
            Out: function(a) {
                return --a * a * (2.70158 * a + 1.70158) + 1
            },
            InOut: function(a) {
                return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
            }
        },
        Bounce: {
            In: function(a) {
                return 1 - c.Easing.Bounce.Out(1 - a)
            },
            Out: function(a) {
                return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375
            },
            InOut: function(a) {
                return 0.5 > a ? 0.5 * c.Easing.Bounce.In(2 * a) : 0.5 * c.Easing.Bounce.Out(2 * a - 1) + 0.5
            }
        }
    };
    c.Time =
        function(a) {
            this.game = a;
            this.pausedTime = this.elapsed = this.now = this.time = 0;
            this.advancedTiming = !1;
            this.fps = 0;
            this.fpsMin = 1E3;
            this.fpsMax = 0;
            this.msMin = 1E3;
            this.deltaCap = this.physicsElapsed = this.msMax = 0;
            this.timeCap = 1E3;
            this.lastTime = this.timeToCall = this.pauseDuration = this.frames = 0;
            this.events = new c.Timer(this.game, !1);
            this._pauseStarted = this._timeLastSecond = this._started = 0;
            this._justResumed = !1;
            this._timers = [];
            this._i = this._len = 0
        };
    c.Time.prototype = {
        boot: function() {
            this._started = Date.now();
            this.events.start()
        },
        create: function(a) {
            "undefined" === typeof a && (a = !0);
            a = new c.Timer(this.game, a);
            this._timers.push(a);
            return a
        },
        removeAll: function() {
            for (var a = 0; a < this._timers.length; a++) this._timers[a].destroy();
            this._timers = [];
            this.events.removeAll()
        },
        update: function(a) {
            this.now = a;
            this.timeToCall = this.game.math.max(0, 16 - (a - this.lastTime));
            this.elapsed = this.now - this.time;
            this.elapsed > this.timeCap && (this.elapsed = 1 / 60);
            this.physicsElapsed = this.elapsed / 1E3 || 1 / 60;
            0 < this.deltaCap && this.physicsElapsed > this.deltaCap && (this.physicsElapsed =
                this.deltaCap);
            this.advancedTiming && (this.msMin = this.game.math.min(this.msMin, this.elapsed), this.msMax = this.game.math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1E3 && (this.fps = Math.round(1E3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = this.game.math.min(this.fpsMin, this.fps), this.fpsMax = this.game.math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0));
            this.time = this.now;
            this.lastTime = a + this.timeToCall;
            if (!this.game.paused) {
                this.events.update(this.now);
                this._i = 0;
                for (this._len = this._timers.length; this._i < this._len;) this._timers[this._i].update(this.now) ? this._i++ : (this._timers.splice(this._i, 1), this._len--)
            }
        },
        gamePaused: function() {
            this._pauseStarted = this.now;
            this.events.pause();
            for (var a = this._timers.length; a--;) this._timers[a]._pause()
        },
        gameResumed: function() {
            this.time = this.now = Date.now();
            this.pauseDuration = this.time - this._pauseStarted;
            this.events.resume();
            for (var a = this._timers.length; a--;) this._timers[a]._resume()
        },
        totalElapsedSeconds: function() {
            return 0.001 *
                (this.now - this._started)
        },
        elapsedSince: function(a) {
            return this.now - a
        },
        elapsedSecondsSince: function(a) {
            return 0.001 * (this.now - a)
        },
        reset: function() {
            this._started = this.now;
            this.removeAll()
        }
    };
    c.Time.prototype.constructor = c.Time;
    c.Timer = function(a, b) {
        "undefined" === typeof b && (b = !0);
        this.game = a;
        this.running = !1;
        this.autoDestroy = b;
        this.expired = !1;
        this.elapsed = 0;
        this.events = [];
        this.onComplete = new c.Signal;
        this.nextTick = 0;
        this.timeCap = 1E3;
        this._codePaused = this.paused = !1;
        this._pauseTotal = this._pauseStarted = this._started =
            0;
        this._now = Date.now();
        this._newTick = this._diff = this._i = this._marked = this._len = 0
    };
    c.Timer.MINUTE = 6E4;
    c.Timer.SECOND = 1E3;
    c.Timer.HALF = 500;
    c.Timer.QUARTER = 250;
    c.Timer.prototype = {
        create: function(a, b, d, e, f, h) {
            var k = a,
                k = 0 === this._now ? k + this.game.time.now : k + this._now;
            a = new c.TimerEvent(this, a, k, d, b, e, f, h);
            this.events.push(a);
            this.order();
            this.expired = !1;
            return a
        },
        add: function(a, b, c) {
            return this.create(a, !1, 0, b, c, Array.prototype.splice.call(arguments, 3))
        },
        repeat: function(a, b, c, e) {
            return this.create(a, !1,
                b, c, e, Array.prototype.splice.call(arguments, 4))
        },
        loop: function(a, b, c) {
            return this.create(a, !0, 0, b, c, Array.prototype.splice.call(arguments, 3))
        },
        start: function(a) {
            if (!this.running) {
                this._started = this.game.time.now + (a || 0);
                this.running = !0;
                for (a = 0; a < this.events.length; a++) this.events[a].tick = this.events[a].delay + this._started
            }
        },
        stop: function(a) {
            this.running = !1;
            "undefined" === typeof a && (a = !0);
            a && (this.events.length = 0)
        },
        remove: function(a) {
            for (var b = 0; b < this.events.length; b++)
                if (this.events[b] === a) return this.events[b].pendingDelete = !0;
            return !1
        },
        order: function() {
            0 < this.events.length && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
        },
        sortHandler: function(a, b) {
            return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0
        },
        clearPendingEvents: function() {
            for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length;
            this._i = 0
        },
        update: function(a) {
            if (this.paused) return !0;
            this.elapsed = a - this._now;
            this._now = a;
            this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed);
            this._marked = 0;
            this.clearPendingEvents();
            if (this.running && this._now >= this.nextTick && 0 < this._len) {
                for (; this._i < this._len && this.running;)
                    if (this._now >= this.events[this._i].tick) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), 0 > this._newTick && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? this.events[this._i].tick = this._newTick : 0 < this.events[this._i].repeatCount ? (this.events[this._i].repeatCount--, this.events[this._i].tick =
                        this._newTick) : (this._marked++, this.events[this._i].pendingDelete = !0), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args), this._i++;
                    else break;
                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
            }
            return this.expired && this.autoDestroy ? !1 : !0
        },
        pause: function() {
            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.now, this.paused = !0))
        },
        _pause: function() {
            !this.paused && this.running && (this._pauseStarted =
                this.game.time.now, this.paused = !0)
        },
        adjustEvents: function(a) {
            for (var b = 0; b < this.events.length; b++)
                if (!this.events[b].pendingDelete) {
                    var c = this.events[b].tick - a;
                    0 > c && (c = 0);
                    this.events[b].tick = this._now + c
                }
            a = this.nextTick - a;
            this.nextTick = 0 > a ? this._now : this._now + a
        },
        resume: function() {
            if (this.paused) {
                var a = this.game.time.now;
                this._pauseTotal += a - this._now;
                this._now = a;
                this.adjustEvents(this._pauseStarted);
                this._codePaused = this.paused = !1
            }
        },
        _resume: function() {
            this._codePaused || this.resume()
        },
        removeAll: function() {
            this.onComplete.removeAll();
            this._i = this._len = this.events.length = 0
        },
        destroy: function() {
            this.onComplete.removeAll();
            this.running = !1;
            this.events = [];
            this._i = this._len = 0
        }
    };
    Object.defineProperty(c.Timer.prototype, "next", {
        get: function() {
            return this.nextTick
        }
    });
    Object.defineProperty(c.Timer.prototype, "duration", {
        get: function() {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
        }
    });
    Object.defineProperty(c.Timer.prototype, "length", {
        get: function() {
            return this.events.length
        }
    });
    Object.defineProperty(c.Timer.prototype,
        "ms", {
            get: function() {
                return this._now - this._started - this._pauseTotal
            }
        });
    Object.defineProperty(c.Timer.prototype, "seconds", {
        get: function() {
            return 0.001 * this.ms
        }
    });
    c.Timer.prototype.constructor = c.Timer;
    c.TimerEvent = function(a, b, c, e, f, h, k, g) {
        this.timer = a;
        this.delay = b;
        this.tick = c;
        this.repeatCount = e - 1;
        this.loop = f;
        this.callback = h;
        this.callbackContext = k;
        this.args = g;
        this.pendingDelete = !1
    };
    c.TimerEvent.prototype.constructor = c.TimerEvent;
    c.AnimationManager = function(a) {
        this.sprite = a;
        this.game = a.game;
        this.currentAnim =
            this.currentFrame = null;
        this.updateIfVisible = !0;
        this.isLoaded = !1;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = []
    };
    c.AnimationManager.prototype = {
        loadFrameData: function(a) {
            this._frameData = a;
            this.frame = 0;
            this.isLoaded = !0
        },
        add: function(a, b, d, e, f) {
            if (null === this._frameData) console.warn("No FrameData available for Phaser.Animation " + a);
            else return b = b || [], d = d || 60, "undefined" === typeof e && (e = !1), "undefined" === typeof f && (f = b && "number" === typeof b[0] ? !0 : !1), null === this.sprite.events.onAnimationStart &&
                (this.sprite.events.onAnimationStart = new c.Signal, this.sprite.events.onAnimationComplete = new c.Signal, this.sprite.events.onAnimationLoop = new c.Signal), this._outputFrames.length = 0, this._frameData.getFrameIndexes(b, f, this._outputFrames), this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e), this.currentAnim = this._anims[a], this.currentFrame = this.currentAnim.currentFrame, this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this.sprite.__tilePattern &&
                (this.tilingTexture = this.__tilePattern = !1), this._anims[a]
        },
        validateFrames: function(a, b) {
            "undefined" == typeof b && (b = !0);
            for (var c = 0; c < a.length; c++)
                if (!0 === b) {
                    if (a[c] > this._frameData.total) return !1
                } else if (!1 === this._frameData.checkFrameName(a[c])) return !1;
            return !0
        },
        play: function(a, b, c, e) {
            if (this._anims[a])
                if (this.currentAnim === this._anims[a]) {
                    if (!1 === this.currentAnim.isPlaying) return this.currentAnim.paused = !1, this.currentAnim.play(b, c, e)
                } else return this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(),
                    this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentAnim.play(b, c, e)
        },
        stop: function(a, b) {
            "undefined" == typeof b && (b = !1);
            "string" == typeof a ? this._anims[a] && (this.currentAnim = this._anims[a], this.currentAnim.stop(b)) : this.currentAnim && this.currentAnim.stop(b)
        },
        update: function() {
            return this.updateIfVisible && !this.sprite.visible ? !1 : this.currentAnim && !0 === this.currentAnim.update() ? (this.currentFrame = this.currentAnim.currentFrame, !0) : !1
        },
        getAnimation: function(a) {
            return "string" === typeof a &&
                this._anims[a] ? this._anims[a] : null
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            this.sprite.__tilePattern && (this.tilingTexture = this.__tilePattern = !1)
        },
        destroy: function() {
            var a = null;
            for (a in this._anims) this._anims.hasOwnProperty(a) && this._anims[a].destroy();
            this._anims = {};
            this._frameData = null;
            this._frameIndex = 0;
            this.currentFrame = this.currentAnim = null
        }
    };
    c.AnimationManager.prototype.constructor = c.AnimationManager;
    Object.defineProperty(c.AnimationManager.prototype,
        "frameData", {
            get: function() {
                return this._frameData
            }
        });
    Object.defineProperty(c.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData ? this._frameData.total : -1
        }
    });
    Object.defineProperty(c.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused
        },
        set: function(a) {
            this.currentAnim.paused = a
        }
    });
    Object.defineProperty(c.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) return this._frameIndex
        },
        set: function(a) {
            if ("number" === typeof a &&
                (this._frameData && null !== this._frameData.getFrame(a)) && (this.currentFrame = this._frameData.getFrame(a))) this._frameIndex = a, this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this.sprite.__tilePattern && (this.tilingTexture = this.__tilePattern = !1)
        }
    });
    Object.defineProperty(c.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) return this.currentFrame.name
        },
        set: function(a) {
            if ("string" === typeof a && this._frameData && null !== this._frameData.getFrameByName(a)) {
                if (this.currentFrame =
                    this._frameData.getFrameByName(a)) this._frameIndex = this.currentFrame.index, this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this.sprite.__tilePattern && (this.tilingTexture = this.__tilePattern = !1)
            } else console.warn("Cannot set frameName: " + a)
        }
    });
    c.Animation = function(a, b, d, e, f, h, k) {
        this.game = a;
        this._parent = b;
        this._frameData = e;
        this.name = d;
        this._frames = [];
        this._frames = this._frames.concat(f);
        this.delay = 1E3 / h;
        this.loop = k;
        this.loopCount = 0;
        this.isPaused = this.isPlaying = this.isFinished = this.killOnComplete = !1;
        this._frameDiff = this._frameIndex = this._pauseStartTime = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.onStart = new c.Signal;
        this.onComplete = new c.Signal;
        this.onLoop = new c.Signal;
        this.game.onPause.add(this.onPause, this);
        this.game.onResume.add(this.onResume, this)
    };
    c.Animation.prototype = {
        play: function(a, b, c) {
            "number" === typeof a && (this.delay = 1E3 / a);
            "boolean" === typeof b && (this.loop = b);
            "undefined" !== typeof c && (this.killOnComplete = c);
            this.isPlaying = !0;
            this.paused = this.isFinished = !1;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1);
            this._parent.events.onAnimationStart.dispatch(this._parent, this);
            this.onStart.dispatch(this._parent, this);
            return this
        },
        restart: function() {
            this.isPlaying = !0;
            this.paused = this.isFinished = !1;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this.onStart.dispatch(this._parent, this)
        },
        setFrame: function(a, b) {
            var c;
            "undefined" === typeof b && (b = !1);
            if ("string" === typeof a)
                for (var e = 0; e < this._frames.length; e++) this._frameData.getFrame(this._frames[e]).name === a && (c = e);
            else if ("number" ===
                typeof a)
                if (b) c = a;
                else
                    for (e = 0; e < this._frames.length; e++) this.frames[e] === c && (c = e);
            c && (this._frameIndex = c - 1, this._timeNextFrame = this.game.time.now, this.update())
        },
        stop: function(a, b) {
            "undefined" === typeof a && (a = !1);
            "undefined" === typeof b && (b = !1);
            this.isPlaying = !1;
            this.isFinished = !0;
            this.paused = !1;
            a && (this.currentFrame = this._frameData.getFrame(this._frames[0]));
            b && (this._parent.events.onAnimationComplete.dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
        },
        onPause: function() {
            this.isPlaying &&
                (this._frameDiff = this._timeNextFrame - this.game.time.now)
        },
        onResume: function() {
            this.isPlaying && (this._timeNextFrame = this.game.time.now + this._frameDiff)
        },
        update: function() {
            if (this.isPaused) return !1;
            if (!0 === this.isPlaying && this.game.time.now >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.now - this._timeNextFrame;
                this._timeLastFrame = this.game.time.now;
                this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay);
                this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length)
                    if (this.loop) {
                        this._frameIndex %= this._frames.length;
                        if (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])) this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1);
                        this.loopCount++;
                        this._parent.events.onAnimationLoop.dispatch(this._parent,
                            this);
                        this.onLoop.dispatch(this._parent, this)
                    } else this.complete();
                else if (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])) this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1);
                return !0
            }
            return !1
        },
        destroy: function() {
            this.game.onPause.remove(this.onPause, this);
            this.game.onResume.remove(this.onResume, this);
            this.currentFrame = this._frameData = this._frames = this._parent = this.game =
                null;
            this.isPlaying = !1;
            this.onStart.dispose();
            this.onLoop.dispose();
            this.onComplete.dispose()
        },
        complete: function() {
            this.isPlaying = !1;
            this.isFinished = !0;
            this.paused = !1;
            this._parent.events.onAnimationComplete.dispatch(this._parent, this);
            this.onComplete.dispatch(this._parent, this);
            this.killOnComplete && this._parent.kill()
        }
    };
    c.Animation.prototype.constructor = c.Animation;
    Object.defineProperty(c.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused
        },
        set: function(a) {
            (this.isPaused = a) ? this._pauseStartTime =
                this.game.time.now: this.isPlaying && (this._timeNextFrame = this.game.time.now + this.delay)
        }
    });
    Object.defineProperty(c.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length
        }
    });
    Object.defineProperty(c.Animation.prototype, "frame", {
        get: function() {
            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
        },
        set: function(a) {
            this.currentFrame = this._frameData.getFrame(this._frames[a]);
            null !== this.currentFrame && (this._frameIndex = a, this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]))
        }
    });
    Object.defineProperty(c.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1E3 / this.delay)
        },
        set: function(a) {
            1 <= a && (this.delay = 1E3 / a)
        }
    });
    c.Animation.generateFrameNames = function(a, b, d, e, f) {
        "undefined" == typeof e && (e = "");
        var h = [],
            k = "";
        if (b < d)
            for (; b <= d; b++) k = "number" == typeof f ? c.Utils.pad(b.toString(), f, "0", 1) : b.toString(), k = a + k + e, h.push(k);
        else
            for (; b >= d; b--) k = "number" == typeof f ? c.Utils.pad(b.toString(), f, "0", 1) : b.toString(), k = a + k + e, h.push(k);
        return h
    };
    c.Frame = function(a, b, d, e, f, h, k) {
        this.index =
            a;
        this.x = b;
        this.y = d;
        this.width = e;
        this.height = f;
        this.name = h;
        this.uuid = k;
        this.centerX = Math.floor(e / 2);
        this.centerY = Math.floor(f / 2);
        this.distance = c.Math.distance(0, 0, e, f);
        this.rotated = !1;
        this.rotationDirection = "cw";
        this.trimmed = !1;
        this.sourceSizeW = e;
        this.sourceSizeH = f;
        this.spriteSourceSizeH = this.spriteSourceSizeW = this.spriteSourceSizeY = this.spriteSourceSizeX = 0
    };
    c.Frame.prototype = {
        setTrim: function(a, b, c, e, f, h, k) {
            if (this.trimmed = a) this.width = b, this.height = c, this.sourceSizeW = b, this.sourceSizeH = c, this.centerX =
                Math.floor(b / 2), this.centerY = Math.floor(c / 2), this.spriteSourceSizeX = e, this.spriteSourceSizeY = f, this.spriteSourceSizeW = h, this.spriteSourceSizeH = k
        },
        getRect: function(a) {
            "undefined" === typeof a ? a = new c.Rectangle(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height);
            return a
        }
    };
    c.Frame.prototype.constructor = c.Frame;
    c.FrameData = function() {
        this._frames = [];
        this._frameNames = []
    };
    c.FrameData.prototype = {
        addFrame: function(a) {
            a.index = this._frames.length;
            this._frames.push(a);
            "" !== a.name &&
                (this._frameNames[a.name] = a.index);
            return a
        },
        getFrame: function(a) {
            a > this._frames.length && (a = 0);
            return this._frames[a]
        },
        getFrameByName: function(a) {
            return "number" === typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null
        },
        checkFrameName: function(a) {
            return null == this._frameNames[a] ? !1 : !0
        },
        getFrameRange: function(a, b, c) {
            for ("undefined" === typeof c && (c = []); a <= b; a++) c.push(this._frames[a]);
            return c
        },
        getFrames: function(a, b, c) {
            "undefined" === typeof b && (b = !0);
            "undefined" === typeof c && (c = []);
            if ("undefined" ===
                typeof a || 0 === a.length)
                for (var e = 0; e < this._frames.length; e++) c.push(this._frames[e]);
            else
                for (var e = 0, f = a.length; e < f; e++) b ? c.push(this.getFrame(a[e])) : c.push(this.getFrameByName(a[e]));
            return c
        },
        getFrameIndexes: function(a, b, c) {
            "undefined" === typeof b && (b = !0);
            "undefined" === typeof c && (c = []);
            if ("undefined" === typeof a || 0 === a.length)
                for (var e = 0, f = this._frames.length; e < f; e++) c.push(this._frames[e].index);
            else {
                e = 0;
                for (f = a.length; e < f; e++) b ? c.push(a[e]) : this.getFrameByName(a[e]) && c.push(this.getFrameByName(a[e]).index)
            }
            return c
        }
    };
    c.FrameData.prototype.constructor = c.FrameData;
    Object.defineProperty(c.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length
        }
    });
    c.AnimationParser = {
        spriteSheet: function(a, b, d, e, f, h, k) {
            var g = a.cache.getImage(b);
            if (null == g) return null;
            var l = g.width,
                m = g.height;
            0 >= d && (d = Math.floor(-l / Math.min(-1, d)));
            0 >= e && (e = Math.floor(-m / Math.min(-1, e)));
            g = Math.floor((l - h) / (d + k)) * Math.floor((m - h) / (e + k)); - 1 !== f && (g = f);
            if (0 === l || 0 === m || l < d || m < e || 0 === g) return console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight"),
                null;
            f = new c.FrameData;
            for (var n = m = h, q = 0; q < g; q++) {
                var s = a.rnd.uuid();
                f.addFrame(new c.Frame(q, m, n, d, e, "", s));
                PIXI.TextureCache[s] = new PIXI.Texture(PIXI.BaseTextureCache[b], {
                    x: m,
                    y: n,
                    width: d,
                    height: e
                });
                m += d + k;
                m + d > l && (m = h, n += e + k)
            }
            return f
        },
        JSONData: function(a, b, d) {
            if (b.frames) {
                var e = new c.FrameData;
                b = b.frames;
                for (var f, h = 0; h < b.length; h++) {
                    var k = a.rnd.uuid();
                    f = e.addFrame(new c.Frame(h, b[h].frame.x, b[h].frame.y, b[h].frame.w, b[h].frame.h, b[h].filename, k));
                    PIXI.TextureCache[k] = new PIXI.Texture(PIXI.BaseTextureCache[d], {
                        x: b[h].frame.x,
                        y: b[h].frame.y,
                        width: b[h].frame.w,
                        height: b[h].frame.h
                    });
                    b[h].trimmed && (f.setTrim(b[h].trimmed, b[h].sourceSize.w, b[h].sourceSize.h, b[h].spriteSourceSize.x, b[h].spriteSourceSize.y, b[h].spriteSourceSize.w, b[h].spriteSourceSize.h), PIXI.TextureCache[k].trim = new c.Rectangle(b[h].spriteSourceSize.x, b[h].spriteSourceSize.y, b[h].sourceSize.w, b[h].sourceSize.h))
                }
                return e
            }
            console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
            console.log(b)
        },
        JSONDataHash: function(a, b, d) {
            if (b.frames) {
                var e = new c.FrameData;
                b = b.frames;
                var f, h = 0,
                    k;
                for (k in b) {
                    var g = a.rnd.uuid();
                    f = e.addFrame(new c.Frame(h, b[k].frame.x, b[k].frame.y, b[k].frame.w, b[k].frame.h, k, g));
                    PIXI.TextureCache[g] = new PIXI.Texture(PIXI.BaseTextureCache[d], {
                        x: b[k].frame.x,
                        y: b[k].frame.y,
                        width: b[k].frame.w,
                        height: b[k].frame.h
                    });
                    b[k].trimmed && (f.setTrim(b[k].trimmed, b[k].sourceSize.w, b[k].sourceSize.h, b[k].spriteSourceSize.x, b[k].spriteSourceSize.y, b[k].spriteSourceSize.w, b[k].spriteSourceSize.h),
                        PIXI.TextureCache[g].trim = new c.Rectangle(b[k].spriteSourceSize.x, b[k].spriteSourceSize.y, b[k].sourceSize.w, b[k].sourceSize.h));
                    h++
                }
                return e
            }
            console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
            console.log(b)
        },
        XMLData: function(a, b, d) {
            if (b.getElementsByTagName("TextureAtlas")) {
                var e = new c.FrameData;
                b = b.getElementsByTagName("SubTexture");
                for (var f, h, k, g, l, m, n, q, s, v, t, u = 0; u < b.length; u++)
                    if (h = a.rnd.uuid(), k = b[u].attributes, f = k.name.nodeValue, g =
                        parseInt(k.x.nodeValue, 10), l = parseInt(k.y.nodeValue, 10), m = parseInt(k.width.nodeValue, 10), n = parseInt(k.height.nodeValue, 10), s = q = null, k.frameX && (q = Math.abs(parseInt(k.frameX.nodeValue, 10)), s = Math.abs(parseInt(k.frameY.nodeValue, 10)), v = parseInt(k.frameWidth.nodeValue, 10), t = parseInt(k.frameHeight.nodeValue, 10)), f = e.addFrame(new c.Frame(u, g, l, m, n, f, h)), PIXI.TextureCache[h] = new PIXI.Texture(PIXI.BaseTextureCache[d], {
                            x: g,
                            y: l,
                            width: m,
                            height: n
                        }), null !== q || null !== s) f.setTrim(!0, m, n, q, s, v, t), PIXI.TextureCache[h].trim =
                        new c.Rectangle(q, s, m, n);
                return e
            }
            console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
        }
    };
    c.Cache = function(a) {
        this.game = a;
        this._canvases = {};
        this._images = {};
        this._textures = {};
        this._sounds = {};
        this._text = {};
        this._json = {};
        this._physics = {};
        this._tilemaps = {};
        this._binary = {};
        this._bitmapDatas = {};
        this._bitmapFont = {};
        this.addDefaultImage();
        this.addMissingImage();
        this.onSoundUnlock = new c.Signal;
        this._cacheMap = [];
        this._cacheMap[c.Cache.CANVAS] = this._canvases;
        this._cacheMap[c.Cache.IMAGE] = this._images;
        this._cacheMap[c.Cache.TEXTURE] = this._textures;
        this._cacheMap[c.Cache.SOUND] = this._sounds;
        this._cacheMap[c.Cache.TEXT] = this._text;
        this._cacheMap[c.Cache.PHYSICS] = this._physics;
        this._cacheMap[c.Cache.TILEMAP] = this._tilemaps;
        this._cacheMap[c.Cache.BINARY] = this._binary;
        this._cacheMap[c.Cache.BITMAPDATA] = this._bitmapDatas;
        this._cacheMap[c.Cache.BITMAPFONT] = this._bitmapFont;
        this._cacheMap[c.Cache.JSON] = this._json
    };
    c.Cache.CANVAS = 1;
    c.Cache.IMAGE = 2;
    c.Cache.TEXTURE =
        3;
    c.Cache.SOUND = 4;
    c.Cache.TEXT = 5;
    c.Cache.PHYSICS = 6;
    c.Cache.TILEMAP = 7;
    c.Cache.BINARY = 8;
    c.Cache.BITMAPDATA = 9;
    c.Cache.BITMAPFONT = 10;
    c.Cache.JSON = 11;
    c.Cache.prototype = {
        addCanvas: function(a, b, c) {
            this._canvases[a] = {
                canvas: b,
                context: c
            }
        },
        addBinary: function(a, b) {
            this._binary[a] = b
        },
        addBitmapData: function(a, b) {
            return this._bitmapDatas[a] = b
        },
        addRenderTexture: function(a, b) {
            var d = new c.Frame(0, 0, 0, b.width, b.height, "", "");
            this._textures[a] = {
                texture: b,
                frame: d
            }
        },
        addSpriteSheet: function(a, b, d, e, f, h, k, g) {
            this._images[a] = {
                url: b,
                data: d,
                spriteSheet: !0,
                frameWidth: e,
                frameHeight: f,
                margin: k,
                spacing: g
            };
            PIXI.BaseTextureCache[a] = new PIXI.BaseTexture(d);
            PIXI.TextureCache[a] = new PIXI.Texture(PIXI.BaseTextureCache[a]);
            this._images[a].frameData = c.AnimationParser.spriteSheet(this.game, a, e, f, h, k, g)
        },
        addTilemap: function(a, b, c, e) {
            this._tilemaps[a] = {
                url: b,
                data: c,
                format: e
            }
        },
        addTextureAtlas: function(a, b, d, e, f) {
            this._images[a] = {
                url: b,
                data: d,
                spriteSheet: !0
            };
            PIXI.BaseTextureCache[a] = new PIXI.BaseTexture(d);
            PIXI.TextureCache[a] = new PIXI.Texture(PIXI.BaseTextureCache[a]);
            f == c.Loader.TEXTURE_ATLAS_JSON_ARRAY ? this._images[a].frameData = c.AnimationParser.JSONData(this.game, e, a) : f == c.Loader.TEXTURE_ATLAS_JSON_HASH ? this._images[a].frameData = c.AnimationParser.JSONDataHash(this.game, e, a) : f == c.Loader.TEXTURE_ATLAS_XML_STARLING && (this._images[a].frameData = c.AnimationParser.XMLData(this.game, e, a))
        },
        addBitmapFont: function(a, b, d, e, f, h) {
            this._images[a] = {
                url: b,
                data: d,
                spriteSheet: !0
            };
            PIXI.BaseTextureCache[a] = new PIXI.BaseTexture(d);
            PIXI.TextureCache[a] = new PIXI.Texture(PIXI.BaseTextureCache[a]);
            c.LoaderParser.bitmapFont(this.game, e, a, f, h)
        },
        addPhysicsData: function(a, b, c, e) {
            this._physics[a] = {
                url: b,
                data: c,
                format: e
            }
        },
        addDefaultImage: function() {
            var a = new Image;
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            this._images.__default = {
                url: null,
                data: a,
                spriteSheet: !1
            };
            this._images.__default.frame = new c.Frame(0, 0, 0, 32, 32, "", "");
            PIXI.BaseTextureCache.__default = new PIXI.BaseTexture(a);
            PIXI.TextureCache.__default = new PIXI.Texture(PIXI.BaseTextureCache.__default)
        },
        addMissingImage: function() {
            var a = new Image;
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            this._images.__missing = {
                url: null,
                data: a,
                spriteSheet: !1
            };
            this._images.__missing.frame = new c.Frame(0, 0, 0, 32, 32, "", "");
            PIXI.BaseTextureCache.__missing = new PIXI.BaseTexture(a);
            PIXI.TextureCache.__missing = new PIXI.Texture(PIXI.BaseTextureCache.__missing)
        },
        addText: function(a, b, c) {
            this._text[a] = {
                url: b,
                data: c
            }
        },
        addJSON: function(a, b, c) {
            this._json[a] = {
                url: b,
                data: c
            }
        },
        addImage: function(a, b, d) {
            this._images[a] = {
                url: b,
                data: d,
                spriteSheet: !1
            };
            this._images[a].frame = new c.Frame(0, 0, 0, d.width, d.height, a, this.game.rnd.uuid());
            PIXI.BaseTextureCache[a] =
                new PIXI.BaseTexture(d);
            PIXI.TextureCache[a] = new PIXI.Texture(PIXI.BaseTextureCache[a])
        },
        addSound: function(a, b, c, e, f) {
            f = f || !1;
            var h = !1;
            f && (h = !0);
            this._sounds[a] = {
                url: b,
                data: c,
                isDecoding: !1,
                decoded: h,
                webAudio: e || !0,
                audioTag: f,
                locked: this.game.sound.touchLocked
            }
        },
        reloadSound: function(a) {
            var b = this;
            this._sounds[a] && (this._sounds[a].data.src = this._sounds[a].url, this._sounds[a].data.addEventListener("canplaythrough", function() {
                return b.reloadSoundComplete(a)
            }, !1), this._sounds[a].data.load())
        },
        reloadSoundComplete: function(a) {
            this._sounds[a] &&
                (this._sounds[a].locked = !1, this.onSoundUnlock.dispatch(a))
        },
        updateSound: function(a, b, c) {
            this._sounds[a] && (this._sounds[a][b] = c)
        },
        decodedSound: function(a, b) {
            this._sounds[a].data = b;
            this._sounds[a].decoded = !0;
            this._sounds[a].isDecoding = !1
        },
        getCanvas: function(a) {
            if (this._canvases[a]) return this._canvases[a].canvas;
            console.warn('Phaser.Cache.getCanvas: Invalid key: "' + a + '"')
        },
        getBitmapData: function(a) {
            if (this._bitmapDatas[a]) return this._bitmapDatas[a];
            console.warn('Phaser.Cache.getBitmapData: Invalid key: "' +
                a + '"')
        },
        getBitmapFont: function(a) {
            if (this._bitmapFont[a]) return this._bitmapFont[a];
            console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + a + '"')
        },
        getPhysicsData: function(a, b, c) {
            if ("undefined" === typeof b || null === b) {
                if (this._physics[a]) return this._physics[a].data;
                console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + a + '"')
            } else if (this._physics[a] && this._physics[a].data[b])
                if ((b = this._physics[a].data[b]) && c) {
                    for (var e in b)
                        if (e = b[e], e.fixtureKey === c) return e;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' +
                        c + " in " + a + '"')
                } else return b;
            else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + a + " / " + b + '"');
            return null
        },
        checkKey: function(a, b) {
            return this._cacheMap[a][b] ? !0 : !1
        },
        checkCanvasKey: function(a) {
            return this.checkKey(c.Cache.CANVAS, a)
        },
        checkImageKey: function(a) {
            return this.checkKey(c.Cache.IMAGE, a)
        },
        checkTextureKey: function(a) {
            return this.checkKey(c.Cache.TEXTURE, a)
        },
        checkSoundKey: function(a) {
            return this.checkKey(c.Cache.SOUND, a)
        },
        checkTextKey: function(a) {
            return this.checkKey(c.Cache.TEXT,
                a)
        },
        checkPhysicsKey: function(a) {
            return this.checkKey(c.Cache.PHYSICS, a)
        },
        checkTilemapKey: function(a) {
            return this.checkKey(c.Cache.TILEMAP, a)
        },
        checkBinaryKey: function(a) {
            return this.checkKey(c.Cache.BINARY, a)
        },
        checkBitmapDataKey: function(a) {
            return this.checkKey(c.Cache.BITMAPDATA, a)
        },
        checkBitmapFontKey: function(a) {
            return this.checkKey(c.Cache.BITMAPFONT, a)
        },
        checkJSONKey: function(a) {
            return this.checkKey(c.Cache.JSON, a)
        },
        getImage: function(a) {
            if (this._images[a]) return this._images[a].data;
            console.warn('Phaser.Cache.getImage: Invalid key: "' +
                a + '"')
        },
        getTilemapData: function(a) {
            if (this._tilemaps[a]) return this._tilemaps[a];
            console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + a + '"')
        },
        getFrameData: function(a) {
            return this._images[a] && this._images[a].frameData ? this._images[a].frameData : null
        },
        updateFrameData: function(a, b) {
            this._images[a] && (this._images[a].spriteSheet = !0, this._images[a].frameData = b)
        },
        getFrameByIndex: function(a, b) {
            return this._images[a] && this._images[a].frameData ? this._images[a].frameData.getFrame(b) : null
        },
        getFrameByName: function(a,
            b) {
            return this._images[a] && this._images[a].frameData ? this._images[a].frameData.getFrameByName(b) : null
        },
        getFrame: function(a) {
            return this._images[a] && !1 === this._images[a].spriteSheet ? this._images[a].frame : null
        },
        getTextureFrame: function(a) {
            return this._textures[a] ? this._textures[a].frame : null
        },
        getTexture: function(a) {
            if (this._textures[a]) return this._textures[a];
            console.warn('Phaser.Cache.getTexture: Invalid key: "' + a + '"')
        },
        getSound: function(a) {
            if (this._sounds[a]) return this._sounds[a];
            console.warn('Phaser.Cache.getSound: Invalid key: "' +
                a + '"')
        },
        getSoundData: function(a) {
            if (this._sounds[a]) return this._sounds[a].data;
            console.warn('Phaser.Cache.getSoundData: Invalid key: "' + a + '"')
        },
        isSoundDecoded: function(a) {
            if (this._sounds[a]) return this._sounds[a].decoded
        },
        isSoundReady: function(a) {
            return this._sounds[a] && this._sounds[a].decoded && !1 === this.game.sound.touchLocked
        },
        isSpriteSheet: function(a) {
            return this._images[a] ? this._images[a].spriteSheet : !1
        },
        getText: function(a) {
            if (this._text[a]) return this._text[a].data;
            console.warn('Phaser.Cache.getText: Invalid key: "' +
                a + '"')
        },
        getJSON: function(a) {
            if (this._json[a]) return this._json[a].data;
            console.warn('Phaser.Cache.getJSON: Invalid key: "' + a + '"')
        },
        getBinary: function(a) {
            if (this._binary[a]) return this._binary[a];
            console.warn('Phaser.Cache.getBinary: Invalid key: "' + a + '"')
        },
        getKeys: function(a) {
            var b = null;
            switch (a) {
                case c.Cache.CANVAS:
                    b = this._canvases;
                    break;
                case c.Cache.IMAGE:
                    b = this._images;
                    break;
                case c.Cache.TEXTURE:
                    b = this._textures;
                    break;
                case c.Cache.SOUND:
                    b = this._sounds;
                    break;
                case c.Cache.TEXT:
                    b = this._text;
                    break;
                case c.Cache.PHYSICS:
                    b = this._physics;
                    break;
                case c.Cache.TILEMAP:
                    b = this._tilemaps;
                    break;
                case c.Cache.BINARY:
                    b = this._binary;
                    break;
                case c.Cache.BITMAPDATA:
                    b = this._bitmapDatas;
                    break;
                case c.Cache.BITMAPFONT:
                    b = this._bitmapFont;
                    break;
                case c.Cache.JSON:
                    b = this._json
            }
            if (b) {
                a = [];
                for (var d in b) "__default" !== d && "__missing" !== d && a.push(d);
                return a
            }
        },
        removeCanvas: function(a) {
            delete this._canvases[a]
        },
        removeImage: function(a) {
            delete this._images[a]
        },
        removeSound: function(a) {
            delete this._sounds[a]
        },
        removeText: function(a) {
            delete this._text[a]
        },
        removeJSON: function(a) {
            delete this._json[a]
        },
        removePhysics: function(a) {
            delete this._physics[a]
        },
        removeTilemap: function(a) {
            delete this._tilemaps[a]
        },
        removeBinary: function(a) {
            delete this._binary[a]
        },
        removeBitmapData: function(a) {
            delete this._bitmapDatas[a]
        },
        removeBitmapFont: function(a) {
            delete this._bitmapFont[a]
        },
        destroy: function() {
            for (var a in this._canvases) delete this._canvases[a];
            for (a in this._images) "__default" !== a && "__missing" !== a && delete this._images[a];
            for (a in this._sounds) delete this._sounds[a];
            for (a in this._text) delete this._text[a];
            for (a in this._json) delete this._json[a];
            for (a in this._textures) delete this._textures[a];
            for (a in this._physics) delete this._physics[a];
            for (a in this._tilemaps) delete this._tilemaps[a];
            for (a in this._binary) delete this._binary[a];
            for (a in this._bitmapDatas) delete this._bitmapDatas[a];
            for (a in this._bitmapFont) delete this._bitmapFont[a]
        }
    };
    c.Cache.prototype.constructor = c.Cache;
    c.Loader = function(a) {
        this.game = a;
        this._fileList = [];
        this._progressChunk = this._fileIndex =
            0;
        this._xhr = new XMLHttpRequest;
        this._ajax = null;
        this.hasLoaded = this.isLoading = !1;
        this.progressFloat = this.progress = 0;
        this.preloadSprite = null;
        this.crossOrigin = !1;
        this.baseURL = "";
        this.onLoadStart = new c.Signal;
        this.onFileStart = new c.Signal;
        this.onFileComplete = new c.Signal;
        this.onFileError = new c.Signal;
        this.onLoadComplete = new c.Signal
    };
    c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    c.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    c.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    c.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    c.Loader.PHYSICS_PHASER_JSON =
        4;
    c.Loader.prototype = {
        setPreloadSprite: function(a, b) {
            b = b || 0;
            this.preloadSprite = {
                sprite: a,
                direction: b,
                width: a.width,
                height: a.height,
                rect: null
            };
            this.preloadSprite.rect = 0 === b ? new c.Rectangle(0, 0, 1, a.height) : new c.Rectangle(0, 0, a.width, 1);
            a.crop(this.preloadSprite.rect);
            a.visible = !0
        },
        checkKeyExists: function(a, b) {
            if (0 < this._fileList.length)
                for (var c = 0; c < this._fileList.length; c++)
                    if (this._fileList[c].type === a && this._fileList[c].key === b) return !0;
            return !1
        },
        getAssetIndex: function(a, b) {
            if (0 < this._fileList.length)
                for (var c =
                        0; c < this._fileList.length; c++)
                    if (this._fileList[c].type === a && this._fileList[c].key === b) return c;
            return -1
        },
        getAsset: function(a, b) {
            if (0 < this._fileList.length)
                for (var c = 0; c < this._fileList.length; c++)
                    if (this._fileList[c].type === a && this._fileList[c].key === b) return {
                        index: c,
                        file: this._fileList[c]
                    };
            return !1
        },
        reset: function() {
            this.preloadSprite = null;
            this.isLoading = !1;
            this._fileIndex = this._fileList.length = 0
        },
        addToFileList: function(a, b, c, e) {
            c = {
                type: a,
                key: b,
                url: c,
                data: null,
                error: !1,
                loaded: !1
            };
            if ("undefined" !==
                typeof e)
                for (var f in e) c[f] = e[f];
            !1 === this.checkKeyExists(a, b) && this._fileList.push(c)
        },
        replaceInFileList: function(a, b, c, e) {
            c = {
                type: a,
                key: b,
                url: c,
                data: null,
                error: !1,
                loaded: !1
            };
            if ("undefined" !== typeof e)
                for (var f in e) c[f] = e[f];
            a = this.getAssetIndex(a, b); - 1 === a ? this._fileList.push(c) : this._fileList[a] = c
        },
        image: function(a, b, c) {
            "undefined" === typeof c && (c = !1);
            c ? this.replaceInFileList("image", a, b) : this.addToFileList("image", a, b);
            return this
        },
        text: function(a, b, c) {
            "undefined" === typeof c && (c = !1);
            c ? this.replaceInFileList("text",
                a, b) : this.addToFileList("text", a, b);
            return this
        },
        json: function(a, b, c) {
            "undefined" === typeof c && (c = !1);
            c ? this.replaceInFileList("json", a, b) : this.addToFileList("json", a, b);
            return this
        },
        script: function(a, b, c, e) {
            "undefined" === typeof c && (c = !1);
            !1 !== c && "undefined" === typeof e && (e = c);
            this.addToFileList("script", a, b, {
                callback: c,
                callbackContext: e
            });
            return this
        },
        binary: function(a, b, c, e) {
            "undefined" === typeof c && (c = !1);
            !1 !== c && "undefined" === typeof e && (e = c);
            this.addToFileList("binary", a, b, {
                callback: c,
                callbackContext: e
            });
            return this
        },
        spritesheet: function(a, b, c, e, f, h, k) {
            "undefined" === typeof f && (f = -1);
            "undefined" === typeof h && (h = 0);
            "undefined" === typeof k && (k = 0);
            this.addToFileList("spritesheet", a, b, {
                frameWidth: c,
                frameHeight: e,
                frameMax: f,
                margin: h,
                spacing: k
            });
            return this
        },
        audio: function(a, b, c) {
            "undefined" === typeof c && (c = !0);
            this.addToFileList("audio", a, b, {
                buffer: null,
                autoDecode: c
            });
            return this
        },
        tilemap: function(a, b, d, e) {
            "undefined" === typeof b && (b = null);
            "undefined" === typeof d && (d = null);
            "undefined" === typeof e && (e = c.Tilemap.CSV);
            if (null == b && null == d) return console.warn("Phaser.Loader.tilemap - Both mapDataURL and mapData are null. One must be set."), this;
            if (d) {
                switch (e) {
                    case c.Tilemap.TILED_JSON:
                        "string" === typeof d && (d = JSON.parse(d))
                }
                this.game.cache.addTilemap(a, null, d, e)
            } else this.addToFileList("tilemap", a, b, {
                format: e
            });
            return this
        },
        physics: function(a, b, d, e) {
            "undefined" === typeof b && (b = null);
            "undefined" === typeof d && (d = null);
            "undefined" === typeof e && (e = c.Physics.LIME_CORONA_JSON);
            if (null == b && null == d) return console.warn("Phaser.Loader.physics - Both dataURL and jsonData are null. One must be set."),
                this;
            d ? ("string" === typeof d && (d = JSON.parse(d)), this.game.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, {
                format: e
            });
            return this
        },
        bitmapFont: function(a, b, c, e, f, h) {
            "undefined" === typeof c && (c = null);
            "undefined" === typeof e && (e = null);
            "undefined" === typeof f && (f = 0);
            "undefined" === typeof h && (h = 0);
            if (c) this.addToFileList("bitmapfont", a, b, {
                xmlURL: c,
                xSpacing: f,
                ySpacing: h
            });
            else if ("string" === typeof e) {
                var k;
                try {
                    window.DOMParser ? k = (new DOMParser).parseFromString(e, "text/xml") : (k = new ActiveXObject("Microsoft.XMLDOM"),
                        k.async = "false", k.loadXML(e))
                } catch (g) {
                    k = void 0
                }
                if (!k || !k.documentElement || k.getElementsByTagName("parsererror").length) throw Error("Phaser.Loader. Invalid Bitmap Font XML given");
                this.addToFileList("bitmapfont", a, b, {
                    xmlURL: null,
                    xmlData: k,
                    xSpacing: f,
                    ySpacing: h
                })
            }
            return this
        },
        atlasJSONArray: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        },
        atlasJSONHash: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH)
        },
        atlasXML: function(a, b, d, e) {
            return this.atlas(a,
                b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING)
        },
        atlas: function(a, b, d, e, f) {
            "undefined" === typeof d && (d = null);
            "undefined" === typeof e && (e = null);
            "undefined" === typeof f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY);
            if (d) this.addToFileList("textureatlas", a, b, {
                atlasURL: d,
                format: f
            });
            else {
                switch (f) {
                    case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                        "string" === typeof e && (e = JSON.parse(e));
                        break;
                    case c.Loader.TEXTURE_ATLAS_XML_STARLING:
                        if ("string" === typeof e) {
                            var h;
                            try {
                                window.DOMParser ? h = (new DOMParser).parseFromString(e, "text/xml") :
                                    (h = new ActiveXObject("Microsoft.XMLDOM"), h.async = "false", h.loadXML(e))
                            } catch (k) {
                                h = void 0
                            }
                            if (!h || !h.documentElement || h.getElementsByTagName("parsererror").length) throw Error("Phaser.Loader. Invalid Texture Atlas XML given");
                            e = h
                        }
                }
                this.addToFileList("textureatlas", a, b, {
                    atlasURL: null,
                    atlasData: e,
                    format: f
                })
            }
            return this
        },
        removeFile: function(a, b) {
            var c = this.getAsset(a, b);
            !1 !== c && this._fileList.splice(c.index, 1)
        },
        removeAll: function() {
            this._fileList.length = 0
        },
        start: function() {
            this.isLoading || (this.progressFloat =
                this.progress = 0, this.hasLoaded = !1, this.isLoading = !0, this.onLoadStart.dispatch(this._fileList.length), 0 < this._fileList.length ? (this._fileIndex = 0, this._progressChunk = 100 / this._fileList.length, this.loadFile()) : (this.progressFloat = this.progress = 100, this.hasLoaded = !0, this.onLoadComplete.dispatch()))
        },
        loadFile: function() {
            if (this._fileList[this._fileIndex]) {
                var a = this._fileList[this._fileIndex],
                    b = this;
                this.onFileStart.dispatch(this.progress, a.key);
                switch (a.type) {
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        a.data =
                            new Image;
                        a.data.name = a.key;
                        a.data.onload = function() {
                            return b.fileComplete(b._fileIndex)
                        };
                        a.data.onerror = function() {
                            return b.fileError(b._fileIndex)
                        };
                        this.crossOrigin && (a.data.crossOrigin = this.crossOrigin);
                        a.data.src = this.baseURL + a.url;
                        break;
                    case "audio":
                        a.url = this.getAudioURL(a.url);
                        null !== a.url ? this.game.sound.usingWebAudio ? (this._xhr.open("GET", this.baseURL + a.url, !0), this._xhr.responseType = "arraybuffer", this._xhr.onload = function() {
                                return b.fileComplete(b._fileIndex)
                            }, this._xhr.onerror = function() {
                                return b.fileError(b._fileIndex)
                            },
                            this._xhr.send()) : this.game.sound.usingAudioTag && (this.game.sound.touchLocked ? (a.data = new Audio, a.data.name = a.key, a.data.preload = "auto", a.data.src = this.baseURL + a.url, this.fileComplete(this._fileIndex)) : (a.data = new Audio, a.data.name = a.key, a.data.onerror = function() {
                            return b.fileError(b._fileIndex)
                        }, a.data.preload = "auto", a.data.src = this.baseURL + a.url, a.data.addEventListener("canplaythrough", c.GAMES[this.game.id].load.fileComplete(this._fileIndex), !1), a.data.load())) : this.fileError(this._fileIndex);
                        break;
                    case "json":
                        window.XDomainRequest ? (this._ajax = new window.XDomainRequest, this._ajax.timeout = 3E3, this._ajax.onerror = function() {
                            return b.dataLoadError(b._fileIndex)
                        }, this._ajax.ontimeout = function() {
                            return b.dataLoadError(b._fileIndex)
                        }, this._ajax.onprogress = function() {}, this._ajax.onload = function() {
                            return b.jsonLoadComplete(b._fileIndex)
                        }, this._ajax.open("GET", this.baseURL + a.url, !0), this._ajax.send()) : (this._xhr.open("GET", this.baseURL + a.url, !0), this._xhr.responseType = "text", this._xhr.onload = function() {
                                return b.jsonLoadComplete(b._fileIndex)
                            },
                            this._xhr.onerror = function() {
                                return b.dataLoadError(b._fileIndex)
                            }, this._xhr.send());
                        break;
                    case "tilemap":
                        this._xhr.open("GET", this.baseURL + a.url, !0);
                        this._xhr.responseType = "text";
                        if (a.format === c.Tilemap.TILED_JSON) this._xhr.onload = function() {
                            return b.jsonLoadComplete(b._fileIndex)
                        };
                        else if (a.format === c.Tilemap.CSV) this._xhr.onload = function() {
                            return b.csvLoadComplete(b._fileIndex)
                        };
                        else throw Error("Phaser.Loader. Invalid Tilemap format: " + a.format);
                        this._xhr.onerror = function() {
                            return b.dataLoadError(b._fileIndex)
                        };
                        this._xhr.send();
                        break;
                    case "text":
                    case "script":
                    case "physics":
                        this._xhr.open("GET", this.baseURL + a.url, !0);
                        this._xhr.responseType = "text";
                        this._xhr.onload = function() {
                            return b.fileComplete(b._fileIndex)
                        };
                        this._xhr.onerror = function() {
                            return b.fileError(b._fileIndex)
                        };
                        this._xhr.send();
                        break;
                    case "binary":
                        this._xhr.open("GET", this.baseURL + a.url, !0), this._xhr.responseType = "arraybuffer", this._xhr.onload = function() {
                                return b.fileComplete(b._fileIndex)
                            }, this._xhr.onerror = function() {
                                return b.fileError(b._fileIndex)
                            },
                            this._xhr.send()
                }
            } else console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex)
        },
        getAudioURL: function(a) {
            var b;
            "string" === typeof a && (a = [a]);
            for (var c = 0; c < a.length; c++)
                if (b = a[c].toLowerCase(), b = b.substr((Math.max(0, b.lastIndexOf(".")) || Infinity) + 1), this.game.device.canPlayAudio(b)) return a[c];
            return null
        },
        fileError: function(a) {
            this._fileList[a].loaded = !0;
            this._fileList[a].error = !0;
            this.onFileError.dispatch(this._fileList[a].key, this._fileList[a]);
            console.warn("Phaser.Loader error loading file: " +
                this._fileList[a].key + " from URL " + this._fileList[a].url);
            this.nextFile(a, !1)
        },
        fileComplete: function(a) {
            if (this._fileList[a]) {
                var b = this._fileList[a],
                    d = b.loaded = !0,
                    e = this;
                switch (b.type) {
                    case "image":
                        this.game.cache.addImage(b.key, b.url, b.data);
                        break;
                    case "spritesheet":
                        this.game.cache.addSpriteSheet(b.key, b.url, b.data, b.frameWidth, b.frameHeight, b.frameMax, b.margin, b.spacing);
                        break;
                    case "textureatlas":
                        if (null == b.atlasURL) this.game.cache.addTextureAtlas(b.key, b.url, b.data, b.atlasData, b.format);
                        else {
                            d = !1;
                            this._xhr.open("GET", this.baseURL + b.atlasURL, !0);
                            this._xhr.responseType = "text";
                            if (b.format == c.Loader.TEXTURE_ATLAS_JSON_ARRAY || b.format == c.Loader.TEXTURE_ATLAS_JSON_HASH) this._xhr.onload = function() {
                                return e.jsonLoadComplete(a)
                            };
                            else if (b.format == c.Loader.TEXTURE_ATLAS_XML_STARLING) this._xhr.onload = function() {
                                return e.xmlLoadComplete(a)
                            };
                            else throw Error("Phaser.Loader. Invalid Texture Atlas format: " + b.format);
                            this._xhr.onerror = function() {
                                return e.dataLoadError(a)
                            };
                            this._xhr.send()
                        }
                        break;
                    case "bitmapfont":
                        null ==
                            b.xmlURL ? this.game.cache.addBitmapFont(b.key, b.url, b.data, b.xmlData, b.xSpacing, b.ySpacing) : (d = !1, this._xhr.open("GET", this.baseURL + b.xmlURL, !0), this._xhr.responseType = "text", this._xhr.onload = function() {
                                return e.xmlLoadComplete(a)
                            }, this._xhr.onerror = function() {
                                return e.dataLoadError(a)
                            }, this._xhr.send());
                        break;
                    case "audio":
                        if (this.game.sound.usingWebAudio) {
                            if (b.data = this._xhr.response, this.game.cache.addSound(b.key, b.url, b.data, !0, !1), b.autoDecode) {
                                var f = this,
                                    h = b.key;
                                this.game.cache.updateSound(h,
                                    "isDecoding", !0);
                                this.game.sound.context.decodeAudioData(b.data, function(a) {
                                    a && (f.game.cache.decodedSound(h, a), f.game.sound.onSoundDecode.dispatch(h, f.game.cache.getSound(h)))
                                })
                            }
                        } else b.data.removeEventListener("canplaythrough", c.GAMES[this.game.id].load.fileComplete), this.game.cache.addSound(b.key, b.url, b.data, !1, !0);
                        break;
                    case "text":
                        b.data = this._xhr.responseText;
                        this.game.cache.addText(b.key, b.url, b.data);
                        break;
                    case "physics":
                        var k = JSON.parse(this._xhr.responseText);
                        this.game.cache.addPhysicsData(b.key,
                            b.url, k, b.format);
                        break;
                    case "script":
                        b.data = document.createElement("script");
                        b.data.language = "javascript";
                        b.data.type = "text/javascript";
                        b.data.defer = !1;
                        b.data.text = this._xhr.responseText;
                        document.head.appendChild(b.data);
                        b.callback && (b.data = b.callback.call(b.callbackContext, b.key, this._xhr.responseText));
                        break;
                    case "binary":
                        b.data = b.callback ? b.callback.call(b.callbackContext, b.key, this._xhr.response) : this._xhr.response, this.game.cache.addBinary(b.key, b.data)
                }
                d && this.nextFile(a, !0)
            } else console.warn("Phaser.Loader fileComplete invalid index " +
                a)
        },
        jsonLoadComplete: function(a) {
            if (this._fileList[a]) {
                var b = this._fileList[a],
                    c = JSON.parse(this._xhr.responseText);
                b.loaded = !0;
                "tilemap" === b.type ? this.game.cache.addTilemap(b.key, b.url, c, b.format) : "json" === b.type ? this.game.cache.addJSON(b.key, b.url, c) : this.game.cache.addTextureAtlas(b.key, b.url, b.data, c, b.format);
                this.nextFile(a, !0)
            } else console.warn("Phaser.Loader jsonLoadComplete invalid index " + a)
        },
        csvLoadComplete: function(a) {
            if (this._fileList[a]) {
                var b = this._fileList[a],
                    c = this._xhr.responseText;
                b.loaded = !0;
                this.game.cache.addTilemap(b.key, b.url, c, b.format);
                this.nextFile(a, !0)
            } else console.warn("Phaser.Loader csvLoadComplete invalid index " + a)
        },
        dataLoadError: function(a) {
            var b = this._fileList[a];
            b.loaded = !0;
            b.error = !0;
            console.warn("Phaser.Loader dataLoadError: " + b.key);
            this.nextFile(a, !0)
        },
        xmlLoadComplete: function(a) {
            var b = this._xhr.responseText,
                c;
            try {
                window.DOMParser ? c = (new DOMParser).parseFromString(b, "text/xml") : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b))
            } catch (e) {
                c =
                    void 0
            }
            if (!c || !c.documentElement || c.getElementsByTagName("parsererror").length) throw Error("Phaser.Loader. Invalid XML given");
            b = this._fileList[a];
            b.loaded = !0;
            "bitmapfont" == b.type ? this.game.cache.addBitmapFont(b.key, b.url, b.data, c, b.xSpacing, b.ySpacing) : "textureatlas" == b.type && this.game.cache.addTextureAtlas(b.key, b.url, b.data, c, b.format);
            this.nextFile(a, !0)
        },
        nextFile: function(a, b) {
            this.progressFloat += this._progressChunk;
            this.progress = Math.round(this.progressFloat);
            100 < this.progress && (this.progress =
                100);
            null !== this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite.crop(this.preloadSprite.rect));
            this.onFileComplete.dispatch(this.progress, this._fileList[a].key, b, this.totalLoadedFiles(), this._fileList.length);
            0 < this.totalQueuedFiles() ? (this._fileIndex++, this.loadFile()) : (this.hasLoaded = !0, this.isLoading = !1, this.removeAll(), this.onLoadComplete.dispatch())
        },
        totalLoadedFiles: function() {
            for (var a = 0, b = 0; b < this._fileList.length; b++) this._fileList[b].loaded && a++;
            return a
        },
        totalQueuedFiles: function() {
            for (var a = 0, b = 0; b < this._fileList.length; b++) !1 === this._fileList[b].loaded && a++;
            return a
        }
    };
    c.Loader.prototype.constructor = c.Loader;
    c.LoaderParser = {
        bitmapFont: function(a, b, c, e, f) {
            a = {};
            var h = b.getElementsByTagName("info")[0],
                k = b.getElementsByTagName("common")[0];
            a.font = h.getAttribute("face");
            a.size = parseInt(h.getAttribute("size"),
                10);
            a.lineHeight = parseInt(k.getAttribute("lineHeight"), 10) + f;
            a.chars = {};
            h = b.getElementsByTagName("char");
            k = PIXI.TextureCache[c];
            for (f = 0; f < h.length; f++) {
                var g = parseInt(h[f].getAttribute("id"), 10),
                    l = new PIXI.Rectangle(parseInt(h[f].getAttribute("x"), 10), parseInt(h[f].getAttribute("y"), 10), parseInt(h[f].getAttribute("width"), 10), parseInt(h[f].getAttribute("height"), 10));
                a.chars[g] = {
                    xOffset: parseInt(h[f].getAttribute("xoffset"), 10),
                    yOffset: parseInt(h[f].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(h[f].getAttribute("xadvance"),
                        10) + e,
                    kerning: {},
                    texture: PIXI.TextureCache[c] = new PIXI.Texture(k, l)
                }
            }
            b = b.getElementsByTagName("kerning");
            for (f = 0; f < b.length; f++) e = parseInt(b[f].getAttribute("first"), 10), h = parseInt(b[f].getAttribute("second"), 10), k = parseInt(b[f].getAttribute("amount"), 10), a.chars[h].kerning[e] = k;
            PIXI.BitmapText.fonts[c] = a
        }
    };
    c.Sound = function(a, b, d, e, f) {
        "undefined" == typeof d && (d = 1);
        "undefined" == typeof e && (e = !1);
        "undefined" === typeof f && (f = a.sound.connectToMaster);
        this.game = a;
        this.key = this.name = b;
        this.loop = e;
        this.volume =
            d;
        this.markers = {};
        this.context = null;
        this.autoplay = !1;
        this.stopTime = this.position = this.durationMS = this.duration = this.currentTime = this.startTime = this.totalDuration = 0;
        this.paused = !1;
        this.pausedTime = this.pausedPosition = 0;
        this.isPlaying = !1;
        this.currentMarker = "";
        this.override = this.pendingPlayback = !1;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        this.gainNode = this.masterGainNode = this.externalNode = null;
        this.usingWebAudio ? (this.context = this.game.sound.context,
            this.masterGainNode = this.game.sound.masterGain, this.gainNode = "undefined" === typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked,
            this);
        this.onDecoded = new c.Signal;
        this.onPlay = new c.Signal;
        this.onPause = new c.Signal;
        this.onResume = new c.Signal;
        this.onLoop = new c.Signal;
        this.onStop = new c.Signal;
        this.onMute = new c.Signal;
        this.onMarkerComplete = new c.Signal;
        this._volume = d;
        this._buffer = null;
        this._muted = !1;
        this._tempLoop = this._tempVolume = this._tempPosition = this._tempMarker = 0;
        this._paused = !1
    };
    c.Sound.prototype = {
        soundHasUnlocked: function(a) {
            a == this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
        },
        addMarker: function(a, b, c, e, f) {
            "undefined" == typeof e && (e = 1);
            "undefined" == typeof f && (f = !1);
            this.markers[a] = {
                name: a,
                start: b,
                stop: b + c,
                volume: e,
                duration: c,
                durationMS: 1E3 * c,
                loop: f
            }
        },
        removeMarker: function(a) {
            delete this.markers[a]
        },
        update: function() {
            this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop));
            this.isPlaying && (this.currentTime = this.game.time.now - this.startTime, this.currentTime >= this.durationMS &&
                (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.now) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : this.stop() : this.loop ? (this.onLoop.dispatch(this), this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
        },
        play: function(a, b, c, e, f) {
            "undefined" === typeof a && (a = "");
            "undefined" === typeof f && (f = !0);
            if (!0 === this.isPlaying && !1 === f && !1 === this.override) return this;
            this.isPlaying && this.override && (this.usingWebAudio ? "undefined" === typeof this._sound.stop ? this._sound.noteOff(0) : this._sound.stop(0) : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0));
            this.currentMarker = a;
            if ("" !== a)
                if (this.markers[a]) this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, "undefined" !== typeof c && (this.volume = c), "undefined" !== typeof e && (this.loop =
                    e), this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop;
                else return console.warn("Phaser.Sound.play: audio marker " + a + " doesn't exist"), this;
            else b = b || 0, "undefined" === typeof c && (c = this._volume), "undefined" === typeof e && (e = this.loop), this.position = b, this.volume = c, this.loop = e, this.durationMS = this.duration = 0, this._tempMarker = a, this._tempPosition = b, this._tempVolume = c, this._tempLoop = e;
            this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (null ==
                    this._buffer && (this._buffer = this.game.cache.getSoundData(this.key)), this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode.input) : this._sound.connect(this.gainNode), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1E3 * this.totalDuration), this.loop && "" === a && (this._sound.loop = !0), "undefined" === typeof this._sound.start ? this._sound.noteGrainOn(0, this.position,
                        this.duration) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) :
                this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1E3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._sound.volume = this._muted ? 0 : this._volume, this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0;
            return this
        },
        restart: function(a, b, c, e) {
            "undefined" == typeof e && (e = !1);
            this.play(a || "", b || 0, c || 1, e, !0)
        },
        pause: function() {
            this.isPlaying && this._sound && (this.stop(), this.isPlaying = !1, this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.now, this.onPause.dispatch(this))
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var a = this.position + this.pausedPosition / 1E3;
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    this.externalNode ?
                        this._sound.connect(this.externalNode.input) : this._sound.connect(this.gainNode);
                    this.loop && (this._sound.loop = !0);
                    "undefined" === typeof this._sound.start ? this._sound.noteGrainOn(0, a, this.duration) : this._sound.start(0, a, this.duration)
                } else this._sound.play();
                this.isPlaying = !0;
                this.paused = !1;
                this.startTime += this.game.time.now - this.pausedTime;
                this.onResume.dispatch(this)
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound)
                if (this.usingWebAudio)
                    if ("undefined" === typeof this._sound.stop) this._sound.noteOff(0);
                    else try {
                        this._sound.stop(0)
                    } catch (a) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
            this.isPlaying = !1;
            var b = this.currentMarker;
            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this);
            this.currentMarker = "";
            this.onStop.dispatch(this, b)
        },
        destroy: function(a) {
            "undefined" === typeof a && (a = !0);
            this.stop();
            a && this.game.sound.remove(this);
            this.markers = {};
            this.externalNode = this._buffer = this.context = null;
            this.onDecoded.dispose();
            this.onPlay.dispose();
            this.onPause.dispose();
            this.onResume.dispose();
            this.onLoop.dispose();
            this.onStop.dispose();
            this.onMute.dispose();
            this.onMarkerComplete.dispose()
        }
    };
    c.Sound.prototype.constructor = c.Sound;
    Object.defineProperty(c.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding
        }
    });
    Object.defineProperty(c.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key)
        }
    });
    Object.defineProperty(c.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute
        },
        set: function(a) {
            a ? (this._muted = !0, this.usingWebAudio ? (this._muteVolume = this.gainNode.gain.value, this.gainNode.gain.value = 0) : this.usingAudioTag && this._sound && (this._muteVolume = this._sound.volume, this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume));
            this.onMute.dispatch(this)
        }
    });
    Object.defineProperty(c.Sound.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this.usingWebAudio ?
                (this._volume = a, this.gainNode.gain.value = a) : this.usingAudioTag && this._sound && (0 <= a && 1 >= a) && (this._volume = a, this._sound.volume = a)
        }
    });
    c.SoundManager = function(a) {
        this.game = a;
        this.onSoundDecode = new c.Signal;
        this._muted = this._codeMuted = !1;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this.context = null;
        this.usingWebAudio = !0;
        this.noAudio = this.usingAudioTag = !1;
        this.connectToMaster = !0;
        this.touchLocked = !1;
        this.channels = 32
    };
    c.SoundManager.prototype = {
        boot: function() {
            this.game.device.iOS && !1 === this.game.device.webAudio &&
                (this.channels = 1);
            this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? (this.game.input.touch.callbackContext = this, this.game.input.touch.touchStartCallback = this.unlock, this.game.input.mouse.callbackContext = this, this.game.input.mouse.mouseDownCallback = this.unlock, this.touchLocked = !0) : this.touchLocked = !1;
            if (window.PhaserGlobal) {
                if (!0 === window.PhaserGlobal.disableAudio) {
                    this.usingWebAudio = !1;
                    this.noAudio = !0;
                    return
                }
                if (!0 === window.PhaserGlobal.disableWebAudio) {
                    this.usingWebAudio = !1;
                    this.usingAudioTag = !0;
                    this.noAudio = !1;
                    return
                }
            }
            if (window.AudioContext) try {
                this.context = new window.AudioContext
            } catch (a) {
                this.context = null, this.usingWebAudio = !1, this.noAudio = !0
            } else if (window.webkitAudioContext) try {
                this.context = new window.webkitAudioContext
            } catch (b) {
                this.context = null, this.usingWebAudio = !1, this.noAudio = !0
            }
            window.Audio && null === this.context && (this.usingWebAudio = !1, this.usingAudioTag = !0, this.noAudio = !1);
            null !== this.context && (this.masterGain = "undefined" === typeof this.context.createGain ?
                this.context.createGainNode() : this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination))
        },
        unlock: function() {
            if (!1 !== this.touchLocked)
                if (!1 === this.game.device.webAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableWebAudio) this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null, this.game.input.mouse.callbackContext = null, this.game.input.mouse.mouseDownCallback = null;
                else {
                    var a =
                        this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource();
                    this._unlockSource.buffer = a;
                    this._unlockSource.connect(this.context.destination);
                    this._unlockSource.noteOn(0)
                }
        },
        stopAll: function() {
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop()
        },
        pauseAll: function() {
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause()
        },
        resumeAll: function() {
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume()
        },
        decode: function(a, b) {
            b = b || null;
            var c = this.game.cache.getSoundData(a);
            if (c && !1 === this.game.cache.isSoundDecoded(a)) {
                this.game.cache.updateSound(a, "isDecoding", !0);
                var e = this;
                this.context.decodeAudioData(c, function(c) {
                    e.game.cache.decodedSound(a, c);
                    b && e.onSoundDecode.dispatch(a, b)
                })
            }
        },
        update: function() {
            if (this.touchLocked && this.game.device.webAudio && null !== this._unlockSource && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE)) this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null;
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update()
        },
        add: function(a, b, d, e) {
            "undefined" === typeof b && (b = 1);
            "undefined" === typeof d && (d = !1);
            "undefined" === typeof e && (e = this.connectToMaster);
            a = new c.Sound(this.game, a, b, d, e);
            this._sounds.push(a);
            return a
        },
        remove: function(a) {
            for (var b = this._sounds.length; b--;)
                if (this._sounds[b] === a) return this._sounds[b].destroy(!1), this._sounds.splice(b,
                    1), !0;
            return !1
        },
        removeByKey: function(a) {
            for (var b = this._sounds.length, c = 0; b--;) this._sounds[b].key === a && (this._sounds[b].destroy(!1), this._sounds.splice(b, 1), c++);
            return c
        },
        play: function(a, b, c) {
            a = this.add(a, b, c);
            a.play();
            return a
        },
        setMute: function() {
            if (!this._muted) {
                this._muted = !0;
                this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0)
            }
        },
        unsetMute: function() {
            if (this._muted &&
                !this._codeMuted) {
                this._muted = !1;
                this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1)
            }
        }
    };
    c.SoundManager.prototype.constructor = c.SoundManager;
    Object.defineProperty(c.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(a) {
            a ? this._muted || (this._codeMuted = !0, this.setMute()) : this._muted && (this._codeMuted = !1, this.unsetMute())
        }
    });
    Object.defineProperty(c.SoundManager.prototype,
        "volume", {
            get: function() {
                return this.usingWebAudio ? this.masterGain.gain.value : this._volume
            },
            set: function(a) {
                this._volume = a;
                if (this.usingWebAudio) this.masterGain.gain.value = a;
                else
                    for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && (this._sounds[b].volume *= a)
            }
        });
    c.Utils.Debug = function(a) {
        this.game = a;
        this.context = this.textureFrame = this.texture = this.baseTexture = this.canvas = this.sprite = null;
        this.font = "14px Courier";
        this.columnWidth = 100;
        this.lineHeight = 16;
        this.renderShadow = !0;
        this.currentY =
            this.currentX = 0;
        this.currentAlpha = 1;
        this.dirty = !1
    };
    c.Utils.Debug.prototype = {
        boot: function() {
            this.game.renderType === c.CANVAS ? this.context = this.game.context : (this.canvas = c.Canvas.create(this.game.width, this.game.height, "", !0), this.context = this.canvas.getContext("2d"), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new c.Frame(0, 0, 0, this.game.width, this.game.height, "debug", this.game.rnd.uuid()), this.sprite = this.game.make.image(0, 0,
                this.texture, this.textureFrame), this.game.stage.addChild(this.sprite))
        },
        preUpdate: function() {
            this.dirty && this.sprite && (this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
        },
        start: function(a, b, c, e) {
            "number" !== typeof a && (a = 0);
            "number" !== typeof b && (b = 0);
            c = c || "rgb(255,255,255)";
            "undefined" === typeof e && (e = 0);
            this.currentX = a;
            this.currentY = b;
            this.currentColor = c;
            this.currentAlpha = this.context.globalAlpha;
            this.columnWidth = e;
            this.sprite && (this.dirty = !0);
            this.context.save();
            this.context.setTransform(1,
                0, 0, 1, 0, 0);
            this.context.strokeStyle = c;
            this.context.fillStyle = c;
            this.context.font = this.font;
            this.context.globalAlpha = 1
        },
        stop: function() {
            this.context.restore();
            this.context.globalAlpha = this.currentAlpha;
            this.sprite && PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl)
        },
        line: function() {
            for (var a = this.currentX, b = 0; b < arguments.length; b++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[b], a + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[b],
                a, this.currentY), a += this.columnWidth;
            this.currentY += this.lineHeight
        },
        soundInfo: function(a, b, c, e) {
            this.start(b, c, e);
            this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback);
            this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding);
            this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying);
            this.line("Time: " + a.currentTime);
            this.line("Volume: " + a.volume + " Muted: " + a.mute);
            this.line("WebAudio: " +
                a.usingWebAudio + " Audio: " + a.usingAudioTag);
            "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"), this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), this.line("Position: " + a.position));
            this.stop()
        },
        cameraInfo: function(a, b, c, e) {
            this.start(b, c, e);
            this.line("Camera (" + a.width + " x " + a.height + ")");
            this.line("X: " + a.x + " Y: " + a.y);
            this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width +
                " h: " + a.bounds.height);
            this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height);
            this.stop()
        },
        timer: function(a, b, c, e) {
            this.start(b, c, e);
            this.line("Timer (running: " + a.running + " expired: " + a.expired + ")");
            this.line("Next Tick: " + a.next + " Duration: " + a.duration);
            this.line("Paused: " + a.paused + " Length: " + a.length);
            this.stop()
        },
        pointer: function(a, b, c, e, f) {
            null != a && ("undefined" === typeof b && (b = !1), c = c || "rgba(0,255,0,0.5)", e = e || "rgba(255,0,0,0.5)", !0 === b && !0 === a.isUp || (this.start(a.x,
                a.y - 100, f), this.context.beginPath(), this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), this.context.fillStyle = a.active ? c : e, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " + a.worldY), this.line("Screen X: " + a.x + " Screen Y: " +
                a.y), this.line("Duration: " + a.duration + " ms"), this.line("is Down: " + a.isDown + " is Up: " + a.isUp), this.stop()))
        },
        spriteInputInfo: function(a, b, c, e) {
            this.start(b, c, e);
            this.line("Sprite Input: (" + a.width + " x " + a.height + ")");
            this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1));
            this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0));
            this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0));
            this.line("just over: " +
                a.input.justOver() + " just out: " + a.input.justOut());
            this.stop()
        },
        key: function(a, b, c, e) {
            this.start(b, c, e, 150);
            this.line("Key:", a.keyCode, "isDown:", a.isDown);
            this.line("justPressed:", a.justPressed(), "justReleased:", a.justReleased());
            this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0));
            this.stop()
        },
        inputInfo: function(a, b, c) {
            this.start(a, b, c);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " +
                this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop()
        },
        spriteBounds: function(a, b, c) {
            a = a.getBounds();
            a.x += this.game.camera.x;
            a.y += this.game.camera.y;
            this.rectangle(a, b, c)
        },
        spriteInfo: function(a, b, c, e) {
            this.start(b, c, e);
            this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y);
            this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1));
            this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1));
            this.line("visible: " + a.visible + " in camera: " + a.inCamera);
            this.stop()
        },
        spriteCoords: function(a, b, c, e) {
            this.start(b, c, e, 100);
            a.name && this.line(a.name);
            this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2));
            this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2));
            this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2));
            this.stop()
        },
        lineInfo: function(a,
            b, c, e) {
            this.start(b, c, e, 80);
            this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2));
            this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2));
            this.line("length:", a.length.toFixed(2), "angle:", a.angle);
            this.stop()
        },
        pixel: function(a, b, c, e) {
            e = e || 2;
            this.start();
            this.context.fillStyle = c;
            this.context.fillRect(a, b, e, e);
            this.stop()
        },
        geom: function(a, b, d, e) {
            "undefined" === typeof d && (d = !0);
            "undefined" === typeof e && (e = 0);
            b = b || "rgba(0,255,0,0.4)";
            this.start();
            this.context.fillStyle = b;
            this.context.strokeStyle = b;
            if (a instanceof c.Rectangle || 1 === e) d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height);
            else if (a instanceof c.Circle || 2 === e) this.context.beginPath(), this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), this.context.closePath(), d ? this.context.fill() : this.context.stroke();
            else if (a instanceof c.Point || 3 === e) this.context.fillRect(a.x -
                this.game.camera.x, a.y - this.game.camera.y, 4, 4);
            else if (a instanceof c.Line || 4 === e) this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(a.start.x + 0.5 - this.game.camera.x, a.start.y + 0.5 - this.game.camera.y), this.context.lineTo(a.end.x + 0.5 - this.game.camera.x, a.end.y + 0.5 - this.game.camera.y), this.context.closePath(), this.context.stroke();
            this.stop()
        },
        rectangle: function(a, b, c) {
            "undefined" === typeof c && (c = !0);
            b = b || "rgba(0, 255, 0, 0.4)";
            this.start();
            c ? (this.context.fillStyle = b, this.context.fillRect(a.x -
                this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.strokeStyle = b, this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height));
            this.stop()
        },
        text: function(a, b, c, e, f) {
            e = e || "rgb(255,255,255)";
            f = f || "16px Courier";
            this.start();
            this.context.font = f;
            this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, b + 1, c + 1));
            this.context.fillStyle = e;
            this.context.fillText(a, b, c);
            this.stop()
        },
        quadTree: function(a, b) {
            b = b || "rgba(255,0,0,0.3)";
            this.start();
            var c = a.bounds;
            if (0 === a.nodes.length) {
                this.context.strokeStyle = b;
                this.context.strokeRect(c.x, c.y, c.width, c.height);
                this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (c = 0; c < a.objects.length; c++) this.context.strokeRect(a.objects[c].x, a.objects[c].y, a.objects[c].width, a.objects[c].height)
            } else
                for (c = 0; c < a.nodes.length; c++) this.quadTree(a.nodes[c]);
            this.stop()
        },
        body: function(a, b, d) {
            a.body && a.body.type === c.Physics.ARCADE && (this.start(),
                c.Physics.Arcade.Body.render(this.context, a.body, b, d), this.stop())
        },
        bodyInfo: function(a, b, d, e) {
            a.body && a.body.type === c.Physics.ARCADE && (this.start(b, d, e, 210), c.Physics.Arcade.Body.renderBodyInfo(this, a.body), this.stop())
        }
    };
    c.Utils.Debug.prototype.constructor = c.Utils.Debug;
    c.Color = {
        packPixel: function(a, b, d, e) {
            return c.Device.LITTLE_ENDIAN ? e << 24 | d << 16 | b << 8 | a : a << 24 | b << 16 | d << 8 | e
        },
        unpackPixel: function(a, b, d, e) {
            if ("undefined" === typeof b || null === b) b = c.Color.createColor();
            if ("undefined" === typeof d || null ===
                d) d = !1;
            if ("undefined" === typeof e || null === e) e = !1;
            c.Device.LITTLE_ENDIAN ? (b.a = (a & 4278190080) >>> 24, b.b = (a & 16711680) >>> 16, b.g = (a & 65280) >>> 8, b.r = a & 255) : (b.r = (a & 4278190080) >>> 24, b.g = (a & 16711680) >>> 16, b.b = (a & 65280) >>> 8, b.a = a & 255);
            b.color = a;
            b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")";
            d && c.Color.RGBtoHSL(b.r, b.g, b.b, b);
            e && c.Color.RGBtoHSV(b.r, b.g, b.b, b);
            return b
        },
        fromRGBA: function(a, b) {
            b || (b = c.Color.createColor());
            b.r = (a & 4278190080) >>> 24;
            b.g = (a & 16711680) >>> 16;
            b.b = (a & 65280) >>> 8;
            b.a = a & 255;
            b.rgba = "rgba(" +
                b.r + "," + b.g + "," + b.b + "," + b.a + ")";
            return b
        },
        toRGBA: function(a, b, c, e) {
            return a << 24 | b << 16 | c << 8 | e
        },
        RGBtoHSL: function(a, b, d, e) {
            e || (e = c.Color.createColor(a, b, d, 1));
            a /= 255;
            b /= 255;
            d /= 255;
            var f = Math.min(a, b, d),
                h = Math.max(a, b, d);
            e.h = 0;
            e.s = 0;
            e.l = (h + f) / 2;
            if (h !== f) {
                var k = h - f;
                e.s = 0.5 < e.l ? k / (2 - h - f) : k / (h + f);
                h === a ? e.h = (b - d) / k + (b < d ? 6 : 0) : h === b ? e.h = (d - a) / k + 2 : h === d && (e.h = (a - b) / k + 4);
                e.h /= 6
            }
            return e
        },
        HSLtoRGB: function(a, b, d, e) {
            e ? (e.r = d, e.g = d, e.b = d) : e = c.Color.createColor(d, d, d);
            0 !== b && (b = 0.5 > d ? d * (1 + b) : d + b - d * b, d = 2 * d - b, e.r =
                c.Color.hueToColor(d, b, a + 1 / 3), e.g = c.Color.hueToColor(d, b, a), e.b = c.Color.hueToColor(d, b, a - 1 / 3));
            e.r = Math.floor(255 * e.r | 0);
            e.g = Math.floor(255 * e.g | 0);
            e.b = Math.floor(255 * e.b | 0);
            c.Color.updateColor(e);
            return e
        },
        RGBtoHSV: function(a, b, d, e) {
            e || (e = c.Color.createColor(a, b, d, 255));
            a /= 255;
            b /= 255;
            d /= 255;
            var f = Math.min(a, b, d),
                h = Math.max(a, b, d),
                k = h - f;
            e.h = 0;
            e.s = 0 === h ? 0 : k / h;
            e.v = h;
            h !== f && (h === a ? e.h = (b - d) / k + (b < d ? 6 : 0) : h === b ? e.h = (d - a) / k + 2 : h === d && (e.h = (a - b) / k + 4), e.h /= 6);
            return e
        },
        HSVtoRGB: function(a, b, d, e) {
            "undefined" ===
            typeof e && (e = c.Color.createColor(0, 0, 0, 1, a, b, 0, d));
            var f, h, k, g = Math.floor(6 * a),
                l = 6 * a - g;
            a = d * (1 - b);
            var m = d * (1 - l * b);
            b = d * (1 - (1 - l) * b);
            switch (g % 6) {
                case 0:
                    f = d;
                    h = b;
                    k = a;
                    break;
                case 1:
                    f = m;
                    h = d;
                    k = a;
                    break;
                case 2:
                    f = a;
                    h = d;
                    k = b;
                    break;
                case 3:
                    f = a;
                    h = m;
                    k = d;
                    break;
                case 4:
                    f = b;
                    h = a;
                    k = d;
                    break;
                case 5:
                    f = d, h = a, k = m
            }
            e.r = Math.floor(255 * f);
            e.g = Math.floor(255 * h);
            e.b = Math.floor(255 * k);
            c.Color.updateColor(e);
            return e
        },
        hueToColor: function(a, b, c) {
            0 > c && (c += 1);
            1 < c && (c -= 1);
            return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
        },
        createColor: function(a,
            b, c, e, f, h, k, g) {
            a = {
                r: a || 0,
                g: b || 0,
                b: c || 0,
                a: e || 1,
                h: f || 0,
                s: h || 0,
                l: k || 0,
                v: g || 0,
                color: 0
            };
            a.rgba = "rgba(" + a.r + "," + a.g + "," + a.b + "," + a.a + ")";
            return a
        },
        updateColor: function(a) {
            a.rgba = "rgba(" + a.r + "," + a.g + "," + a.b + "," + a.a + ")";
            return a
        },
        getColor32: function(a, b, c, e) {
            return a << 24 | b << 16 | c << 8 | e
        },
        getColor: function(a, b, c) {
            return a << 16 | b << 8 | c
        },
        RGBtoString: function(a, b, d, e, f) {
            "undefined" === typeof e && (e = 255);
            "undefined" === typeof f && (f = "#");
            return "#" === f ? "#" + (16777216 + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c.Color.componentToHex(e) +
                c.Color.componentToHex(a) + c.Color.componentToHex(b) + c.Color.componentToHex(d)
        },
        hexToRGB: function(a) {
            if (a = c.Color.hexToColor(a)) return c.Color.getColor32(a.a, a.r, a.g, a.b)
        },
        hexToColor: function(a, b) {
            b || (b = c.Color.createColor());
            a = a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) {
                return b + b + c + c + d + d
            });
            var d = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
            d && (b.r = parseInt(d[1], 16), b.g = parseInt(d[2], 16), b.b = parseInt(d[3], 16));
            return b
        },
        componentToHex: function(a) {
            a = a.toString(16);
            return 1 ==
                a.length ? "0" + a : a
        },
        HSVColorWheel: function(a, b) {
            "undefined" === typeof a && (a = 1);
            "undefined" === typeof b && (b = 1);
            for (var d = [], e = 0; 359 >= e; e++) d.push(c.Color.HSVtoRGB(e / 359, a, b));
            return d
        },
        HSLColorWheel: function(a, b) {
            "undefined" === typeof a && (a = 0.5);
            "undefined" === typeof b && (b = 0.5);
            for (var d = [], e = 0; 359 >= e; e++) d.push(c.Color.HSLtoRGB(e / 359, a, b));
            return d
        },
        interpolateColor: function(a, b, d, e, f) {
            "undefined" === typeof f && (f = 255);
            a = c.Color.getRGB(a);
            b = c.Color.getRGB(b);
            return c.Color.getColor32(f, (b.red - a.red) * e / d +
                a.red, (b.green - a.green) * e / d + a.green, (b.blue - a.blue) * e / d + a.blue)
        },
        interpolateColorWithRGB: function(a, b, d, e, f, h) {
            a = c.Color.getRGB(a);
            return c.Color.getColor((b - a.red) * h / f + a.red, (d - a.green) * h / f + a.green, (e - a.blue) * h / f + a.blue)
        },
        interpolateRGB: function(a, b, d, e, f, h, k, g) {
            return c.Color.getColor((e - a) * g / k + a, (f - b) * g / k + b, (h - d) * g / k + d)
        },
        getRandomColor: function(a, b, d) {
            "undefined" === typeof a && (a = 0);
            "undefined" === typeof b && (b = 255);
            "undefined" === typeof d && (d = 255);
            if (255 < b || a > b) return c.Color.getColor(255, 255, 255);
            var e = a + Math.round(Math.random() * (b - a)),
                f = a + Math.round(Math.random() * (b - a));
            a += Math.round(Math.random() * (b - a));
            return c.Color.getColor32(d, e, f, a)
        },
        getRGB: function(a) {
            return 16777215 < a ? {
                alpha: a >>> 24,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: a & 255,
                a: a >>> 24,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: a & 255
            } : {
                alpha: 255,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: a & 255,
                a: 255,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: a & 255
            }
        },
        getWebRGB: function(a) {
            a = c.Color.getRGB(a);
            return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")"
        },
        getAlpha: function(a) {
            return a >>> 24
        },
        getAlphaFloat: function(a) {
            return (a >>> 24) / 255
        },
        getRed: function(a) {
            return a >> 16 & 255
        },
        getGreen: function(a) {
            return a >> 8 & 255
        },
        getBlue: function(a) {
            return a & 255
        },
        getColorInfo: function(a) {
            var b = c.Color.getRGB(a);
            a = c.Color.RGBtoHexstring(a) + "\n";
            return a = a.concat("Alpha: " + b.alpha + " Red: " + b.red + " Green: " + b.green + " Blue: " + b.blue) + "\n"
        },
        RGBtoHexstring: function(a) {
            a = c.Color.getRGB(a);
            return "0x" + c.Color.colorToHexstring(a.alpha) + c.Color.colorToHexstring(a.red) + c.Color.colorToHexstring(a.green) +
                c.Color.colorToHexstring(a.blue)
        },
        RGBtoWebstring: function(a) {
            a = c.Color.getRGB(a);
            return "#" + c.Color.colorToHexstring(a.red) + c.Color.colorToHexstring(a.green) + c.Color.colorToHexstring(a.blue)
        },
        colorToHexstring: function(a) {
            var b = a % 16;
            return "0123456789ABCDEF".charAt((a - b) / 16) + "0123456789ABCDEF".charAt(b)
        }
    };
    c.Physics = function(a, b) {
        b = b || {};
        this.game = a;
        this.config = b;
        this.chipmunk = this.box2d = this.ninja = this.p2 = this.arcade = null;
        this.parseConfig()
    };
    c.Physics.ARCADE = 0;
    c.Physics.P2JS = 1;
    c.Physics.NINJA = 2;
    c.Physics.BOX2D =
        3;
    c.Physics.CHIPMUNK = 5;
    c.Physics.prototype = {
        parseConfig: function() {
            if ((!this.config.hasOwnProperty("arcade") || !0 === this.config.arcade) && c.Physics.hasOwnProperty("Arcade")) this.arcade = new c.Physics.Arcade(this.game), this.game.time.deltaCap = 0.2;
            this.config.hasOwnProperty("ninja") && (!0 === this.config.ninja && c.Physics.hasOwnProperty("Ninja")) && (this.ninja = new c.Physics.Ninja(this.game));
            this.config.hasOwnProperty("p2") && (!0 === this.config.p2 && c.Physics.hasOwnProperty("P2")) && (this.p2 = new c.Physics.P2(this.game,
                this.config))
        },
        startSystem: function(a) {
            a === c.Physics.ARCADE ? this.arcade = new c.Physics.Arcade(this.game) : a === c.Physics.P2JS && (this.p2 = new c.Physics.P2(this.game, this.config));
            if (a === c.Physics.NINJA) this.ninja = new c.Physics.Ninja(this.game);
            else {
                if (a === c.Physics.BOX2D && null === this.box2d) throw Error("The Box2D physics system has not been implemented yet.");
                if (a === c.Physics.CHIPMUNK && null === this.chipmunk) throw Error("The Chipmunk physics system has not been implemented yet.");
            }
        },
        enable: function(a, b, d) {
            "undefined" ===
            typeof b && (b = c.Physics.ARCADE);
            "undefined" === typeof d && (d = !1);
            b === c.Physics.ARCADE ? this.arcade.enable(a) : b === c.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : b === c.Physics.NINJA && this.ninja && this.ninja.enableAABB(a)
        },
        preUpdate: function() {
            this.p2 && this.p2.preUpdate()
        },
        update: function() {
            this.p2 && this.p2.update()
        },
        setBoundsToWorld: function() {
            this.arcade && this.arcade.setBoundsToWorld();
            this.ninja && this.ninja.setBoundsToWorld();
            this.p2 && this.p2.setBoundsToWorld()
        },
        clear: function() {
            this.p2 && this.p2.clear()
        },
        destroy: function() {
            this.p2 && this.p2.destroy();
            this.p2 = this.ninja = this.arcade = null
        }
    };
    c.Physics.prototype.constructor = c.Physics;
    c.Physics.Arcade = function(a) {
        this.game = a;
        this.gravity = new c.Point;
        this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height);
        this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        };
        this.maxObjects = 10;
        this.OVERLAP_BIAS = this.maxLevels = 4;
        this.TILE_BIAS = 16;
        this.forceX = !1;
        this.quadTree = new c.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width,
            this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this._average = this._newVelocity2 = this._newVelocity1 = this._velocity2 = this._velocity1 = this._maxOverlap = this._overlap = 0;
        this._mapData = [];
        this._result = !1;
        this._dy = this._dx = this._angle = this._total = 0
    };
    c.Physics.Arcade.prototype.constructor = c.Physics.Arcade;
    c.Physics.Arcade.prototype = {
        setBounds: function(a, b, c, e) {
            this.bounds.setTo(a, b, c, e)
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width,
                this.game.world.bounds.height)
        },
        enable: function(a, b) {
            "undefined" === typeof b && (b = !0);
            var d = 1;
            if (Array.isArray(a))
                for (d = a.length; d--;) a[d] instanceof c.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), b && (a[d].hasOwnProperty("children") && 0 < a[d].children.length) && this.enable(a[d], !0));
            else a instanceof c.Group ? this.enable(a.children, b) : (this.enableBody(a), b && (a.hasOwnProperty("children") && 0 < a.children.length) && this.enable(a.children, !0))
        },
        enableBody: function(a) {
            a.hasOwnProperty("body") && null ===
                a.body && (a.body = new c.Physics.Arcade.Body(a))
        },
        updateMotion: function(a) {
            this._velocityDelta = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
            a.angularVelocity += this._velocityDelta;
            a.rotation += a.angularVelocity * this.game.time.physicsElapsed;
            a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x);
            a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y)
        },
        computeVelocity: function(a,
            b, c, e, f, h) {
            h = h || 1E4;
            1 == a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 == a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed);
            e ? c += e * this.game.time.physicsElapsed : f && (this._drag = f * this.game.time.physicsElapsed, c = 0 < c - this._drag ? c - this._drag : 0 > c + this._drag ? c + this._drag : 0);
            c > h ? c = h : c < -h && (c = -h);
            return c
        },
        overlap: function(a, b, c, e, f) {
            c = c || null;
            e = e || null;
            f = f || c;
            this._result = !1;
            this._total = 0;
            if (Array.isArray(b))
                for (var h = 0, k = b.length; h < k; h++) this.collideHandler(a,
                    b[h], c, e, f, !0);
            else this.collideHandler(a, b, c, e, f, !0);
            return 0 < this._total
        },
        collide: function(a, b, c, e, f) {
            c = c || null;
            e = e || null;
            f = f || c;
            this._result = !1;
            this._total = 0;
            if (Array.isArray(b))
                for (var h = 0, k = b.length; h < k; h++) this.collideHandler(a, b[h], c, e, f, !1);
            else this.collideHandler(a, b, c, e, f, !1);
            return 0 < this._total
        },
        collideHandler: function(a, b, d, e, f, h) {
            "undefined" === typeof b && (a.type === c.GROUP || a.type === c.EMITTER) ? this.collideGroupVsSelf(a, d, e, f, h) : a && (b && a.exists && b.exists) && (a.type == c.SPRITE || a.type == c.TILESPRITE ?
                b.type == c.SPRITE || b.type == c.TILESPRITE ? this.collideSpriteVsSprite(a, b, d, e, f, h) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideSpriteVsGroup(a, b, d, e, f, h) : b.type == c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f) : a.type == c.GROUP ? b.type == c.SPRITE || b.type == c.TILESPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, h) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideGroupVsGroup(a, b, d, e, f, h) : b.type == c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f) : a.type == c.TILEMAPLAYER ? b.type == c.SPRITE || b.type ==
                c.TILESPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f) : (b.type == c.GROUP || b.type == c.EMITTER) && this.collideGroupVsTilemapLayer(b, a, d, e, f) : a.type == c.EMITTER && (b.type == c.SPRITE || b.type == c.TILESPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, h) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideGroupVsGroup(a, b, d, e, f, h) : b.type == c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f)))
        },
        collideSpriteVsSprite: function(a, b, c, e, f, h) {
            if (!a.body || !b.body) return !1;
            this.separate(a.body, b.body, e, f, h) && (c && c.call(f,
                a, b), this._total++);
            return !0
        },
        collideSpriteVsGroup: function(a, b, c, e, f, h) {
            if (0 !== b.length && a.body) {
                this.quadTree.clear();
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
                this.quadTree.populate(b);
                this._potentials = this.quadTree.retrieve(a);
                b = 0;
                for (var k = this._potentials.length; b < k; b++) this.separate(a.body, this._potentials[b], e, f, h) && (c && c.call(f, a, this._potentials[b].sprite), this._total++)
            }
        },
        collideGroupVsSelf: function(a, b, c, e, f) {
            if (0 !== a.length)
                for (var h = a.children.length, k = 0; k < h; k++)
                    for (var g = k + 1; g <= h; g++) a.children[k] && (a.children[g] && a.children[k].exists && a.children[g].exists) && this.collideSpriteVsSprite(a.children[k], a.children[g], b, c, e, f)
        },
        collideGroupVsGroup: function(a, b, c, e, f, h) {
            if (!(0 === a.length || 0 === b.length))
                for (var k = 0, g = a.children.length; k < g; k++) a.children[k].exists && this.collideSpriteVsGroup(a.children[k], b, c, e, f, h)
        },
        collideSpriteVsTilemapLayer: function(a, b, c, e, f) {
            if (a.body &&
                (this._mapData = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1), 0 !== this._mapData.length))
                for (b = 0; b < this._mapData.length; b++) this.separateTile(b, a.body, this._mapData[b]) && (e ? e.call(f, a, this._mapData[b]) && (this._total++, c && c.call(f, a, this._mapData[b])) : (this._total++, c && c.call(f, a, this._mapData[b])))
        },
        collideGroupVsTilemapLayer: function(a, c, d, e, f) {
            if (0 !== a.length)
                for (var h = 0, k = a.children.length; h <
                    k; h++) a.children[h].exists && this.collideSpriteVsTilemapLayer(a.children[h], c, d, e, f)
        },
        separate: function(a, c, d, e, f) {
            if (!this.intersects(a, c) || d && !1 === d.call(e, a.sprite, c.sprite)) return !1;
            if (f) return !0;
            this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? this._result = this.separateX(a, c, f) || this.separateY(a, c, f) : this._result = this.separateY(a, c, f) || this.separateX(a, c, f);
            return this._result
        },
        intersects: function(a, c) {
            return a.right <= c.position.x || a.bottom <= c.position.y ||
                a.position.x >= c.right || a.position.y >= c.bottom ? !1 : !0
        },
        separateX: function(a, c, d) {
            if (a.immovable && c.immovable) return !1;
            this._overlap = 0;
            if (this.intersects(a, c) && (this._maxOverlap = a.deltaAbsX() + c.deltaAbsX() + this.OVERLAP_BIAS, 0 === a.deltaX() && 0 === c.deltaX() ? (a.embedded = !0, c.embedded = !0) : a.deltaX() > c.deltaX() ? (this._overlap = a.right - c.x, this._overlap > this._maxOverlap || !1 === a.checkCollision.right || !1 === c.checkCollision.left ? this._overlap = 0 : (a.touching.none = !1, a.touching.right = !0, c.touching.none = !1, c.touching.left = !0)) : a.deltaX() < c.deltaX() && (this._overlap = a.x - c.width - c.x, -this._overlap > this._maxOverlap || !1 === a.checkCollision.left || !1 === c.checkCollision.right ? this._overlap = 0 : (a.touching.none = !1, a.touching.left = !0, c.touching.none = !1, c.touching.right = !0)), 0 !== this._overlap)) {
                a.overlapX = this._overlap;
                c.overlapX = this._overlap;
                if (d || a.customSeparateX || c.customSeparateX) return !0;
                this._velocity1 = a.velocity.x;
                this._velocity2 = c.velocity.x;
                !a.immovable && !c.immovable ? (this._overlap *= 0.5, a.x -= this._overlap, c.x += this._overlap,
                    this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * c.mass / a.mass) * (0 < this._velocity2 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * a.mass / c.mass) * (0 < this._velocity1 ? 1 : -1), this._average = 0.5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, a.velocity.x = this._average + this._newVelocity1 * a.bounce.x, c.velocity.x = this._average + this._newVelocity2 * c.bounce.x) : a.immovable ? c.immovable || (c.x += this._overlap, c.velocity.x =
                    this._velocity1 - this._velocity2 * c.bounce.x) : (a.x -= this._overlap, a.velocity.x = this._velocity2 - this._velocity1 * a.bounce.x);
                return !0
            }
            return !1
        },
        separateY: function(a, c, d) {
            if (a.immovable && c.immovable) return !1;
            this._overlap = 0;
            if (this.intersects(a, c) && (this._maxOverlap = a.deltaAbsY() + c.deltaAbsY() + this.OVERLAP_BIAS, 0 === a.deltaY() && 0 === c.deltaY() ? (a.embedded = !0, c.embedded = !0) : a.deltaY() > c.deltaY() ? (this._overlap = a.bottom - c.y, this._overlap > this._maxOverlap || !1 === a.checkCollision.down || !1 === c.checkCollision.up ?
                    this._overlap = 0 : (a.touching.none = !1, a.touching.down = !0, c.touching.none = !1, c.touching.up = !0)) : a.deltaY() < c.deltaY() && (this._overlap = a.y - c.bottom, -this._overlap > this._maxOverlap || !1 === a.checkCollision.up || !1 === c.checkCollision.down ? this._overlap = 0 : (a.touching.none = !1, a.touching.up = !0, c.touching.none = !1, c.touching.down = !0)), 0 !== this._overlap)) {
                a.overlapY = this._overlap;
                c.overlapY = this._overlap;
                if (d || a.customSeparateY || c.customSeparateY) return !0;
                this._velocity1 = a.velocity.y;
                this._velocity2 = c.velocity.y;
                !a.immovable && !c.immovable ? (this._overlap *= 0.5, a.y -= this._overlap, c.y += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * c.mass / a.mass) * (0 < this._velocity2 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * a.mass / c.mass) * (0 < this._velocity1 ? 1 : -1), this._average = 0.5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, a.velocity.y = this._average + this._newVelocity1 * a.bounce.y, c.velocity.y = this._average + this._newVelocity2 *
                    c.bounce.y) : a.immovable ? c.immovable || (c.y += this._overlap, c.velocity.y = this._velocity1 - this._velocity2 * c.bounce.y, a.moves && (c.x += a.x - a.prev.x)) : (a.y -= this._overlap, a.velocity.y = this._velocity2 - this._velocity1 * a.bounce.y, c.moves && (a.x += c.x - c.prev.x));
                return !0
            }
            return !1
        },
        separateTile: function(a, c, d) {
            if (!d.intersects(c.position.x, c.position.y, c.right, c.bottom) || d.collisionCallback && !d.collisionCallback.call(d.collisionCallbackContext, c.sprite, d) || d.layer.callbacks[d.index] && !d.layer.callbacks[d.index].callback.call(d.layer.callbacks[d.index].callbackContext,
                    c.sprite, d) || !d.faceLeft && !d.faceRight && !d.faceTop && !d.faceBottom) return !1;
            var e = a = 0,
                f = 0,
                h = 1;
            c.deltaAbsX() > c.deltaAbsY() ? f = -1 : c.deltaAbsX() < c.deltaAbsY() && (h = -1);
            if (0 !== c.deltaX() && 0 !== c.deltaY() && (d.faceLeft || d.faceRight) && (d.faceTop || d.faceBottom)) f = Math.min(Math.abs(c.position.x - d.right), Math.abs(c.right - d.left)), h = Math.min(Math.abs(c.position.y - d.bottom), Math.abs(c.bottom - d.top));
            if (f < h) {
                if (d.faceLeft || d.faceRight)
                    if (a = this.tileCheckX(c, d), 0 !== a && !d.intersects(c.position.x, c.position.y, c.right,
                            c.bottom)) return !0;
                if (d.faceTop || d.faceBottom) e = this.tileCheckY(c, d)
            } else {
                if (d.faceTop || d.faceBottom)
                    if (e = this.tileCheckY(c, d), 0 !== e && !d.intersects(c.position.x, c.position.y, c.right, c.bottom)) return !0;
                if (d.faceLeft || d.faceRight) a = this.tileCheckX(c, d)
            }
            return 0 !== a || 0 !== e
        },
        tileCheckX: function(a, c) {
            var d = 0;
            0 > a.deltaX() && !a.blocked.left && c.collideRight && a.checkCollision.left ? c.faceRight && a.x < c.right && (d = a.x - c.right, d < -this.TILE_BIAS && (d = 0)) : 0 < a.deltaX() && (!a.blocked.right && c.collideLeft && a.checkCollision.right) &&
                (c.faceLeft && a.right > c.left) && (d = a.right - c.left, d > this.TILE_BIAS && (d = 0));
            0 !== d && this.processTileSeparationX(a, d);
            return d
        },
        tileCheckY: function(a, c) {
            var d = 0;
            0 > a.deltaY() && !a.blocked.up && c.collideDown && a.checkCollision.up ? c.faceBottom && a.y < c.bottom && (d = a.y - c.bottom, d < -this.TILE_BIAS && (d = 0)) : 0 < a.deltaY() && (!a.blocked.down && c.collideUp && a.checkCollision.down) && (c.faceTop && a.bottom > c.top) && (d = a.bottom - c.top, d > this.TILE_BIAS && (d = 0));
            0 !== d && this.processTileSeparationY(a, d);
            return d
        },
        processTileSeparationX: function(a,
            c) {
            0 > c ? a.blocked.left = !0 : 0 < c && (a.blocked.right = !0);
            a.position.x -= c;
            a.velocity.x = 0 === a.bounce.x ? 0 : -a.velocity.x * a.bounce.x
        },
        processTileSeparationY: function(a, c) {
            0 > c ? a.blocked.up = !0 : 0 < c && (a.blocked.down = !0);
            a.position.y -= c;
            a.velocity.y = 0 === a.bounce.y ? 0 : -a.velocity.y * a.bounce.y
        },
        getObjectsUnderPointer: function(a, b, d, e) {
            if (0 !== b.length && a.exists) {
                this.quadTree.clear();
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects,
                    this.maxLevels);
                this.quadTree.populate(b);
                var f = new c.Rectangle(a.x, a.y, 1, 1);
                b = [];
                this._potentials = this.quadTree.retrieve(f);
                for (var f = 0, h = this._potentials.length; f < h; f++) this._potentials[f].hitTest(a.x, a.y) && (d && d.call(e, a, this._potentials[f].sprite), b.push(this._potentials[f].sprite));
                return b
            }
        },
        moveToObject: function(a, c, d, e) {
            "undefined" === typeof d && (d = 60);
            "undefined" === typeof e && (e = 0);
            this._angle = Math.atan2(c.y - a.y, c.x - a.x);
            0 < e && (d = this.distanceBetween(a, c) / (e / 1E3));
            a.body.velocity.x = Math.cos(this._angle) *
                d;
            a.body.velocity.y = Math.sin(this._angle) * d;
            return this._angle
        },
        moveToPointer: function(a, c, d, e) {
            "undefined" === typeof c && (c = 60);
            d = d || this.game.input.activePointer;
            "undefined" === typeof e && (e = 0);
            this._angle = this.angleToPointer(a, d);
            0 < e && (c = this.distanceToPointer(a, d) / (e / 1E3));
            a.body.velocity.x = Math.cos(this._angle) * c;
            a.body.velocity.y = Math.sin(this._angle) * c;
            return this._angle
        },
        moveToXY: function(a, c, d, e, f) {
            "undefined" === typeof e && (e = 60);
            "undefined" === typeof f && (f = 0);
            this._angle = Math.atan2(d - a.y, c - a.x);
            0 < f && (e = this.distanceToXY(a, c, d) / (f / 1E3));
            a.body.velocity.x = Math.cos(this._angle) * e;
            a.body.velocity.y = Math.sin(this._angle) * e;
            return this._angle
        },
        velocityFromAngle: function(a, b, d) {
            "undefined" === typeof b && (b = 60);
            d = d || new c.Point;
            return d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b)
        },
        velocityFromRotation: function(a, b, d) {
            "undefined" === typeof b && (b = 60);
            d = d || new c.Point;
            return d.setTo(Math.cos(a) * b, Math.sin(a) * b)
        },
        accelerationFromRotation: function(a, b, d) {
            "undefined" ===
            typeof b && (b = 60);
            d = d || new c.Point;
            return d.setTo(Math.cos(a) * b, Math.sin(a) * b)
        },
        accelerateToObject: function(a, c, d, e, f) {
            "undefined" === typeof d && (d = 60);
            "undefined" === typeof e && (e = 1E3);
            "undefined" === typeof f && (f = 1E3);
            this._angle = this.angleBetween(a, c);
            a.body.acceleration.setTo(Math.cos(this._angle) * d, Math.sin(this._angle) * d);
            a.body.maxVelocity.setTo(e, f);
            return this._angle
        },
        accelerateToPointer: function(a, c, d, e, f) {
            "undefined" === typeof d && (d = 60);
            "undefined" === typeof c && (c = this.game.input.activePointer);
            "undefined" === typeof e && (e = 1E3);
            "undefined" === typeof f && (f = 1E3);
            this._angle = this.angleToPointer(a, c);
            a.body.acceleration.setTo(Math.cos(this._angle) * d, Math.sin(this._angle) * d);
            a.body.maxVelocity.setTo(e, f);
            return this._angle
        },
        accelerateToXY: function(a, c, d, e, f, h) {
            "undefined" === typeof e && (e = 60);
            "undefined" === typeof f && (f = 1E3);
            "undefined" === typeof h && (h = 1E3);
            this._angle = this.angleToXY(a, c, d);
            a.body.acceleration.setTo(Math.cos(this._angle) * e, Math.sin(this._angle) * e);
            a.body.maxVelocity.setTo(f, h);
            return this._angle
        },
        distanceBetween: function(a, c) {
            this._dx = a.x - c.x;
            this._dy = a.y - c.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        distanceToXY: function(a, c, d) {
            this._dx = a.x - c;
            this._dy = a.y - d;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        distanceToPointer: function(a, c) {
            c = c || this.game.input.activePointer;
            this._dx = a.x - c.x;
            this._dy = a.y - c.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        angleBetween: function(a, c) {
            this._dx = c.x - a.x;
            this._dy = c.y - a.y;
            return Math.atan2(this._dy, this._dx)
        },
        angleToXY: function(a,
            c, d) {
            this._dx = c - a.x;
            this._dy = d - a.y;
            return Math.atan2(this._dy, this._dx)
        },
        angleToPointer: function(a, c) {
            c = c || this.game.input.activePointer;
            this._dx = c.worldX - a.x;
            this._dy = c.worldY - a.y;
            return Math.atan2(this._dy, this._dx)
        }
    };
    c.Physics.Arcade.Body = function(a) {
        this.sprite = a;
        this.game = a.game;
        this.type = c.Physics.ARCADE;
        this.offset = new c.Point;
        this.position = new c.Point(a.x, a.y);
        this.prev = new c.Point(this.position.x, this.position.y);
        this.allowRotation = !0;
        this.preRotation = this.rotation = a.rotation;
        this.sourceWidth =
            a.texture.frame.width;
        this.sourceHeight = a.texture.frame.height;
        this.width = a.width;
        this.height = a.height;
        this.halfWidth = Math.abs(a.width / 2);
        this.halfHeight = Math.abs(a.height / 2);
        this.center = new c.Point(a.x + this.halfWidth, a.y + this.halfHeight);
        this.velocity = new c.Point;
        this.newVelocity = new c.Point(0, 0);
        this.deltaMax = new c.Point(0, 0);
        this.acceleration = new c.Point;
        this.drag = new c.Point;
        this.allowGravity = !0;
        this.gravity = new c.Point(0, 0);
        this.bounce = new c.Point;
        this.maxVelocity = new c.Point(1E4, 1E4);
        this.angularDrag =
            this.angularAcceleration = this.angularVelocity = 0;
        this.maxAngular = 1E3;
        this.mass = 1;
        this.speed = this.angle = 0;
        this.facing = c.NONE;
        this.immovable = !1;
        this.moves = !0;
        this.customSeparateY = this.customSeparateX = !1;
        this.overlapY = this.overlapX = 0;
        this.collideWorldBounds = this.embedded = !1;
        this.checkCollision = {
            none: !1,
            any: !0,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        };
        this.touching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        };
        this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        };
        this.blocked = {
            up: !1,
            down: !1,
            left: !1,
            right: !1
        };
        this.tilePadding =
            new c.Point;
        this.phase = 0;
        this._reset = !0;
        this._sx = a.scale.x;
        this._sy = a.scale.y;
        this._dy = this._dx = 0
    };
    c.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            var a = Math.abs(this.sprite.scale.x),
                c = Math.abs(this.sprite.scale.y);
            if (a !== this._sx || c !== this._sy) this.width = this.sourceWidth * a, this.height = this.sourceHeight * c, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this._sx = a, this._sy = c, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
                this._reset = !0
        },
        preUpdate: function() {
            this.phase = 1;
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = !0;
            this.touching.up = !1;
            this.touching.down = !1;
            this.touching.left = !1;
            this.touching.right = !1;
            this.blocked.up = !1;
            this.blocked.down = !1;
            this.blocked.left = !1;
            this.embedded = this.blocked.right = !1;
            this.updateBounds();
            this.position.x = this.sprite.world.x -
                this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
            this.preRotation = this.rotation = this.sprite.angle;
            if (this._reset || 1 === this.sprite._cache[4]) this.prev.x = this.position.x, this.prev.y = this.position.y;
            if (this.moves) {
                this.game.physics.arcade.updateMotion(this);
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
                this.position.x += this.newVelocity.x;
                this.position.y +=
                    this.newVelocity.y;
                if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                this.collideWorldBounds && this.checkWorldBounds()
            }
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            this._reset = !1
        },
        postUpdate: function() {
            2 !== this.phase && (this.phase = 2, 0 > this.deltaX() ? this.facing = c.LEFT : 0 < this.deltaX() && (this.facing = c.RIGHT), 0 > this.deltaY() ? this.facing = c.UP : 0 < this.deltaY() &&
                (this.facing = c.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (0 > this._dx && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : 0 < this._dx && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (0 > this._dy && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : 0 < this._dy && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.x += this._dx, this.sprite.y += this._dy), this.center.setTo(this.position.x + this.halfWidth,
                    this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
        },
        destroy: function() {
            this.sprite = null
        },
        checkWorldBounds: function() {
            this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left ? (this.position.x = this.game.physics.arcade.bounds.x, this.velocity.x *= -this.bounce.x, this.blocked.left = !0) : this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right &&
                (this.position.x = this.game.physics.arcade.bounds.right - this.width, this.velocity.x *= -this.bounce.x, this.blocked.right = !0);
            this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up ? (this.position.y = this.game.physics.arcade.bounds.y, this.velocity.y *= -this.bounce.y, this.blocked.up = !0) : this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down && (this.position.y = this.game.physics.arcade.bounds.bottom - this.height, this.velocity.y *=
                -this.bounce.y, this.blocked.down = !0)
        },
        setSize: function(a, c, d, e) {
            d = d || this.offset.x;
            e = e || this.offset.y;
            this.sourceWidth = a;
            this.sourceHeight = c;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(d, e);
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        reset: function(a, c) {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.angularAcceleration = this.angularVelocity =
                0;
            this.position.x = a - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = c - this.sprite.anchor.y * this.height + this.offset.y;
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            this.preRotation = this.rotation = this.sprite.angle;
            this._sx = this.sprite.scale.x;
            this._sy = this.sprite.scale.y;
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        hitTest: function(a, b) {
            return c.Rectangle.contains(this, a, b)
        },
        onFloor: function() {
            return this.blocked.down
        },
        onWall: function() {
            return this.blocked.left ||
                this.blocked.right
        },
        deltaAbsX: function() {
            return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
        },
        deltaAbsY: function() {
            return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
        },
        deltaX: function() {
            return this.position.x - this.prev.x
        },
        deltaY: function() {
            return this.position.y - this.prev.y
        },
        deltaZ: function() {
            return this.rotation - this.preRotation
        }
    };
    Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height
        }
    });
    Object.defineProperty(c.Physics.Arcade.Body.prototype,
        "right", {
            get: function() {
                return this.position.x + this.width
            }
        });
    Object.defineProperty(c.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(a) {
            this.position.x = a
        }
    });
    Object.defineProperty(c.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(a) {
            this.position.y = a
        }
    });
    c.Physics.Arcade.Body.render = function(a, c, d, e) {
        "undefined" === typeof d && (d = !0);
        e = e || "rgba(0,255,0,0.4)";
        d ? (a.fillStyle = e, a.fillRect(c.position.x - c.game.camera.x, c.position.y -
            c.game.camera.y, c.width, c.height)) : (a.strokeStyle = e, a.strokeRect(c.position.x - c.game.camera.x, c.position.y - c.game.camera.y, c.width, c.height))
    };
    c.Physics.Arcade.Body.renderBodyInfo = function(a, c) {
        a.line("x: " + c.x.toFixed(2), "y: " + c.y.toFixed(2), "width: " + c.width, "height: " + c.height);
        a.line("velocity x: " + c.velocity.x.toFixed(2), "y: " + c.velocity.y.toFixed(2), "deltaX: " + c._dx.toFixed(2), "deltaY: " + c._dy.toFixed(2));
        a.line("acceleration x: " + c.acceleration.x.toFixed(2), "y: " + c.acceleration.y.toFixed(2),
            "speed: " + c.speed.toFixed(2), "angle: " + c.angle.toFixed(2));
        a.line("gravity x: " + c.gravity.x, "y: " + c.gravity.y, "bounce x: " + c.bounce.x.toFixed(2), "y: " + c.bounce.y.toFixed(2));
        a.line("touching left: " + c.touching.left, "right: " + c.touching.right, "up: " + c.touching.up, "down: " + c.touching.down);
        a.line("blocked left: " + c.blocked.left, "right: " + c.blocked.right, "up: " + c.blocked.up, "down: " + c.blocked.down)
    };
    c.Physics.Arcade.Body.prototype.constructor = c.Physics.Arcade.Body;
    c.Particles = function(a) {
        this.game = a;
        this.emitters = {};
        this.ID = 0
    };
    c.Particles.prototype = {
        add: function(a) {
            return this.emitters[a.name] = a
        },
        remove: function(a) {
            delete this.emitters[a.name]
        },
        update: function() {
            for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update()
        }
    };
    c.Particles.prototype.constructor = c.Particles;
    c.Particles.Arcade = {};
    c.Particles.Arcade.Emitter = function(a, b, d, e) {
        this.maxParticles = e || 50;
        c.Group.call(this, a);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = c.EMITTER;
        this.height = this.width = 1;
        this.minParticleSpeed =
            new c.Point(-100, -100);
        this.maxParticleSpeed = new c.Point(100, 100);
        this.maxParticleScale = this.minParticleScale = 1;
        this.scaleData = null;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.maxParticleAlpha = this.minParticleAlpha = 1;
        this.alphaData = null;
        this.gravity = 100;
        this.particleClass = c.Particle;
        this.particleDrag = new c.Point;
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2E3;
        this.bounce = new c.Point;
        this.on = !1;
        this.particleAnchor = new c.Point(0.5, 0.5);
        this.blendMode = c.blendModes.NORMAL;
        this.emitX = b;
        this.emitY =
            d;
        this.particleSendToBack = this.particleBringToTop = this.autoAlpha = this.autoScale = !1;
        this._minParticleScale = new c.Point(1, 1);
        this._maxParticleScale = new c.Point(1, 1);
        this._counter = this._timer = this._quantity = 0;
        this._explode = !0;
        this._frames = null
    };
    c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype);
    c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter;
    c.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on)
            if (this._explode) {
                this._counter = 0;
                do this.emitParticle(),
                    this._counter++; while (this._counter < this._quantity);
                this.on = !1
            } else this.game.time.now >= this._timer && (this.emitParticle(), this._counter++, 0 < this._quantity && this._counter >= this._quantity && (this.on = !1), this._timer = this.game.time.now + this.frequency);
        for (var a = this.children.length; a--;) this.children[a].exists && this.children[a].update()
    };
    c.Particles.Arcade.Emitter.prototype.makeParticles = function(a, c, d, e, f) {
        "undefined" === typeof c && (c = 0);
        "undefined" === typeof d && (d = this.maxParticles);
        "undefined" === typeof e &&
            (e = !1);
        "undefined" === typeof f && (f = !1);
        var h, k = 0,
            g = a,
            l = c;
        for (this._frames = c; k < d;) Array.isArray(a) && (g = this.game.rnd.pick(a)), Array.isArray(c) && (l = this.game.rnd.pick(c)), h = new this.particleClass(this.game, 0, 0, g, l), this.game.physics.arcade.enable(h, !1), e ? (h.body.checkCollision.any = !0, h.body.checkCollision.none = !1) : h.body.checkCollision.none = !0, h.body.collideWorldBounds = f, h.exists = !1, h.visible = !1, h.anchor.copyFrom(this.particleAnchor), this.add(h), k++;
        return this
    };
    c.Particles.Arcade.Emitter.prototype.kill =
        function() {
            this.exists = this.alive = this.on = !1
        };
    c.Particles.Arcade.Emitter.prototype.revive = function() {
        this.exists = this.alive = !0
    };
    c.Particles.Arcade.Emitter.prototype.start = function(a, c, d, e) {
        "undefined" === typeof a && (a = !0);
        "undefined" === typeof c && (c = 0);
        if ("undefined" === typeof d || null === d) d = 250;
        "undefined" === typeof e && (e = 0);
        this.revive();
        this.on = this.visible = !0;
        this._explode = a;
        this.lifespan = c;
        this.frequency = d;
        this._quantity = a ? e : this._quantity + e;
        this._counter = 0;
        this._timer = this.game.time.now + d
    };
    c.Particles.Arcade.Emitter.prototype.emitParticle =
        function() {
            var a = this.getFirstExists(!1);
            null !== a && (1 < this.width || 1 < this.height ? a.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom)) : a.reset(this.emitX, this.emitY), a.angle = 0, a.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(a) : this.particleSendToBack && this.sendToBack(a), this.autoScale ? a.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? a.scale.set(this.game.rnd.realInRange(this.minParticleScale,
                    this.maxParticleScale)) : (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) && a.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), Array.isArray("object" === this._frames) ? a.frame = this.game.rnd.pick(this._frames) : a.frame = this._frames, this.autoAlpha ? a.setAlphaData(this.alphaData) : a.alpha = this.game.rnd.realInRange(this.minParticleAlpha,
                    this.maxParticleAlpha), a.blendMode = this.blendMode, a.body.updateBounds(), a.body.bounce.setTo(this.bounce.x, this.bounce.y), a.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x), a.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y), a.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation), a.body.gravity.y = this.gravity, a.body.drag.x = this.particleDrag.x, a.body.drag.y = this.particleDrag.y, a.body.angularDrag =
                this.angularDrag, a.onEmit())
        };
    c.Particles.Arcade.Emitter.prototype.setSize = function(a, c) {
        this.width = a;
        this.height = c
    };
    c.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, c) {
        this.minParticleSpeed.x = a || 0;
        this.maxParticleSpeed.x = c || 0
    };
    c.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, c) {
        this.minParticleSpeed.y = a || 0;
        this.maxParticleSpeed.y = c || 0
    };
    c.Particles.Arcade.Emitter.prototype.setRotation = function(a, c) {
        this.minRotation = a || 0;
        this.maxRotation = c || 0
    };
    c.Particles.Arcade.Emitter.prototype.setAlpha =
        function(a, b, d, e, f) {
            "undefined" === typeof a && (a = 1);
            "undefined" === typeof b && (b = 1);
            "undefined" === typeof d && (d = 0);
            "undefined" === typeof e && (e = c.Easing.Linear.None);
            "undefined" === typeof f && (f = !1);
            this.minParticleAlpha = a;
            this.maxParticleAlpha = b;
            this.autoAlpha = !1;
            0 < d && a !== b && (a = this.game.make.tween({
                v: a
            }).to({
                v: b
            }, d, e), a.yoyo(f), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0)
        };
    c.Particles.Arcade.Emitter.prototype.setScale = function(a, b, d, e, f, h, k) {
        "undefined" === typeof a && (a = 1);
        "undefined" === typeof b && (b = 1);
        "undefined" === typeof d && (d = 1);
        "undefined" === typeof e && (e = 1);
        "undefined" === typeof f && (f = 0);
        "undefined" === typeof h && (h = c.Easing.Linear.None);
        "undefined" === typeof k && (k = !1);
        this.maxParticleScale = this.minParticleScale = 1;
        this._minParticleScale.set(a, d);
        this._maxParticleScale.set(b, e);
        this.autoScale = !1;
        if (0 < f && a !== b || d !== e) a = this.game.make.tween({
            x: a,
            y: d
        }).to({
            x: b,
            y: e
        }, f, h), a.yoyo(k), this.scaleData = a.generateData(60), this.scaleData.reverse(), this.autoScale = !0
    };
    c.Particles.Arcade.Emitter.prototype.at =
        function(a) {
            a.center ? (this.emitX = a.center.x, this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width, this.emitY = a.world.y + a.anchor.y * a.height)
        };
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX
        },
        set: function(a) {
            this.emitX = a
        }
    });
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY
        },
        set: function(a) {
            this.emitY = a
        }
    });
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x -
                this.width / 2)
        }
    });
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.width / 2)
        }
    });
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.height / 2)
        }
    });
    Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.height / 2)
        }
    });
    c.Tile = function(a, c, d, e, f, h) {
        this.layer = a;
        this.index = c;
        this.x = d;
        this.y = e;
        this.worldX = d * f;
        this.worldY = e * h;
        this.width =
            f;
        this.height = h;
        this.centerX = Math.abs(f / 2);
        this.centerY = Math.abs(h / 2);
        this.alpha = 1;
        this.properties = {};
        this.collideDown = this.collideUp = this.collideRight = this.collideLeft = this.faceRight = this.faceLeft = this.faceBottom = this.faceTop = this.scanned = !1;
        this.collisionCallback = null;
        this.collisionCallbackContext = this
    };
    c.Tile.prototype = {
        containsPoint: function(a, c) {
            return !(a < this.worldX || c < this.worldY || a > this.right || c > this.bottom)
        },
        intersects: function(a, c, d, e) {
            return d <= this.worldX || e <= this.worldY || a >= this.worldX +
                this.width || c >= this.worldY + this.height ? !1 : !0
        },
        setCollisionCallback: function(a, c) {
            this.collisionCallback = a;
            this.collisionCallbackContext = c
        },
        destroy: function() {
            this.properties = this.collisionCallbackContext = this.collisionCallback = null
        },
        setCollision: function(a, c, d, e) {
            this.collideLeft = a;
            this.collideRight = c;
            this.collideUp = d;
            this.collideDown = e
        },
        resetCollision: function() {
            this.faceRight = this.faceLeft = this.faceBottom = this.faceTop = this.collideDown = this.collideUp = this.collideRight = this.collideLeft = !1
        },
        isInteresting: function(a,
            c) {
            return a && c ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : c ? this.faceTop || this.faceBottom || this.faceLeft || this.faceRight : !1
        },
        copy: function(a) {
            this.index = a.index;
            this.alpha = a.alpha;
            this.properties = a.properties;
            this.collideUp = a.collideUp;
            this.collideDown = a.collideDown;
            this.collideLeft = a.collideLeft;
            this.collideRight =
                a.collideRight;
            this.collisionCallback = a.collisionCallback;
            this.collisionCallbackContext = a.collisionCallbackContext
        }
    };
    c.Tile.prototype.constructor = c.Tile;
    Object.defineProperty(c.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
        }
    });
    Object.defineProperty(c.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
        }
    });
    Object.defineProperty(c.Tile.prototype,
        "left", {
            get: function() {
                return this.worldX
            }
        });
    Object.defineProperty(c.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width
        }
    });
    Object.defineProperty(c.Tile.prototype, "top", {
        get: function() {
            return this.worldY
        }
    });
    Object.defineProperty(c.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height
        }
    });
    c.Tilemap = function(a, b, d, e, f, h) {
        this.game = a;
        this.key = b;
        a = c.TilemapParser.parse(this.game, b, d, e, f, h);
        null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight =
            a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempB = this._tempA = 0)
    };
    c.Tilemap.CSV = 0;
    c.Tilemap.TILED_JSON = 1;
    c.Tilemap.NORTH = 0;
    c.Tilemap.EAST =
        1;
    c.Tilemap.SOUTH = 2;
    c.Tilemap.WEST = 3;
    c.Tilemap.prototype = {
        create: function(a, c, d, e, f, h) {
            "undefined" === typeof h && (h = this.game.world);
            this.width = c;
            this.height = d;
            this.setTileSize(e, f);
            this.layers.length = 0;
            return this.createBlankLayer(a, c, d, e, f, h)
        },
        setTileSize: function(a, c) {
            this.tileWidth = a;
            this.tileHeight = c;
            this.widthInPixels = this.width * a;
            this.heightInPixels = this.height * c
        },
        addTilesetImage: function(a, b, d, e, f, h, k) {
            "undefined" === typeof d && (d = this.tileWidth);
            "undefined" === typeof e && (e = this.tileHeight);
            "undefined" ===
            typeof f && (f = 0);
            "undefined" === typeof h && (h = 0);
            "undefined" === typeof k && (k = 0);
            0 === d && (d = 32);
            0 === e && (e = 32);
            if ("undefined" === typeof b)
                if ("string" === typeof a) {
                    if (b = a, !this.game.cache.checkImageKey(b)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + b + '"'), null
                } else return null;
            if ("string" === typeof a && (a = this.getTilesetIndex(a), null === a && this.format === c.Tilemap.TILED_JSON)) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' +
                b + '"'), null;
            if (this.tilesets[a]) return this.tilesets[a].setImage(this.game.cache.getImage(b)), this.tilesets[a];
            a = new c.Tileset(b, k, d, e, f, h, {});
            a.setImage(this.game.cache.getImage(b));
            this.tilesets.push(a);
            b = this.tilesets.length - 1;
            for (var g = f, l = f, m = 0, n = 0, q = 0, s = k; s < k + a.total; s++) {
                this.tiles[s] = [g, l, b];
                g += d + h;
                m++;
                if (m === a.total) break;
                n++;
                if (n === a.columns && (g = f, l += e + h, n = 0, q++, q === a.rows)) break
            }
            return a
        },
        createFromObjects: function(a, b, d, e, f, h, k, g, l) {
            "undefined" === typeof f && (f = !0);
            "undefined" === typeof h &&
                (h = !1);
            "undefined" === typeof k && (k = this.game.world);
            "undefined" === typeof g && (g = c.Sprite);
            "undefined" === typeof l && (l = !0);
            if (this.objects[a])
                for (var m, n = 0, q = this.objects[a].length; n < q; n++) {
                    if (this.objects[a][n].gid === b) {
                        m = new g(this.game, this.objects[a][n].x, this.objects[a][n].y, d, e);
                        m.name = this.objects[a][n].name;
                        m.visible = this.objects[a][n].visible;
                        m.autoCull = h;
                        m.exists = f;
                        l && (m.y -= m.height);
                        k.add(m);
                        for (var s in this.objects[a][n].properties) k.set(m, s, this.objects[a][n].properties[s], !1, !1, 0, !0)
                    }
                } else console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " +
                    a)
        },
        createLayer: function(a, b, d, e) {
            "undefined" === typeof b && (b = this.game.width);
            "undefined" === typeof d && (d = this.game.height);
            "undefined" === typeof e && (e = this.game.world);
            var f = a;
            "string" === typeof a && (f = this.getLayerIndex(a));
            if (null === f || f > this.layers.length) console.warn("Tilemap.createLayer: Invalid layer ID given: " + f);
            else return e.add(new c.TilemapLayer(this.game, this, f, b, d))
        },
        createBlankLayer: function(a, b, d, e, f, h) {
            "undefined" === typeof h && (h = this.game.world);
            if (null !== this.getLayerIndex(a)) console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
            else {
                for (var k = {
                        name: a,
                        x: 0,
                        y: 0,
                        width: b,
                        height: d,
                        widthInPixels: b * e,
                        heightInPixels: d * f,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: null
                    }, g, l = [], m = 0; m < d; m++) {
                    g = [];
                    for (var n = 0; n < b; n++) g.push(new c.Tile(k, -1, n, m, e, f));
                    l.push(g)
                }
                k.data = l;
                this.layers.push(k);
                this.currentLayer = this.layers.length - 1;
                b = k.widthInPixels;
                k = k.heightInPixels;
                b > this.game.width && (b = this.game.width);
                k > this.game.height && (k = this.game.height);
                l = new c.TilemapLayer(this.game, this, this.layers.length - 1, b, k);
                l.name =
                    a;
                return h.add(l)
            }
        },
        getIndex: function(a, c) {
            for (var d = 0; d < a.length; d++)
                if (a[d].name === c) return d;
            return null
        },
        getLayerIndex: function(a) {
            return this.getIndex(this.layers, a)
        },
        getTilesetIndex: function(a) {
            return this.getIndex(this.tilesets, a)
        },
        getImageIndex: function(a) {
            return this.getIndex(this.images, a)
        },
        getObjectIndex: function(a) {
            return this.getIndex(this.objects, a)
        },
        setTileIndexCallback: function(a, c, d, e) {
            e = this.getLayer(e);
            if ("number" === typeof a) this.layers[e].callbacks[a] = {
                callback: c,
                callbackContext: d
            };
            else
                for (var f = 0, h = a.length; f < h; f++) this.layers[e].callbacks[a[f]] = {
                    callback: c,
                    callbackContext: d
                }
        },
        setTileLocationCallback: function(a, c, d, e, f, h, k) {
            k = this.getLayer(k);
            this.copy(a, c, d, e, k);
            if (!(2 > this._results.length))
                for (a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(f, h)
        },
        setCollision: function(a, c, d, e) {
            "undefined" === typeof c && (c = !0);
            "undefined" === typeof e && (e = !0);
            d = this.getLayer(d);
            if ("number" === typeof a) return this.setCollisionByIndex(a, c, d, !0);
            for (var f = 0, h = a.length; f < h; f++) this.setCollisionByIndex(a[f],
                c, d, !1);
            e && this.calculateFaces(d)
        },
        setCollisionBetween: function(a, c, d, e, f) {
            "undefined" === typeof d && (d = !0);
            "undefined" === typeof f && (f = !0);
            e = this.getLayer(e);
            if (!(a > c)) {
                for (; a <= c; a++) this.setCollisionByIndex(a, d, e, !1);
                f && this.calculateFaces(e)
            }
        },
        setCollisionByExclusion: function(a, c, d, e) {
            "undefined" === typeof c && (c = !0);
            "undefined" === typeof e && (e = !0);
            d = this.getLayer(d);
            for (var f = 0, h = this.tiles.length; f < h; f++) - 1 === a.indexOf(f) && this.setCollisionByIndex(f, c, d, !1);
            e && this.calculateFaces(d)
        },
        setCollisionByIndex: function(a,
            c, d, e) {
            "undefined" === typeof c && (c = !0);
            "undefined" === typeof d && (d = this.currentLayer);
            "undefined" === typeof e && (e = !0);
            if (c) this.collideIndexes.push(a);
            else {
                var f = this.collideIndexes.indexOf(a); - 1 < f && this.collideIndexes.splice(f, 1)
            }
            for (f = 0; f < this.layers[d].height; f++)
                for (var h = 0; h < this.layers[d].width; h++) {
                    var k = this.layers[d].data[f][h];
                    k && k.index === a && (c ? k.setCollision(!0, !0, !0, !0) : k.resetCollision(), k.faceTop = c, k.faceBottom = c, k.faceLeft = c, k.faceRight = c)
                }
            e && this.calculateFaces(d);
            return d
        },
        getLayer: function(a) {
            "undefined" ===
            typeof a ? a = this.currentLayer : "string" === typeof a ? a = this.getLayerIndex(a) : a instanceof c.TilemapLayer && (a = a.index);
            return a
        },
        calculateFaces: function(a) {
            for (var c = null, d = null, e = null, f = null, h = 0, k = this.layers[a].height; h < k; h++)
                for (var g = 0, l = this.layers[a].width; g < l; g++) {
                    var m = this.layers[a].data[h][g];
                    m && (c = this.getTileAbove(a, g, h), d = this.getTileBelow(a, g, h), e = this.getTileLeft(a, g, h), f = this.getTileRight(a, g, h), m.collides && (m.faceTop = !0, m.faceBottom = !0, m.faceLeft = !0, m.faceRight = !0), c && c.collides && (m.faceTop = !1), d && d.collides && (m.faceBottom = !1), e && e.collides && (m.faceLeft = !1), f && f.collides && (m.faceRight = !1))
                }
        },
        getTileAbove: function(a, c, d) {
            return 0 < d ? this.layers[a].data[d - 1][c] : null
        },
        getTileBelow: function(a, c, d) {
            return d < this.layers[a].height - 1 ? this.layers[a].data[d + 1][c] : null
        },
        getTileLeft: function(a, c, d) {
            return 0 < c ? this.layers[a].data[d][c - 1] : null
        },
        getTileRight: function(a, c, d) {
            return c < this.layers[a].width - 1 ? this.layers[a].data[d][c + 1] : null
        },
        setLayer: function(a) {
            a = this.getLayer(a);
            this.layers[a] && (this.currentLayer =
                a)
        },
        hasTile: function(a, c, d) {
            d = this.getLayer(d);
            return null !== this.layers[d].data[c] && null !== this.layers[d].data[c][a]
        },
        removeTile: function(a, c, d) {
            d = this.getLayer(d);
            if (0 <= a && (a < this.layers[d].width && 0 <= c && c < this.layers[d].height) && this.hasTile(a, c, d)) {
                var e = this.layers[d].data[c][a];
                this.layers[d].data[c][a] = null;
                this.layers[d].dirty = !0;
                this.calculateFaces(d);
                return e
            }
        },
        removeTileWorldXY: function(a, c, d, e, f) {
            f = this.getLayer(f);
            a = this.game.math.snapToFloor(a, d) / d;
            c = this.game.math.snapToFloor(c, e) / e;
            return this.removeTile(a, c, f)
        },
        putTile: function(a, b, d, e) {
            if (null === a) return this.removeTile(b, d, e);
            e = this.getLayer(e);
            if (0 <= b && b < this.layers[e].width && 0 <= d && d < this.layers[e].height) {
                var f;
                a instanceof c.Tile ? (f = a.index, this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : this.layers[e].data[d][b] = new c.Tile(e, f, b, d, a.width, a.height)) : (f = a, this.hasTile(b, d, e) ? this.layers[e].data[d][b].index = f : this.layers[e].data[d][b] = new c.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight)); - 1 < this.collideIndexes.indexOf(f) ?
                    this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision();
                this.layers[e].dirty = !0;
                this.calculateFaces(e);
                return this.layers[e].data[d][b]
            }
            return null
        },
        putTileWorldXY: function(a, c, d, e, f, h) {
            h = this.getLayer(h);
            c = this.game.math.snapToFloor(c, e) / e;
            d = this.game.math.snapToFloor(d, f) / f;
            return this.putTile(a, c, d, h)
        },
        searchTileIndex: function(a, c, d, e) {
            "undefined" === typeof c && (c = 0);
            "undefined" === typeof d && (d = !1);
            e = this.getLayer(e);
            var f = 0;
            if (d)
                for (d = this.layers[e].height -
                    1; 0 <= d; d--)
                    for (var h = this.layers[e].width - 1; 0 <= h; h--) {
                        if (this.layers[e].data[d][h].index === a) {
                            if (f === c) return this.layers[e].data[d][h];
                            f++
                        }
                    } else
                        for (d = 0; d < this.layers[e].height; d++)
                            for (h = 0; h < this.layers[e].width; h++)
                                if (this.layers[e].data[d][h].index === a) {
                                    if (f === c) return this.layers[e].data[d][h];
                                    f++
                                }
            return null
        },
        getTile: function(a, c, d, e) {
            "undefined" === typeof e && (e = !1);
            d = this.getLayer(d);
            return 0 <= a && a < this.layers[d].width && 0 <= c && c < this.layers[d].height ? -1 === this.layers[d].data[c][a].index ? e ? this.layers[d].data[c][a] :
                null : this.layers[d].data[c][a] : null
        },
        getTileWorldXY: function(a, c, d, e, f) {
            "undefined" === typeof d && (d = this.tileWidth);
            "undefined" === typeof e && (e = this.tileHeight);
            f = this.getLayer(f);
            a = this.game.math.snapToFloor(a, d) / d;
            c = this.game.math.snapToFloor(c, e) / e;
            return this.getTile(a, c, f)
        },
        copy: function(a, c, d, e, f) {
            f = this.getLayer(f);
            if (this.layers[f]) {
                "undefined" === typeof a && (a = 0);
                "undefined" === typeof c && (c = 0);
                "undefined" === typeof d && (d = this.layers[f].width);
                "undefined" === typeof e && (e = this.layers[f].height);
                0 >
                    a && (a = 0);
                0 > c && (c = 0);
                d > this.layers[f].width && (d = this.layers[f].width);
                e > this.layers[f].height && (e = this.layers[f].height);
                this._results.length = 0;
                this._results.push({
                    x: a,
                    y: c,
                    width: d,
                    height: e,
                    layer: f
                });
                for (var h = c; h < c + e; h++)
                    for (var k = a; k < a + d; k++) this._results.push(this.layers[f].data[h][k]);
                return this._results
            }
            this._results.length = 0
        },
        paste: function(a, c, d, e) {
            "undefined" === typeof a && (a = 0);
            "undefined" === typeof c && (c = 0);
            e = this.getLayer(e);
            if (d && !(2 > d.length)) {
                a = d[1].x - a;
                c = d[1].y - c;
                for (var f = 1; f < d.length; f++) this.layers[e].data[c +
                    d[f].y][a + d[f].x].copy(d[f]);
                this.layers[e].dirty = !0;
                this.calculateFaces(e)
            }
        },
        swap: function(a, c, d, e, f, h, k) {
            k = this.getLayer(k);
            this.copy(d, e, f, h, k);
            2 > this._results.length || (this._tempA = a, this._tempB = c, this._results.forEach(this.swapHandler, this), this.paste(d, e, this._results, k))
        },
        swapHandler: function(a, c) {
            a.index === this._tempA && (this._results[c].index = this._tempB);
            a.index === this._tempB && (this._results[c].index = this._tempA)
        },
        forEach: function(a, c, d, e, f, h, k) {
            k = this.getLayer(k);
            this.copy(d, e, f, h, k);
            2 > this._results.length ||
                (this._results.forEach(a, c), this.paste(d, e, this._results, k))
        },
        replace: function(a, c, d, e, f, h, k) {
            k = this.getLayer(k);
            this.copy(d, e, f, h, k);
            if (!(2 > this._results.length)) {
                for (f = 1; f < this._results.length; f++) this._results[f].index === a && (this._results[f].index = c);
                this.paste(d, e, this._results, k)
            }
        },
        random: function(a, c, d, e, f) {
            f = this.getLayer(f);
            this.copy(a, c, d, e, f);
            if (!(2 > this._results.length)) {
                d = [];
                for (e = 1; e < this._results.length; e++)
                    if (this._results[e].index) {
                        var h = this._results[e].index; - 1 === d.indexOf(h) && d.push(h)
                    }
                for (e =
                    1; e < this._results.length; e++) this._results[e].index = this.game.rnd.pick(d);
                this.paste(a, c, this._results, f)
            }
        },
        shuffle: function(a, b, d, e, f) {
            f = this.getLayer(f);
            this.copy(a, b, d, e, f);
            if (!(2 > this._results.length)) {
                d = [];
                for (e = 1; e < this._results.length; e++) this._results[e].index && d.push(this._results[e].index);
                c.Utils.shuffle(d);
                for (e = 1; e < this._results.length; e++) this._results[e].index = d[e - 1];
                this.paste(a, b, this._results, f)
            }
        },
        fill: function(a, c, d, e, f, h) {
            h = this.getLayer(h);
            this.copy(c, d, e, f, h);
            if (!(2 > this._results.length)) {
                for (e =
                    1; e < this._results.length; e++) this._results[e].index = a;
                this.paste(c, d, this._results, h)
            }
        },
        removeAllLayers: function() {
            this.currentLayer = this.layers.length = 0
        },
        dump: function() {
            for (var a = "", c = [""], d = 0; d < this.layers[this.currentLayer].height; d++) {
                for (var e = 0; e < this.layers[this.currentLayer].width; e++) a += "%c  ", 1 < this.layers[this.currentLayer].data[d][e] ? this.debugMap[this.layers[this.currentLayer].data[d][e]] ? c.push("background: " + this.debugMap[this.layers[this.currentLayer].data[d][e]]) : c.push("background: #ffffff") :
                    c.push("background: rgb(0, 0, 0)");
                a += "\n"
            }
            c[0] = a;
            console.log.apply(console, c)
        },
        destroy: function() {
            this.removeAllLayers();
            this.data = [];
            this.game = null
        }
    };
    c.Tilemap.prototype.constructor = c.Tilemap;
    Object.defineProperty(c.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer]
        },
        set: function(a) {
            a !== this.currentLayer && this.setLayer(a)
        }
    });
    c.TilemapLayer = function(a, b, d, e, f) {
        this.game = a;
        this.map = b;
        this.index = d;
        this.layer = b.layers[d];
        this.canvas = c.Canvas.create(e, f, "", !0);
        this.context =
            this.canvas.getContext("2d");
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new c.Frame(0, 0, 0, e, f, "tilemapLayer", a.rnd.uuid());
        c.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame);
        this.name = "";
        this.type = c.TILEMAPLAYER;
        this.fixedToCamera = !0;
        this.cameraOffset = new c.Point(0, 0);
        this.tileColor = "rgb(255, 255, 255)";
        this.debug = !1;
        this.debugAlpha = 0.5;
        this.debugColor = "rgba(0, 255, 0, 1)";
        this.debugFill = !1;
        this.debugFillColor =
            "rgba(0, 255, 0, 0.2)";
        this.debugCallbackColor = "rgba(255, 0, 0, 1)";
        this.scrollFactorY = this.scrollFactorX = 1;
        this.dirty = !0;
        this.rayStepRate = 4;
        this._mc = {
            cw: b.tileWidth,
            ch: b.tileHeight,
            ga: 1,
            dx: 0,
            dy: 0,
            dw: 0,
            dh: 0,
            tx: 0,
            ty: 0,
            tw: 0,
            th: 0,
            tl: 0,
            maxX: 0,
            maxY: 0,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0
        };
        this._results = [];
        this.updateMax()
    };
    c.TilemapLayer.prototype = Object.create(c.Image.prototype);
    c.TilemapLayer.prototype.constructor = c.TilemapLayer;
    c.TilemapLayer.prototype.postUpdate = function() {
        c.Image.prototype.postUpdate.call(this);
        this.scrollX = this.game.camera.x * this.scrollFactorX;
        this.scrollY = this.game.camera.y * this.scrollFactorY;
        this.render();
        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    };
    c.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels)
    };
    c.TilemapLayer.prototype._fixX = function(a) {
        0 > a && (a = 0);
        return 1 ===
            this.scrollFactorX ? a : this._mc.x + (a - this._mc.x / this.scrollFactorX)
    };
    c.TilemapLayer.prototype._unfixX = function(a) {
        return 1 === this.scrollFactorX ? a : this._mc.x / this.scrollFactorX + (a - this._mc.x)
    };
    c.TilemapLayer.prototype._fixY = function(a) {
        0 > a && (a = 0);
        return 1 === this.scrollFactorY ? a : this._mc.y + (a - this._mc.y / this.scrollFactorY)
    };
    c.TilemapLayer.prototype._unfixY = function(a) {
        return 1 === this.scrollFactorY ? a : this._mc.y / this.scrollFactorY + (a - this._mc.y)
    };
    c.TilemapLayer.prototype.getTileX = function(a) {
        return this.game.math.snapToFloor(this._fixX(a),
            this.map.tileWidth) / this.map.tileWidth
    };
    c.TilemapLayer.prototype.getTileY = function(a) {
        return this.game.math.snapToFloor(this._fixY(a), this.map.tileHeight) / this.map.tileHeight
    };
    c.TilemapLayer.prototype.getTileXY = function(a, c, d) {
        d.x = this.getTileX(a);
        d.y = this.getTileY(c);
        return d
    };
    c.TilemapLayer.prototype.getRayCastTiles = function(a, c, d, e) {
        if ("undefined" === typeof c || null === c) c = this.rayStepRate;
        "undefined" === typeof d && (d = !1);
        "undefined" === typeof e && (e = !1);
        d = this.getTiles(a.x, a.y, a.width, a.height, d, e);
        if (0 === d.length) return [];
        a = a.coordinatesOnLine(c);
        c = a.length;
        e = [];
        for (var f = 0; f < d.length; f++)
            for (var h = 0; h < c; h++)
                if (d[f].containsPoint(a[h][0], a[h][1])) {
                    e.push(d[f]);
                    break
                }
        return e
    };
    c.TilemapLayer.prototype.getTiles = function(a, c, d, e, f, h) {
        "undefined" === typeof f && (f = !1);
        "undefined" === typeof h && (h = !1);
        a = this._fixX(a);
        c = this._fixY(c);
        d > this.layer.widthInPixels && (d = this.layer.widthInPixels);
        e > this.layer.heightInPixels && (e = this.layer.heightInPixels);
        this._mc.tx = this.game.math.snapToFloor(a, this._mc.cw) /
            this._mc.cw;
        this._mc.ty = this.game.math.snapToFloor(c, this._mc.ch) / this._mc.ch;
        this._mc.tw = (this.game.math.snapToCeil(d, this._mc.cw) + this._mc.cw) / this._mc.cw;
        this._mc.th = (this.game.math.snapToCeil(e, this._mc.ch) + this._mc.ch) / this._mc.ch;
        this._results.length = 0;
        for (a = this._mc.ty; a < this._mc.ty + this._mc.th; a++)
            for (c = this._mc.tx; c < this._mc.tx + this._mc.tw; c++) this.layer.data[a] && this.layer.data[a][c] && (!f && !h || this.layer.data[a][c].isInteresting(f, h)) && this._results.push(this.layer.data[a][c]);
        return this._results
    };
    c.TilemapLayer.prototype.updateMax = function() {
        this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1;
        this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1;
        this.layer && (this._mc.maxX > this.layer.width && (this._mc.maxX = this.layer.width), this._mc.maxY > this.layer.height && (this._mc.maxY = this.layer.height));
        this.dirty = !0
    };
    c.TilemapLayer.prototype.render = function() {
        this.layer.dirty && (this.dirty = !0);
        if (this.dirty && this.visible) {
            this._mc.prevX = this._mc.dx;
            this._mc.prevY =
                this._mc.dy;
            this._mc.dx = -(this._mc.x - this._mc.startX * this.map.tileWidth);
            this._mc.dy = -(this._mc.y - this._mc.startY * this.map.tileHeight);
            this._mc.tx = this._mc.dx;
            this._mc.ty = this._mc.dy;
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.context.fillStyle = this.tileColor;
            var a, b;
            this.debug && (this.context.globalAlpha = this.debugAlpha);
            for (var d = this._mc.startY, e = this._mc.startY + this._mc.maxY; d < e; d++) {
                this._column = this.layer.data[d];
                for (var f = this._mc.startX, h = this._mc.startX + this._mc.maxX; f <
                    h; f++) this._column[f] && (a = this._column[f], -1 < a.index && (b = this.map.tilesets[this.map.tiles[a.index][2]], !1 === this.debug && a.alpha !== this.context.globalAlpha && (this.context.globalAlpha = a.alpha), b.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), a.index), a.debug && (this.context.fillStyle = "rgba(0, 255, 0, 0.4)", this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight)))), this._mc.tx += this.map.tileWidth;
                this._mc.tx = this._mc.dx;
                this._mc.ty +=
                    this.map.tileHeight
            }
            this.debug && (this.context.globalAlpha = 1, this.renderDebug());
            this.game.renderType === c.WEBGL && PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
            this.dirty = !1;
            this.layer.dirty = !1;
            return !0
        }
    };
    c.TilemapLayer.prototype.renderDebug = function() {
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.strokeStyle = this.debugColor;
        this.context.fillStyle = this.debugFillColor;
        for (var a = this._mc.startY, c = this._mc.startY + this._mc.maxY; a < c; a++) {
            this._column = this.layer.data[a];
            for (var d =
                    this._mc.startX, e = this._mc.startX + this._mc.maxX; d < e; d++) {
                var f = this._column[d];
                if (f && (f.faceTop || f.faceBottom || f.faceLeft || f.faceRight)) this._mc.tx = Math.floor(this._mc.tx), this.debugFill && this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch), this.context.beginPath(), f.faceTop && (this.context.moveTo(this._mc.tx, this._mc.ty), this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty)), f.faceBottom && (this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch), this.context.lineTo(this._mc.tx +
                    this._mc.cw, this._mc.ty + this._mc.ch)), f.faceLeft && (this.context.moveTo(this._mc.tx, this._mc.ty), this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch)), f.faceRight && (this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty), this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch)), this.context.stroke();
                this._mc.tx += this.map.tileWidth
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight
        }
    };
    Object.defineProperty(c.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._mc.x
        },
        set: function(a) {
            a !==
                this._mc.x && (0 <= a && this.layer.widthInPixels > this.width) && (this._mc.x = a, this._mc.x > this.layer.widthInPixels - this.width && (this._mc.x = this.layer.widthInPixels - this.width), this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth), 0 > this._mc.startX && (this._mc.startX = 0), this._mc.startX + this._mc.maxX > this.layer.width && (this._mc.startX = this.layer.width - this._mc.maxX), this.dirty = !0)
        }
    });
    Object.defineProperty(c.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._mc.y
        },
        set: function(a) {
            a !==
                this._mc.y && (0 <= a && this.layer.heightInPixels > this.height) && (this._mc.y = a, this._mc.y > this.layer.heightInPixels - this.height && (this._mc.y = this.layer.heightInPixels - this.height), this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight), 0 > this._mc.startY && (this._mc.startY = 0), this._mc.startY + this._mc.maxY > this.layer.height && (this._mc.startY = this.layer.height - this._mc.maxY), this.dirty = !0)
        }
    });
    Object.defineProperty(c.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw
        },
        set: function(a) {
            this._mc.cw =
                a;
            this.dirty = !0
        }
    });
    Object.defineProperty(c.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch
        },
        set: function(a) {
            this._mc.ch = a;
            this.dirty = !0
        }
    });
    c.TilemapParser = {
        parse: function(a, b, d, e, f, h) {
            "undefined" === typeof d && (d = 32);
            "undefined" === typeof e && (e = 32);
            "undefined" === typeof f && (f = 10);
            "undefined" === typeof h && (h = 10);
            if ("undefined" === typeof b) return this.getEmptyData();
            if (null === b) return this.getEmptyData(d, e, f, h);
            if (a = a.cache.getTilemapData(b)) {
                if (a.format === c.Tilemap.CSV) return this.parseCSV(b,
                    a.data, d, e);
                if (!a.format || a.format === c.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + b)
        },
        parseCSV: function(a, b, d, e) {
            var f = this.getEmptyData();
            b = b.trim();
            var h = [];
            b = b.split("\n");
            for (var k = b.length, g = 0, l = 0; l < b.length; l++) {
                h[l] = [];
                for (var m = b[l].split(","), n = 0; n < m.length; n++) h[l][n] = new c.Tile(f.layers[0], parseInt(m[n], 10), n, l, d, e);
                0 === g && (g = m.length)
            }
            f.format = c.Tilemap.CSV;
            f.name = a;
            f.width = g;
            f.height = k;
            f.tileWidth =
                d;
            f.tileHeight = e;
            f.widthInPixels = g * d;
            f.heightInPixels = k * e;
            f.layers[0].width = g;
            f.layers[0].height = k;
            f.layers[0].widthInPixels = f.widthInPixels;
            f.layers[0].heightInPixels = f.heightInPixels;
            f.layers[0].data = h;
            return f
        },
        getEmptyData: function(a, c, d, e) {
            var f = {
                width: 0,
                height: 0,
                tileWidth: 0,
                tileHeight: 0
            };
            "undefined" !== typeof a && null !== a && (f.tileWidth = a);
            "undefined" !== typeof c && null !== c && (f.tileHeight = c);
            "undefined" !== typeof d && null !== d && (f.width = d);
            "undefined" !== typeof e && null !== e && (f.height = e);
            f.orientation =
                "orthogonal";
            f.version = "1";
            f.properties = {};
            f.widthInPixels = 0;
            f.heightInPixels = 0;
            a = [];
            a.push({
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: !0,
                properties: {},
                indexes: [],
                callbacks: [],
                data: []
            });
            f.layers = a;
            f.images = [];
            f.objects = {};
            f.collision = {};
            f.tilesets = [];
            f.tiles = [];
            return f
        },
        parseTiledJSON: function(a) {
            function b(a, c) {
                var b = {},
                    e;
                for (e in c) {
                    var d = c[e];
                    b[d] = a[d]
                }
                return b
            }
            if ("orthogonal" !== a.orientation) return console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser"),
                null;
            var d = {};
            d.width = a.width;
            d.height = a.height;
            d.tileWidth = a.tilewidth;
            d.tileHeight = a.tileheight;
            d.orientation = a.orientation;
            d.format = c.Tilemap.TILED_JSON;
            d.version = a.version;
            d.properties = a.properties;
            d.widthInPixels = d.width * d.tileWidth;
            d.heightInPixels = d.height * d.tileHeight;
            for (var e = [], f = 0; f < a.layers.length; f++)
                if ("tilelayer" === a.layers[f].type) {
                    var h = {
                        name: a.layers[f].name,
                        x: a.layers[f].x,
                        y: a.layers[f].y,
                        width: a.layers[f].width,
                        height: a.layers[f].height,
                        widthInPixels: a.layers[f].width * a.tilewidth,
                        heightInPixels: a.layers[f].height * a.tileheight,
                        alpha: a.layers[f].opacity,
                        visible: a.layers[f].visible,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: []
                    };
                    a.layers[f].properties && (h.properties = a.layers[f].properties);
                    for (var k = 0, g = [], l = [], m = 0, n = a.layers[f].data.length; m < n; m++) 0 < a.layers[f].data[m] ? g.push(new c.Tile(h, a.layers[f].data[m], k, l.length, a.tilewidth, a.tileheight)) : g.push(new c.Tile(h, -1, k, l.length, a.tilewidth, a.tileheight)), k++, k === a.layers[f].width && (l.push(g), k = 0, g = []);
                    h.data = l;
                    e.push(h)
                }
            d.layers =
                e;
            k = [];
            for (f = 0; f < a.layers.length; f++) "imagelayer" === a.layers[f].type && (m = {
                name: a.layers[f].name,
                image: a.layers[f].image,
                x: a.layers[f].x,
                y: a.layers[f].y,
                alpha: a.layers[f].opacity,
                visible: a.layers[f].visible,
                properties: {}
            }, a.layers[f].properties && (m.properties = a.layers[f].properties), k.push(m));
            d.images = k;
            k = [];
            for (f = 0; f < a.tilesets.length; f++) n = a.tilesets[f], m = new c.Tileset(n.name, n.firstgid, n.tilewidth, n.tileheight, n.margin, n.spacing, n.properties), n.tileproperties && (m.tileProperties = n.tileproperties),
                m.rows = Math.round((n.imageheight - n.margin) / (n.tileheight + n.spacing)), m.columns = Math.round((n.imagewidth - n.margin) / (n.tilewidth + n.spacing)), m.total = m.rows * m.columns, 0 !== m.rows % 1 || 0 !== m.columns % 1 ? console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.") : k.push(m);
            d.tilesets = k;
            k = {};
            m = {};
            for (f = 0; f < a.layers.length; f++)
                if ("objectgroup" === a.layers[f].type) {
                    k[a.layers[f].name] = [];
                    m[a.layers[f].name] = [];
                    e = 0;
                    for (n =
                        a.layers[f].objects.length; e < n; e++)
                        if (a.layers[f].objects[e].gid) h = {
                            gid: a.layers[f].objects[e].gid,
                            name: a.layers[f].objects[e].name,
                            x: a.layers[f].objects[e].x,
                            y: a.layers[f].objects[e].y,
                            visible: a.layers[f].objects[e].visible,
                            properties: a.layers[f].objects[e].properties
                        }, k[a.layers[f].name].push(h);
                        else if (a.layers[f].objects[e].polyline) {
                        h = {
                            name: a.layers[f].objects[e].name,
                            x: a.layers[f].objects[e].x,
                            y: a.layers[f].objects[e].y,
                            width: a.layers[f].objects[e].width,
                            height: a.layers[f].objects[e].height,
                            visible: a.layers[f].objects[e].visible,
                            properties: a.layers[f].objects[e].properties,
                            polyline: []
                        };
                        for (g = 0; g < a.layers[f].objects[e].polyline.length; g++) h.polyline.push([a.layers[f].objects[e].polyline[g].x, a.layers[f].objects[e].polyline[g].y]);
                        m[a.layers[f].name].push(h)
                    } else {
                        if (a.layers[f].objects[e].polygon) {
                            h = b(a.layers[f].objects[e], ["name", "x", "y", "visible", "properties"]);
                            h.polygon = [];
                            for (g = 0; g < a.layers[f].objects[e].polygon.length; g++) h.polygon.push([a.layers[f].objects[e].polygon[g].x, a.layers[f].objects[e].polygon[g].y])
                        } else a.layers[f].objects[e].ellipse ?
                            h = b(a.layers[f].objects[e], "name ellipse x y width height visible properties".split(" ")) : (h = b(a.layers[f].objects[e], "name x y width height visible properties".split(" ")), h.rectangle = !0);
                        k[a.layers[f].name].push(h)
                    }
                }
            d.objects = k;
            d.collision = m;
            d.tiles = [];
            for (f = 0; f < d.tilesets.length; f++) {
                n = d.tilesets[f];
                a = k = n.tileMargin;
                g = h = e = 0;
                for (m = n.firstgid; m < n.firstgid + n.total; m++) {
                    d.tiles[m] = [k, a, f];
                    k += n.tileWidth + n.tileSpacing;
                    e++;
                    if (e === n.total) break;
                    h++;
                    if (h === n.columns && (k = n.tileMargin, a += n.tileHeight + n.tileSpacing,
                            h = 0, g++, g === n.rows)) break
                }
            }
            return d
        }
    };
    c.Tileset = function(a, c, d, e, f, h, k) {
        if ("undefined" === typeof d || 0 >= d) d = 32;
        if ("undefined" === typeof e || 0 >= e) e = 32;
        "undefined" === typeof f && (f = 0);
        "undefined" === typeof h && (h = 0);
        this.name = a;
        this.firstgid = c;
        this.tileWidth = d;
        this.tileHeight = e;
        this.tileMargin = f;
        this.tileSpacing = h;
        this.properties = k;
        this.image = null;
        this.total = this.columns = this.rows = 0;
        this.drawCoords = []
    };
    c.Tileset.prototype = {
        draw: function(a, c, d, e) {
            this.image && this.drawCoords[e] && a.drawImage(this.image, this.drawCoords[e][0],
                this.drawCoords[e][1], this.tileWidth, this.tileHeight, c, d, this.tileWidth, this.tileHeight)
        },
        setImage: function(a) {
            this.image = a;
            this.rows = Math.round((a.height - this.tileMargin) / (this.tileHeight + this.tileSpacing));
            this.columns = Math.round((a.width - this.tileMargin) / (this.tileWidth + this.tileSpacing));
            this.total = this.rows * this.columns;
            this.drawCoords.length = 0;
            for (var c = a = this.tileMargin, d = this.firstgid, e = 0; e < this.rows; e++) {
                for (var f = 0; f < this.columns; f++) this.drawCoords[d] = [a, c], a += this.tileWidth + this.tileSpacing,
                    d++;
                a = this.tileMargin;
                c += this.tileHeight + this.tileSpacing
            }
        },
        setSpacing: function(a, c) {
            this.tileMargin = a;
            this.tileSpacing = c;
            this.setImage(this.image)
        }
    };
    c.Tileset.prototype.constructor = c.Tileset;
    "undefined" !== typeof exports ? ("undefined" !== typeof module && module.exports && (exports = module.exports = c), exports.Phaser = c) : "undefined" !== typeof define && define.amd ? define("Phaser", this.Phaser = c) : this.Phaser = c
}).call(this);
Phaser.Physics.Ninja = function(c) {
    this.game = c;
    this.time = this.game.time;
    this.gravity = 0.2;
    this.bounds = new Phaser.Rectangle(0, 0, c.world.width, c.world.height);
    this.maxObjects = 10;
    this.maxLevels = 4;
    this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels)
};
Phaser.Physics.Ninja.prototype.constructor = Phaser.Physics.Ninja;
Phaser.Physics.Ninja.prototype = {
    enableAABB: function(c, g) {
        this.enable(c, 1, 0, 0, g)
    },
    enableCircle: function(c, g, a) {
        this.enable(c, 2, 0, g, a)
    },
    enableTile: function(c, g, a) {
        this.enable(c, 3, g, 0, a)
    },
    enable: function(c, g, a, b, d) {
        "undefined" === typeof g && (g = 1);
        "undefined" === typeof a && (a = 1);
        "undefined" === typeof b && (b = 0);
        "undefined" === typeof d && (d = !0);
        if (Array.isArray(c))
            for (var e = c.length; e--;) c[e] instanceof Phaser.Group ? this.enable(c[e].children, g, a, b, d) : (this.enableBody(c[e], g, a, b), d && (c[e].hasOwnProperty("children") &&
                0 < c[e].children.length) && this.enable(c[e], g, a, b, !0));
        else c instanceof Phaser.Group ? this.enable(c.children, g, a, b, d) : (this.enableBody(c, g, a, b), d && (c.hasOwnProperty("children") && 0 < c.children.length) && this.enable(c.children, g, a, b, !0))
    },
    enableBody: function(c, g, a, b) {
        c.hasOwnProperty("body") && null === c.body && (c.body = new Phaser.Physics.Ninja.Body(this, c, g, a, b), c.anchor.set(0.5))
    },
    setBounds: function(c, g, a, b) {
        this.bounds.setTo(c, g, a, b)
    },
    setBoundsToWorld: function() {
        this.bounds.setTo(this.game.world.bounds.x,
            this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
    },
    clearTilemapLayerBodies: function(c, g) {
        g = c.getLayer(g);
        for (var a = c.layers[g].bodies.length; a--;) c.layers[g].bodies[a].destroy();
        c.layers[g].bodies.length = []
    },
    convertTilemap: function(c, g, a) {
        g = c.getLayer(g);
        this.clearTilemapLayerBodies(c, g);
        for (var b = 0, d = c.layers[g].height; b < d; b++)
            for (var e = 0, f = c.layers[g].width; e < f; e++) {
                var h = c.layers[g].data[b][e];
                h && a.hasOwnProperty(h.index) && (h = new Phaser.Physics.Ninja.Body(this,
                    null, 3, a[h.index], 0, h.worldX + h.centerX, h.worldY + h.centerY, h.width, h.height), c.layers[g].bodies.push(h))
            }
        return c.layers[g].bodies
    },
    overlap: function(c, g, a, b, d) {
        a = a || null;
        b = b || null;
        d = d || a;
        this._result = !1;
        this._total = 0;
        if (Array.isArray(g))
            for (var e = 0, f = g.length; e < f; e++) this.collideHandler(c, g[e], a, b, d, !0);
        else this.collideHandler(c, g, a, b, d, !0);
        return 0 < this._total
    },
    collide: function(c, g, a, b, d) {
        a = a || null;
        b = b || null;
        d = d || a;
        this._result = !1;
        this._total = 0;
        if (Array.isArray(g))
            for (var e = 0, f = g.length; e < f; e++) this.collideHandler(c,
                g[e], a, b, d, !1);
        else this.collideHandler(c, g, a, b, d, !1);
        return 0 < this._total
    },
    collideHandler: function(c, g, a, b, d, e) {
        "undefined" === typeof g && (c.type === Phaser.GROUP || c.type === Phaser.EMITTER) ? this.collideGroupVsSelf(c, a, b, d, e) : c && (g && c.exists && g.exists) && (c.type == Phaser.SPRITE || c.type == Phaser.TILESPRITE ? g.type == Phaser.SPRITE || g.type == Phaser.TILESPRITE ? this.collideSpriteVsSprite(c, g, a, b, d, e) : g.type == Phaser.GROUP || g.type == Phaser.EMITTER ? this.collideSpriteVsGroup(c, g, a, b, d, e) : g.type == Phaser.TILEMAPLAYER &&
            this.collideSpriteVsTilemapLayer(c, g, a, b, d) : c.type == Phaser.GROUP ? g.type == Phaser.SPRITE || g.type == Phaser.TILESPRITE ? this.collideSpriteVsGroup(g, c, a, b, d, e) : g.type == Phaser.GROUP || g.type == Phaser.EMITTER ? this.collideGroupVsGroup(c, g, a, b, d, e) : g.type == Phaser.TILEMAPLAYER && this.collideGroupVsTilemapLayer(c, g, a, b, d) : c.type == Phaser.TILEMAPLAYER ? g.type == Phaser.SPRITE || g.type == Phaser.TILESPRITE ? this.collideSpriteVsTilemapLayer(g, c, a, b, d) : (g.type == Phaser.GROUP || g.type == Phaser.EMITTER) && this.collideGroupVsTilemapLayer(g,
                c, a, b, d) : c.type == Phaser.EMITTER && (g.type == Phaser.SPRITE || g.type == Phaser.TILESPRITE ? this.collideSpriteVsGroup(g, c, a, b, d, e) : g.type == Phaser.GROUP || g.type == Phaser.EMITTER ? this.collideGroupVsGroup(c, g, a, b, d, e) : g.type == Phaser.TILEMAPLAYER && this.collideGroupVsTilemapLayer(c, g, a, b, d)))
    },
    collideSpriteVsSprite: function(c, g, a, b, d, e) {
        this.separate(c.body, g.body, b, d, e) && (a && a.call(d, c, g), this._total++)
    },
    collideSpriteVsGroup: function(c, g, a, b, d, e) {
        if (0 !== g.length)
            for (var f = 0, h = g.children.length; f < h; f++) g.children[f].exists &&
                (g.children[f].body && this.separate(c.body, g.children[f].body, b, d, e)) && (a && a.call(d, c, g.children[f]), this._total++)
    },
    collideGroupVsSelf: function(c, g, a, b, d) {
        if (0 !== c.length)
            for (var e = c.children.length, f = 0; f < e; f++)
                for (var h = f + 1; h <= e; h++) c.children[f] && (c.children[h] && c.children[f].exists && c.children[h].exists) && this.collideSpriteVsSprite(c.children[f], c.children[h], g, a, b, d)
    },
    collideGroupVsGroup: function(c, g, a, b, d, e) {
        if (!(0 === c.length || 0 === g.length))
            for (var f = 0, h = c.children.length; f < h; f++) c.children[f].exists &&
                this.collideSpriteVsGroup(c.children[f], g, a, b, d, e)
    },
    separate: function(c, g) {
        if (c.type !== Phaser.Physics.NINJA || g.type !== Phaser.Physics.NINJA) return !1;
        if (c.aabb && g.aabb) return c.aabb.collideAABBVsAABB(g.aabb);
        if (c.aabb && g.tile) return c.aabb.collideAABBVsTile(g.tile);
        if (c.tile && g.aabb) return g.aabb.collideAABBVsTile(c.tile);
        if (c.circle && g.tile) return c.circle.collideCircleVsTile(g.tile);
        if (c.tile && g.circle) return g.circle.collideCircleVsTile(c.tile)
    }
};
Phaser.Physics.Ninja.Body = function(c, g, a, b, d, e, f, h, k) {
    g = g || null;
    "undefined" === typeof a && (a = 1);
    "undefined" === typeof b && (b = 1);
    "undefined" === typeof d && (d = 16);
    this.sprite = g;
    this.game = c.game;
    this.type = Phaser.Physics.NINJA;
    this.system = c;
    this.shape = this.circle = this.tile = this.aabb = null;
    this.drag = 1;
    this.friction = 0.05;
    this.gravityScale = 1;
    this.bounce = 0.3;
    this.velocity = new Phaser.Point;
    this.facing = Phaser.NONE;
    this.immovable = !1;
    this.collideWorldBounds = !0;
    this.checkCollision = {
        none: !1,
        any: !0,
        up: !0,
        down: !0,
        left: !0,
        right: !0
    };
    this.touching = {
        none: !0,
        up: !1,
        down: !1,
        left: !1,
        right: !1
    };
    this.wasTouching = {
        none: !0,
        up: !1,
        down: !1,
        left: !1,
        right: !1
    };
    this.maxSpeed = 8;
    g && (e = g.x, f = g.y, h = g.width, k = g.height, 0 === g.anchor.x && (e += 0.5 * g.width), 0 === g.anchor.y && (f += 0.5 * g.height));
    1 === a ? this.shape = this.aabb = new Phaser.Physics.Ninja.AABB(this, e, f, h, k) : 2 === a ? this.shape = this.circle = new Phaser.Physics.Ninja.Circle(this, e, f, d) : 3 === a && (this.shape = this.tile = new Phaser.Physics.Ninja.Tile(this, e, f, h, k, b))
};
Phaser.Physics.Ninja.Body.prototype = {
    preUpdate: function() {
        this.wasTouching.none = this.touching.none;
        this.wasTouching.up = this.touching.up;
        this.wasTouching.down = this.touching.down;
        this.wasTouching.left = this.touching.left;
        this.wasTouching.right = this.touching.right;
        this.touching.none = !0;
        this.touching.up = !1;
        this.touching.down = !1;
        this.touching.left = !1;
        this.touching.right = !1;
        this.shape.integrate();
        this.collideWorldBounds && this.shape.collideWorldBounds()
    },
    postUpdate: function() {
        this.sprite && (this.sprite.type ===
            Phaser.TILESPRITE ? (this.sprite.x = this.shape.pos.x - this.shape.xw, this.sprite.y = this.shape.pos.y - this.shape.yw) : (this.sprite.x = this.shape.pos.x, this.sprite.y = this.shape.pos.y));
        0 > this.velocity.x ? this.facing = Phaser.LEFT : 0 < this.velocity.x && (this.facing = Phaser.RIGHT);
        0 > this.velocity.y ? this.facing = Phaser.UP : 0 < this.velocity.y && (this.facing = Phaser.DOWN)
    },
    setZeroVelocity: function() {
        this.shape.oldpos.x = this.shape.pos.x;
        this.shape.oldpos.y = this.shape.pos.y
    },
    moveTo: function(c, g) {
        var a = c * this.game.time.physicsElapsed;
        g = this.game.math.degToRad(g);
        this.shape.pos.x = this.shape.oldpos.x + a * Math.cos(g);
        this.shape.pos.y = this.shape.oldpos.y + a * Math.sin(g)
    },
    moveFrom: function(c, g) {
        var a = -c * this.game.time.physicsElapsed;
        g = this.game.math.degToRad(g);
        this.shape.pos.x = this.shape.oldpos.x + a * Math.cos(g);
        this.shape.pos.y = this.shape.oldpos.y + a * Math.sin(g)
    },
    moveLeft: function(c) {
        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + -c * this.game.time.physicsElapsed))
    },
    moveRight: function(c) {
        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + c * this.game.time.physicsElapsed))
    },
    moveUp: function(c) {
        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + -c * this.game.time.physicsElapsed))
    },
    moveDown: function(c) {
        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + c * this.game.time.physicsElapsed))
    },
    reset: function() {
        this.velocity.set(0);
        this.shape.pos.x = this.sprite.x;
        this.shape.pos.y = this.sprite.y;
        this.shape.oldpos.copyFrom(this.shape.pos)
    },
    deltaAbsX: function() {
        return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
    },
    deltaAbsY: function() {
        return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
    },
    deltaX: function() {
        return this.shape.pos.x - this.shape.oldpos.x
    },
    deltaY: function() {
        return this.shape.pos.y - this.shape.oldpos.y
    },
    destroy: function() {
        this.circle = this.tile = this.aabb = this.system = this.sprite = null;
        this.shape.destroy();
        this.shape = null
    }
};
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "x", {
    get: function() {
        return this.shape.pos.x
    },
    set: function(c) {
        this.shape.pos.x = c
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "y", {
    get: function() {
        return this.shape.pos.y
    },
    set: function(c) {
        this.shape.pos.y = c
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "width", {
    get: function() {
        return this.shape.width
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "height", {
    get: function() {
        return this.shape.height
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "bottom", {
    get: function() {
        return this.shape.pos.y + this.shape.yw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "right", {
    get: function() {
        return this.shape.pos.x + this.shape.xw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "speed", {
    get: function() {
        return Math.sqrt(this.shape.velocity.x * this.shape.velocity.x + this.shape.velocity.y * this.shape.velocity.y)
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "angle", {
    get: function() {
        return Math.atan2(this.shape.velocity.y, this.shape.velocity.x)
    }
});
Phaser.Physics.Ninja.AABB = function(c, g, a, b, d) {
    this.body = c;
    this.system = c.system;
    this.pos = new Phaser.Point(g, a);
    this.oldpos = new Phaser.Point(g, a);
    this.xw = Math.abs(b / 2);
    this.yw = Math.abs(d / 2);
    this.width = b;
    this.height = d;
    this.oV = this.oH = 0;
    this.velocity = new Phaser.Point;
    this.aabbTileProjections = {};
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projAABB_Full;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projAABB_45Deg;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] =
        this.projAABB_Concave;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projAABB_Convex;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projAABB_22DegS;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projAABB_22DegB;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projAABB_67DegS;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projAABB_67DegB;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] =
        this.projAABB_Half
};
Phaser.Physics.Ninja.AABB.prototype.constructor = Phaser.Physics.Ninja.AABB;
Phaser.Physics.Ninja.AABB.COL_NONE = 0;
Phaser.Physics.Ninja.AABB.COL_AXIS = 1;
Phaser.Physics.Ninja.AABB.COL_OTHER = 2;
Phaser.Physics.Ninja.AABB.prototype = {
    integrate: function() {
        var c = this.pos.x,
            g = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - c, this.pos.y - g);
        this.oldpos.set(c, g)
    },
    reportCollisionVsWorld: function(c, g, a, b) {
        var d = this.pos,
            e = this.oldpos,
            f = d.x - e.x,
            h = d.y - e.y,
            k = f * a + h * b,
            p = k * a,
            l = k * b;
        0 > k ? (f = (f - p) * this.body.friction, h = (h - l) * this.body.friction,
            k = 1 + this.body.bounce, p *= k, l *= k, 1 === a ? this.body.touching.left = !0 : -1 === a && (this.body.touching.right = !0), 1 === b ? this.body.touching.up = !0 : -1 === b && (this.body.touching.down = !0)) : p = l = f = h = 0;
        d.x += c;
        d.y += g;
        e.x += c + p + f;
        e.y += g + l + h
    },
    reverse: function() {
        var c = this.pos.x - this.oldpos.x,
            g = this.pos.y - this.oldpos.y;
        this.oldpos.x < this.pos.x ? this.oldpos.x = this.pos.x + c : this.oldpos.x > this.pos.x && (this.oldpos.x = this.pos.x - c);
        this.oldpos.y < this.pos.y ? this.oldpos.y = this.pos.y + g : this.oldpos.y > this.pos.y && (this.oldpos.y = this.pos.y -
            g)
    },
    reportCollisionVsBody: function(c, g, a, b, d) {
        a = (this.pos.x - this.oldpos.x) * a + (this.pos.y - this.oldpos.y) * b;
        this.body.immovable && d.body.immovable ? (c *= 0.5, g *= 0.5, this.pos.add(c, g), this.oldpos.set(this.pos.x, this.pos.y), d.pos.subtract(c, g), d.oldpos.set(d.pos.x, d.pos.y)) : !this.body.immovable && !d.body.immovable ? (c *= 0.5, g *= 0.5, this.pos.add(c, g), d.pos.subtract(c, g), 0 > a && (this.reverse(), d.reverse())) : this.body.immovable ? d.body.immovable || (d.pos.subtract(c, g), 0 > a && d.reverse()) : (this.pos.subtract(c, g), 0 > a &&
            this.reverse())
    },
    collideWorldBounds: function() {
        var c = this.system.bounds.x - (this.pos.x - this.xw);
        0 < c ? this.reportCollisionVsWorld(c, 0, 1, 0, null) : (c = this.pos.x + this.xw - this.system.bounds.right, 0 < c && this.reportCollisionVsWorld(-c, 0, -1, 0, null));
        c = this.system.bounds.y - (this.pos.y - this.yw);
        0 < c ? this.reportCollisionVsWorld(0, c, 0, 1, null) : (c = this.pos.y + this.yw - this.system.bounds.bottom, 0 < c && this.reportCollisionVsWorld(0, -c, 0, -1, null))
    },
    collideAABBVsAABB: function(c) {
        var g = this.pos,
            a = c.pos.y,
            b = c.yw,
            d = g.x - c.pos.x,
            e = c.xw + this.xw - Math.abs(d);
        return 0 < e && (g = g.y - a, b = b + this.yw - Math.abs(g), 0 < b) ? (e < b ? (0 > d && (e *= -1), b = 0) : 0 > g ? (e = 0, b *= -1) : e = 0, d = Math.sqrt(e * e + b * b), this.reportCollisionVsBody(e, b, e / d, b / d, c), Phaser.Physics.Ninja.AABB.COL_AXIS) : !1
    },
    collideAABBVsTile: function(c) {
        var g = this.pos.x - c.pos.x,
            a = c.xw + this.xw - Math.abs(g);
        if (0 < a) {
            var b = this.pos.y - c.pos.y,
                d = c.yw + this.yw - Math.abs(b);
            if (0 < d) return a < d ? (0 > g && (a *= -1), d = 0) : 0 > b ? (a = 0, d *= -1) : a = 0, this.resolveTile(a, d, this, c)
        }
        return !1
    },
    resolveTile: function(c, g, a, b) {
        return 0 <
            b.id ? this.aabbTileProjections[b.type](c, g, a, b) : !1
    },
    projAABB_Full: function(c, g, a, b) {
        var d = Math.sqrt(c * c + g * g);
        a.reportCollisionVsWorld(c, g, c / d, g / d, b);
        return Phaser.Physics.Ninja.AABB.COL_AXIS
    },
    projAABB_Half: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = (a.pos.x - d * a.xw - b.pos.x) * d + (a.pos.y - e * a.yw - b.pos.y) * e;
        if (0 > f) {
            var d = d * -f,
                e = e * -f,
                f = Math.sqrt(d * d + e * e),
                h = Math.sqrt(c * c + g * g);
            if (h < f) return a.reportCollisionVsWorld(c, g, c / h, g / h, b), Phaser.Physics.Ninja.AABB.COL_AXIS;
            a.reportCollisionVsWorld(d, e, b.signx, b.signy,
                b);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_45Deg: function(c, g, a, b) {
        var d = b.sx,
            e = b.sy,
            f = (a.pos.x - b.signx * a.xw - b.pos.x) * d + (a.pos.y - b.signy * a.yw - b.pos.y) * e;
        if (0 > f) {
            var d = d * -f,
                e = e * -f,
                f = Math.sqrt(d * d + e * e),
                h = Math.sqrt(c * c + g * g);
            if (h < f) return a.reportCollisionVsWorld(c, g, c / h, g / h, b), Phaser.Physics.Ninja.AABB.COL_AXIS;
            a.reportCollisionVsWorld(d, e, b.sx, b.sy);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_22DegS: function(c,
        g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = b.pos.y - (a.pos.y - e * a.yw);
        if (0 < f * e) {
            var h = b.sx,
                k = b.sy,
                d = (a.pos.x - d * a.xw - (b.pos.x + d * b.xw)) * h + (a.pos.y - e * a.yw - (b.pos.y - e * b.yw)) * k;
            if (0 > d) {
                var h = h * -d,
                    k = k * -d,
                    d = Math.sqrt(h * h + k * k),
                    e = Math.sqrt(c * c + g * g),
                    p = Math.abs(f);
                if (e < d) {
                    if (p < e) return a.reportCollisionVsWorld(0, f, 0, f / p, b), Phaser.Physics.Ninja.AABB.COL_OTHER;
                    a.reportCollisionVsWorld(c, g, c / e, g / e, b);
                    return Phaser.Physics.Ninja.AABB.COL_AXIS
                }
                p < d ? a.reportCollisionVsWorld(0, f, 0, f / p, b) : a.reportCollisionVsWorld(h, k, b.sx, b.sy,
                    b);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_22DegB: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = b.sx,
            h = b.sy,
            d = (a.pos.x - d * a.xw - (b.pos.x - d * b.xw)) * f + (a.pos.y - e * a.yw - (b.pos.y + e * b.yw)) * h;
        if (0 > d) {
            f *= -d;
            h *= -d;
            d = Math.sqrt(f * f + h * h);
            e = Math.sqrt(c * c + g * g);
            if (e < d) return a.reportCollisionVsWorld(c, g, c / e, g / e, b), Phaser.Physics.Ninja.AABB.COL_AXIS;
            a.reportCollisionVsWorld(f, h, b.sx, b.sy, b);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_67DegS: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = b.pos.x - (a.pos.x - d * a.xw);
        if (0 < f * d) {
            var h = b.sx,
                k = b.sy,
                d = (a.pos.x - d * a.xw - (b.pos.x - d * b.xw)) * h + (a.pos.y - e * a.yw - (b.pos.y + e * b.yw)) * k;
            if (0 > d) {
                var h = h * -d,
                    k = k * -d,
                    d = Math.sqrt(h * h + k * k),
                    e = Math.sqrt(c * c + g * g),
                    p = Math.abs(f);
                if (e < d) {
                    if (p < e) return a.reportCollisionVsWorld(f, 0, f / p, 0, b), Phaser.Physics.Ninja.AABB.COL_OTHER;
                    a.reportCollisionVsWorld(c, g, c / e, g / e, b);
                    return Phaser.Physics.Ninja.AABB.COL_AXIS
                }
                p < d ? a.reportCollisionVsWorld(f, 0, f / p, 0, b) : a.reportCollisionVsWorld(h,
                    k, b.sx, b.sy, b);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_67DegB: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = b.sx,
            h = b.sy,
            d = (a.pos.x - d * a.xw - (b.pos.x + d * b.xw)) * f + (a.pos.y - e * a.yw - (b.pos.y - e * b.yw)) * h;
        if (0 > d) {
            f *= -d;
            h *= -d;
            d = Math.sqrt(f * f + h * h);
            e = Math.sqrt(c * c + g * g);
            if (e < d) return a.reportCollisionVsWorld(c, g, c / e, g / e, b), Phaser.Physics.Ninja.AABB.COL_AXIS;
            a.reportCollisionVsWorld(f, h, b.sx, b.sy, b);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_Convex: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            f = a.pos.x - d * a.xw - (b.pos.x - d * b.xw),
            h = a.pos.y - e * a.yw - (b.pos.y - e * b.yw),
            k = Math.sqrt(f * f + h * h),
            p = 2 * b.xw,
            p = Math.sqrt(p * p + 0) - k;
        return 0 > d * f || 0 > e * h ? (d = Math.sqrt(c * c + g * g), a.reportCollisionVsWorld(c, g, c / d, g / d, b), Phaser.Physics.Ninja.AABB.COL_AXIS) : 0 < p ? (f /= k, h /= k, a.reportCollisionVsWorld(f * p, h * p, f, h, b), Phaser.Physics.Ninja.AABB.COL_OTHER) : Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_Concave: function(c, g, a, b) {
        var d = b.signx,
            e = b.signy,
            d = b.pos.x + d * b.xw - (a.pos.x -
                d * a.xw),
            e = b.pos.y + e * b.yw - (a.pos.y - e * a.yw),
            f = 2 * b.xw,
            h = Math.sqrt(f * f + 0),
            f = Math.sqrt(d * d + e * e),
            h = f - h;
        if (0 < h) {
            var k = Math.sqrt(c * c + g * g);
            if (k < h) return a.reportCollisionVsWorld(c, g, c / k, g / k, b), Phaser.Physics.Ninja.AABB.COL_AXIS;
            d /= f;
            e /= f;
            a.reportCollisionVsWorld(d * h, e * h, d, e, b);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    destroy: function() {
        this.system = this.body = null
    }
};
Phaser.Physics.Ninja.Tile = function(c, g, a, b, d, e) {
    "undefined" === typeof e && (e = Phaser.Physics.Ninja.Tile.EMPTY);
    this.body = c;
    this.system = c.system;
    this.id = e;
    this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY;
    this.pos = new Phaser.Point(g, a);
    this.oldpos = new Phaser.Point(g, a);
    1 < this.id && 30 > this.id && (d = b);
    this.xw = Math.abs(b / 2);
    this.yw = Math.abs(d / 2);
    this.width = b;
    this.height = d;
    this.velocity = new Phaser.Point;
    this.sy = this.sx = this.signy = this.signx = 0;
    this.body.gravityScale = 0;
    this.body.collideWorldBounds = !1;
    0 < this.id &&
        this.setType(this.id)
};
Phaser.Physics.Ninja.Tile.prototype.constructor = Phaser.Physics.Ninja.Tile;
Phaser.Physics.Ninja.Tile.prototype = {
    integrate: function() {
        var c = this.pos.x,
            g = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - c, this.pos.y - g);
        this.oldpos.set(c, g)
    },
    collideWorldBounds: function() {
        var c = this.system.bounds.x - (this.pos.x - this.xw);
        0 < c ? this.reportCollisionVsWorld(c, 0, 1, 0, null) : (c = this.pos.x + this.xw - this.system.bounds.right,
            0 < c && this.reportCollisionVsWorld(-c, 0, -1, 0, null));
        c = this.system.bounds.y - (this.pos.y - this.yw);
        0 < c ? this.reportCollisionVsWorld(0, c, 0, 1, null) : (c = this.pos.y + this.yw - this.system.bounds.bottom, 0 < c && this.reportCollisionVsWorld(0, -c, 0, -1, null))
    },
    reportCollisionVsWorld: function(c, g, a, b) {
        var d = this.pos,
            e = this.oldpos,
            f = d.x - e.x,
            h = d.y - e.y,
            k = f * a + h * b,
            p = k * a,
            l = k * b;
        0 > k ? (f = (f - p) * this.body.friction, h = (h - l) * this.body.friction, k = 1 + this.body.bounce, p *= k, l *= k, 1 === a ? this.body.touching.left = !0 : -1 === a && (this.body.touching.right = !0), 1 === b ? this.body.touching.up = !0 : -1 === b && (this.body.touching.down = !0)) : p = l = f = h = 0;
        d.x += c;
        d.y += g;
        e.x += c + p + f;
        e.y += g + l + h
    },
    setType: function(c) {
        c === Phaser.Physics.Ninja.Tile.EMPTY ? this.clear() : (this.id = c, this.updateType());
        return this
    },
    clear: function() {
        this.id = Phaser.Physics.Ninja.Tile.EMPTY;
        this.updateType()
    },
    destroy: function() {
        this.system = this.body = null
    },
    updateType: function() {
        if (0 === this.id) return this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY, this.sy = this.sx = this.signy = this.signx = 0, !0;
        if (this.id < Phaser.Physics.Ninja.Tile.TYPE_45DEG) this.type =
            Phaser.Physics.Ninja.Tile.TYPE_FULL, this.sy = this.sx = this.signy = this.signx = 0;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONCAVE)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_45DEG, this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn) this.signx = 1, this.signy = -1, this.sx = this.signx / Math.SQRT2, this.sy = this.signy / Math.SQRT2;
            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnn) this.signy = this.signx = -1, this.sx = this.signx / Math.SQRT2, this.sy = this.signy / Math.SQRT2;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnp) this.signx = -1, this.signy = 1, this.sx = this.signx / Math.SQRT2, this.sy = this.signy / Math.SQRT2;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpp) this.signy = this.signx = 1, this.sx = this.signx / Math.SQRT2, this.sy = this.signy / Math.SQRT2;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONVEX)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_CONCAVE, this.id == Phaser.Physics.Ninja.Tile.CONCAVEpn) this.signx = 1, this.signy = -1, this.sy = this.sx = 0;
            else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnn) this.signy = this.signx = -1, this.sy = this.sx = 0;
        else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnp) this.signx = -1, this.signy = 1, this.sy = this.sx = 0;
        else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEpp) this.signy = this.signx = 1, this.sy = this.sx = 0;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGs)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_CONVEX, this.id == Phaser.Physics.Ninja.Tile.CONVEXpn) this.signx = 1, this.signy = -1, this.sy = this.sx = 0;
            else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnn) this.signy = this.signx = -1, this.sy =
            this.sx = 0;
        else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnp) this.signx = -1, this.signy = 1, this.sy = this.sx = 0;
        else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXpp) this.signy = this.signx = 1, this.sy = this.sx = 0;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGb)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGs, this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnS) {
                this.signx = 1;
                this.signy = -1;
                var c = Math.sqrt(5);
                this.sx = 1 * this.signx / c;
                this.sy = 2 * this.signy / c
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnS) this.signy =
            this.signx = -1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpS) this.signx = -1, this.signy = 1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppS) this.signy = this.signx = 1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGs)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGb, this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnB) this.signx =
                1, this.signy = -1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnB) this.signy = this.signx = -1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpB) this.signx = -1, this.signy = 1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppB) this.signy = this.signx = 1, c = Math.sqrt(5), this.sx = 1 * this.signx / c, this.sy = 2 * this.signy /
            c;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGb)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGs, this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnS) this.signx = 1, this.signy = -1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnS) this.signy = this.signx = -1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpS) this.signx = -1, this.signy = 1, c = Math.sqrt(5),
            this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppS) this.signy = this.signx = 1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else return !1;
        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_HALF)
            if (this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGb, this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnB) this.signx = 1, this.signy = -1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnB) this.signy =
            this.signx = -1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpB) this.signx = -1, this.signy = 1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppB) this.signy = this.signx = 1, c = Math.sqrt(5), this.sx = 2 * this.signx / c, this.sy = 1 * this.signy / c;
        else return !1;
        else if (this.type = Phaser.Physics.Ninja.Tile.TYPE_HALF, this.id == Phaser.Physics.Ninja.Tile.HALFd) this.signx = 0, this.signy = -1, this.sx =
            this.signx, this.sy = this.signy;
        else if (this.id == Phaser.Physics.Ninja.Tile.HALFu) this.signx = 0, this.signy = 1, this.sx = this.signx, this.sy = this.signy;
        else if (this.id == Phaser.Physics.Ninja.Tile.HALFl) this.signx = 1, this.signy = 0, this.sx = this.signx, this.sy = this.signy;
        else if (this.id == Phaser.Physics.Ninja.Tile.HALFr) this.signx = -1, this.signy = 0, this.sx = this.signx, this.sy = this.signy;
        else return !1
    }
};
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "x", {
    get: function() {
        return this.pos.x - this.xw
    },
    set: function(c) {
        this.pos.x = c
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "y", {
    get: function() {
        return this.pos.y - this.yw
    },
    set: function(c) {
        this.pos.y = c
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "bottom", {
    get: function() {
        return this.pos.y + this.yw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "right", {
    get: function() {
        return this.pos.x + this.xw
    }
});
Phaser.Physics.Ninja.Tile.EMPTY = 0;
Phaser.Physics.Ninja.Tile.FULL = 1;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn = 2;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGnn = 3;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGnp = 4;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGpp = 5;
Phaser.Physics.Ninja.Tile.CONCAVEpn = 6;
Phaser.Physics.Ninja.Tile.CONCAVEnn = 7;
Phaser.Physics.Ninja.Tile.CONCAVEnp = 8;
Phaser.Physics.Ninja.Tile.CONCAVEpp = 9;
Phaser.Physics.Ninja.Tile.CONVEXpn = 10;
Phaser.Physics.Ninja.Tile.CONVEXnn = 11;
Phaser.Physics.Ninja.Tile.CONVEXnp = 12;
Phaser.Physics.Ninja.Tile.CONVEXpp = 13;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnS = 14;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnS = 15;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpS = 16;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGppS = 17;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnB = 18;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnB = 19;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpB = 20;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGppB = 21;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnS = 22;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnS = 23;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpS = 24;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGppS = 25;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnB = 26;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnB = 27;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpB = 28;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGppB = 29;
Phaser.Physics.Ninja.Tile.HALFd = 30;
Phaser.Physics.Ninja.Tile.HALFr = 31;
Phaser.Physics.Ninja.Tile.HALFu = 32;
Phaser.Physics.Ninja.Tile.HALFl = 33;
Phaser.Physics.Ninja.Tile.TYPE_EMPTY = 0;
Phaser.Physics.Ninja.Tile.TYPE_FULL = 1;
Phaser.Physics.Ninja.Tile.TYPE_45DEG = 2;
Phaser.Physics.Ninja.Tile.TYPE_CONCAVE = 6;
Phaser.Physics.Ninja.Tile.TYPE_CONVEX = 10;
Phaser.Physics.Ninja.Tile.TYPE_22DEGs = 14;
Phaser.Physics.Ninja.Tile.TYPE_22DEGb = 18;
Phaser.Physics.Ninja.Tile.TYPE_67DEGs = 22;
Phaser.Physics.Ninja.Tile.TYPE_67DEGb = 26;
Phaser.Physics.Ninja.Tile.TYPE_HALF = 30;
Phaser.Physics.Ninja.Circle = function(c, g, a, b) {
    this.body = c;
    this.system = c.system;
    this.pos = new Phaser.Point(g, a);
    this.oldpos = new Phaser.Point(g, a);
    this.yw = this.xw = this.radius = b;
    this.width = 2 * b;
    this.height = 2 * b;
    this.oV = this.oH = 0;
    this.velocity = new Phaser.Point;
    this.circleTileProjections = {};
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projCircle_Full;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projCircle_45Deg;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] =
        this.projCircle_Concave;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projCircle_Convex;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projCircle_22DegS;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projCircle_22DegB;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projCircle_67DegS;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projCircle_67DegB;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] =
        this.projCircle_Half
};
Phaser.Physics.Ninja.Circle.prototype.constructor = Phaser.Physics.Ninja.Circle;
Phaser.Physics.Ninja.Circle.COL_NONE = 0;
Phaser.Physics.Ninja.Circle.COL_AXIS = 1;
Phaser.Physics.Ninja.Circle.COL_OTHER = 2;
Phaser.Physics.Ninja.Circle.prototype = {
    integrate: function() {
        var c = this.pos.x,
            g = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - c, this.pos.y - g);
        this.oldpos.set(c, g)
    },
    reportCollisionVsWorld: function(c, g, a, b) {
        var d = this.pos,
            e = this.oldpos,
            f = d.x - e.x,
            h = d.y - e.y,
            k = f * a + h * b,
            p = k * a,
            l = k * b;
        0 > k ? (f = (f - p) * this.body.friction, h = (h - l) * this.body.friction,
            k = 1 + this.body.bounce, p *= k, l *= k, 1 === a ? this.body.touching.left = !0 : -1 === a && (this.body.touching.right = !0), 1 === b ? this.body.touching.up = !0 : -1 === b && (this.body.touching.down = !0)) : p = l = f = h = 0;
        d.x += c;
        d.y += g;
        e.x += c + p + f;
        e.y += g + l + h
    },
    collideWorldBounds: function() {
        var c = this.system.bounds.x - (this.pos.x - this.radius);
        0 < c ? this.reportCollisionVsWorld(c, 0, 1, 0, null) : (c = this.pos.x + this.radius - this.system.bounds.right, 0 < c && this.reportCollisionVsWorld(-c, 0, -1, 0, null));
        c = this.system.bounds.y - (this.pos.y - this.radius);
        0 < c ? this.reportCollisionVsWorld(0,
            c, 0, 1, null) : (c = this.pos.y + this.radius - this.system.bounds.bottom, 0 < c && this.reportCollisionVsWorld(0, -c, 0, -1, null))
    },
    collideCircleVsTile: function(c) {
        var g = this.pos,
            a = this.radius,
            b = c.pos.y,
            d = c.xw,
            e = c.yw,
            f = g.x - c.pos.x,
            h = d + a - Math.abs(f);
        if (0 < h && (g = g.y - b, a = e + a - Math.abs(g), 0 < a)) return this.oV = this.oH = 0, f < -d ? this.oH = -1 : d < f && (this.oH = 1), g < -e ? this.oV = -1 : e < g && (this.oV = 1), this.resolveCircleTile(h, a, this.oH, this.oV, this, c)
    },
    resolveCircleTile: function(c, g, a, b, d, e) {
        return 0 < e.id ? this.circleTileProjections[e.type](c,
            g, a, b, d, e) : !1
    },
    projCircle_Full: function(c, g, a, b, d, e) {
        if (0 === a) return 0 === b ? c < g ? (g = d.pos.x - e.pos.x, 0 > g ? d.reportCollisionVsWorld(-c, 0, -1, 0, e) : d.reportCollisionVsWorld(c, 0, 1, 0, e)) : (c = d.pos.y - e.pos.y, 0 > c ? d.reportCollisionVsWorld(0, -g, 0, -1, e) : d.reportCollisionVsWorld(0, g, 0, 1, e)) : d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
        if (0 === b) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
        c = e.pos.y + b * e.yw;
        g = d.pos.x - (e.pos.x + a * e.xw);
        c = d.pos.y - c;
        var f =
            Math.sqrt(g * g + c * c),
            h = d.radius - f;
        return 0 < h ? (0 === f ? (g = a / Math.SQRT2, c = b / Math.SQRT2) : (g /= f, c /= f), d.reportCollisionVsWorld(g * h, c * h, g, c, e), Phaser.Physics.Ninja.Circle.COL_OTHER) : Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_45Deg: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy;
        if (0 === a)
            if (0 === b) {
                var k = e.sx,
                    p = e.sy;
                a = d.pos.x - k * d.radius - e.pos.x;
                b = d.pos.y - p * d.radius - e.pos.y;
                b = a * k + b * p;
                if (0 > b) {
                    k *= -b;
                    p *= -b;
                    c < g ? (b = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (b = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                    a = Math.sqrt(k * k + p * p);
                    if (b <
                        a) return d.reportCollisionVsWorld(c, g, c / b, g / b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                    d.reportCollisionVsWorld(k, p, e.sx, e.sy, e);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                if (0 > h * b) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                k = e.sx;
                p = e.sy;
                a = d.pos.x - (e.pos.x - f * e.xw);
                b = d.pos.y - (e.pos.y + b * e.yw);
                if (0 < (a * -p + b * k) * f * h) {
                    if (k = Math.sqrt(a * a + b * b), c = d.radius - k, 0 < c) return a /= k, b /= k, d.reportCollisionVsWorld(a * c, b * c, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
                } else if (c =
                    d.radius - Math.abs(a * k + b * p), 0 < c) return d.reportCollisionVsWorld(k * c, p * c, k, p, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        else if (0 === b) {
            if (0 > f * a) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            k = e.sx;
            p = e.sy;
            a = d.pos.x - (e.pos.x + a * e.xw);
            b = d.pos.y - (e.pos.y - h * e.yw);
            if (0 > (a * -p + b * k) * f * h) {
                if (k = Math.sqrt(a * a + b * b), c = d.radius - k, 0 < c) return a /= k, b /= k, d.reportCollisionVsWorld(a * c, b * c, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            } else if (c = d.radius - Math.abs(a * k + b * p), 0 < c) return d.reportCollisionVsWorld(k *
                c, p * c, k, p, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (!(0 < f * a + h * b) && (p = d.pos.x - (e.pos.x + a * e.xw), g = d.pos.y - (e.pos.y + b * e.yw), k = Math.sqrt(p * p + g * g), c = d.radius - k, 0 < c)) return 0 === k ? (p = a / Math.SQRT2, g = b / Math.SQRT2) : (p /= k, g /= k), d.reportCollisionVsWorld(p * c, g * c, p, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Concave: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy,
            k;
        if (0 === a)
            if (0 === b) {
                if (a = e.pos.x + f * e.xw - d.pos.x, b = e.pos.y + h * e.yw - d.pos.y, h = 2 * e.xw, f = Math.sqrt(h *
                        h + 0), h = Math.sqrt(a * a + b * b), f = h + d.radius - f, 0 < f) {
                    c < g ? (k = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (k = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                    if (k < f) return d.reportCollisionVsWorld(c, g, c / k, g / k, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                    a /= h;
                    b /= h;
                    d.reportCollisionVsWorld(a * f, b * f, a, b, e);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                if (0 > h * b) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                c = e.pos.x - f * e.xw;
                g = e.pos.y + b * e.yw;
                c = d.pos.x - c;
                g = d.pos.y - g;
                h = Math.sqrt(c * c + g * g);
                f = d.radius - h;
                if (0 <
                    f) return 0 === h ? (c = 0, g = b) : (c /= h, g /= h), d.reportCollisionVsWorld(c * f, g * f, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        else if (0 === b) {
            if (0 > f * a) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            c = e.pos.x + a * e.xw;
            g = e.pos.y - h * e.yw;
            c = d.pos.x - c;
            g = d.pos.y - g;
            h = Math.sqrt(c * c + g * g);
            f = d.radius - h;
            if (0 < f) return 0 === h ? (c = a, g = 0) : (c /= h, g /= h), d.reportCollisionVsWorld(c * f, g * f, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (!(0 < f * a + h * b) && (c = e.pos.x + a * e.xw, g = e.pos.y + b * e.yw, c = d.pos.x - c,
                g = d.pos.y - g, h = Math.sqrt(c * c + g * g), f = d.radius - h, 0 < f)) return 0 === h ? (c = a / Math.SQRT2, g = b / Math.SQRT2) : (c /= h, g /= h), d.reportCollisionVsWorld(c * f, g * f, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Convex: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy,
            k;
        if (0 === a)
            if (0 === b) {
                if (a = d.pos.x - (e.pos.x - f * e.xw), b = d.pos.y - (e.pos.y - h * e.yw), h = 2 * e.xw, f = Math.sqrt(h * h + 0), h = Math.sqrt(a * a + b * b), f = f + d.radius - h, 0 < f) {
                    c < g ? (k = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (k = g, c = 0, 0 > d.pos.y -
                        e.pos.y && (g *= -1));
                    if (k < f) return d.reportCollisionVsWorld(c, g, c / k, g / k, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                    a /= h;
                    b /= h;
                    d.reportCollisionVsWorld(a * f, b * f, a, b, e);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                if (0 > h * b) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                a = d.pos.x - (e.pos.x - f * e.xw);
                b = d.pos.y - (e.pos.y - h * e.yw);
                h = 2 * e.xw;
                f = Math.sqrt(h * h + 0);
                h = Math.sqrt(a * a + b * b);
                f = f + d.radius - h;
                if (0 < f) return a /= h, b /= h, d.reportCollisionVsWorld(a * f, b * f, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        else if (0 ===
            b) {
            if (0 > f * a) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            a = d.pos.x - (e.pos.x - f * e.xw);
            b = d.pos.y - (e.pos.y - h * e.yw);
            h = 2 * e.xw;
            f = Math.sqrt(h * h + 0);
            h = Math.sqrt(a * a + b * b);
            f = f + d.radius - h;
            if (0 < f) return a /= h, b /= h, d.reportCollisionVsWorld(a * f, b * f, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (0 < f * a + h * b) {
            if (a = d.pos.x - (e.pos.x - f * e.xw), b = d.pos.y - (e.pos.y - h * e.yw), h = 2 * e.xw, f = Math.sqrt(h * h + 0), h = Math.sqrt(a * a + b * b), f = f + d.radius - h, 0 < f) return a /= h, b /= h, d.reportCollisionVsWorld(a *
                f, b * f, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (c = d.pos.x - (e.pos.x + a * e.xw), g = d.pos.y - (e.pos.y + b * e.yw), h = Math.sqrt(c * c + g * g), f = d.radius - h, 0 < f) return 0 === h ? (c = a / Math.SQRT2, g = b / Math.SQRT2) : (c /= h, g /= h), d.reportCollisionVsWorld(c * f, g * f, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Half: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy,
            k = a * f + b * h;
        if (!(0 < k))
            if (0 === a)
                if (0 === b) {
                    if (k = d.radius, a = f, b = h, f = (d.pos.x - f * k - e.pos.x) * a + (d.pos.y - h * k - e.pos.y) *
                        b, 0 > f) {
                        a *= -f;
                        b *= -f;
                        f = Math.sqrt(a * a + b * b);
                        h = Math.sqrt(c * c + g * g);
                        if (h < f) return d.reportCollisionVsWorld(c, g, c / h, g / h, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                        d.reportCollisionVsWorld(a, b, e.signx, e.signy);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else if (0 === k) {
            c = d.pos.x - e.pos.x;
            if (0 > c * f) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            g = d.pos.y - (e.pos.y + b * e.yw);
            h = Math.sqrt(c * c + g * g);
            k = d.radius - h;
            if (0 < k) return 0 === h ? (c = f / Math.SQRT2, g = b / Math.SQRT2) : (c /= h, g /= h), d.reportCollisionVsWorld(c *
                k, g * k, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
        else if (0 === b)
            if (0 === k) {
                g = d.pos.y - e.pos.y;
                if (0 > g * h) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                c = d.pos.x - (e.pos.x + a * e.xw);
                h = Math.sqrt(c * c + g * g);
                k = d.radius - h;
                if (0 < k) return 0 === h ? (c = f / Math.SQRT2, g = b / Math.SQRT2) : (c /= h, g /= h), d.reportCollisionVsWorld(c * k, g * k, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            } else return d.reportCollisionVsWorld(c *
                a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
        else if (g = e.pos.y + b * e.yw, c = d.pos.x - (e.pos.x + a * e.xw), g = d.pos.y - g, h = Math.sqrt(c * c + g * g), k = d.radius - h, 0 < k) return 0 === h ? (c = a / Math.SQRT2, g = b / Math.SQRT2) : (c /= h, g /= h), d.reportCollisionVsWorld(c * k, g * k, c, g, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_22DegS: function(c, g, a, b, d, e) {
        var f, h = e.signx;
        f = e.signy;
        if (!(0 < f * b))
            if (0 === a)
                if (0 === b) {
                    b = e.sx;
                    var k = e.sy,
                        p = d.radius;
                    a = d.pos.x - (e.pos.x - h * e.xw);
                    var l = d.pos.y - e.pos.y,
                        m = a * -k + l * b;
                    if (0 < m * h * f) {
                        if (f = Math.sqrt(a * a + l * l), c = p - f, 0 < c) return a /= f, l /= f, d.reportCollisionVsWorld(a * c, l * c, a, l, e), Phaser.Physics.Ninja.Circle.COL_OTHER
                    } else if (f = (a - p * b) * b + (l - p * k) * k, 0 > f) {
                        b *= -f;
                        k *= -f;
                        a = Math.sqrt(b * b + k * k);
                        c < g ? (f = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (f = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                        if (f < a) return d.reportCollisionVsWorld(c, g, c / f, g / f, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                        d.reportCollisionVsWorld(b, k, e.sx, e.sy, e);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else return d.reportCollisionVsWorld(0,
                    g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
        else if (0 === b)
            if (0 > h * a) {
                g = e.pos.x - h * e.xw;
                k = e.pos.y;
                g = d.pos.x - g;
                k = d.pos.y - k;
                if (0 > k * f) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                f = Math.sqrt(g * g + k * k);
                c = d.radius - f;
                if (0 < c) return 0 === f ? (g = a / Math.SQRT2, k = b / Math.SQRT2) : (g /= f, k /= f), d.reportCollisionVsWorld(g * c, k * c, g, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            } else if (b = e.sx, k = e.sy, a = d.pos.x - (e.pos.x + a * e.xw), l = d.pos.y - (e.pos.y - f * e.yw), m = a * -k + l * b, 0 > m * h * f) {
            if (f = Math.sqrt(a *
                    a + l * l), c = d.radius - f, 0 < c) return a /= f, l /= f, d.reportCollisionVsWorld(a * c, l * c, a, l, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else {
            if (f = a * b + l * k, c = d.radius - Math.abs(f), 0 < c) return d.reportCollisionVsWorld(b * c, k * c, b, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (g = e.pos.x + a * e.xw, k = e.pos.y + b * e.yw, g = d.pos.x - g, k = d.pos.y - k, f = Math.sqrt(g * g + k * k), c = d.radius - f, 0 < c) return 0 === f ? (g = a / Math.SQRT2, k = b / Math.SQRT2) : (g /= f, k /= f), d.reportCollisionVsWorld(g * c, k * c, g, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_22DegB: function(c, g, a, b, d, e) {
        var f;
        f = e.signx;
        var h = e.signy;
        if (0 === a)
            if (0 === b) {
                a = e.sx;
                b = e.sy;
                var k = d.radius,
                    p = d.pos.x - a * k - (e.pos.x - f * e.xw),
                    k = d.pos.y - b * k - (e.pos.y + h * e.yw);
                f = p * a + k * b;
                if (0 > f) {
                    a *= -f;
                    b *= -f;
                    h = Math.sqrt(a * a + b * b);
                    c < g ? (f = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (f = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                    if (f < h) return d.reportCollisionVsWorld(c, g, c / f, g / f, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                    d.reportCollisionVsWorld(a, b, e.sx, e.sy, e);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                if (0 > h * b) return d.reportCollisionVsWorld(0,
                    g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                a = e.sx;
                b = e.sy;
                p = d.pos.x - (e.pos.x - f * e.xw);
                k = d.pos.y - (e.pos.y + h * e.yw);
                if (0 < (p * -b + k * a) * f * h) {
                    if (g = Math.sqrt(p * p + k * k), c = d.radius - g, 0 < c) return p /= g, k /= g, d.reportCollisionVsWorld(p * c, k * c, p, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
                } else if (c = d.radius - Math.abs(p * a + k * b), 0 < c) return d.reportCollisionVsWorld(a * c, b * c, a, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        else if (0 === b) {
            if (0 > f * a) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            p = d.pos.x - (e.pos.x + f * e.xw);
            k = d.pos.y - e.pos.y;
            if (0 > k * h) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            a = e.sx;
            b = e.sy;
            if (0 > (p * -b + k * a) * f * h) {
                if (g = Math.sqrt(p * p + k * k), c = d.radius - g, 0 < c) return p /= g, k /= g, d.reportCollisionVsWorld(p * c, k * c, p, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            } else if (c = d.radius - Math.abs(p * a + k * b), 0 < c) return d.reportCollisionVsWorld(a * c, b * c, e.sx, e.sy, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (0 < f * a + h * b) {
            if (c = Math.sqrt(5), a = 1 * f / c, b = 2 * h / c, k = d.radius,
                p = d.pos.x - a * k - (e.pos.x - f * e.xw), k = d.pos.y - b * k - (e.pos.y + h * e.yw), f = p * a + k * b, 0 > f) return d.reportCollisionVsWorld(-a * f, -b * f, e.sx, e.sy, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (f = d.pos.x - (e.pos.x + a * e.xw), h = d.pos.y - (e.pos.y + b * e.yw), g = Math.sqrt(f * f + h * h), c = d.radius - g, 0 < c) return 0 === g ? (f = a / Math.SQRT2, h = b / Math.SQRT2) : (f /= g, h /= g), d.reportCollisionVsWorld(f * c, h * c, f, h, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_67DegS: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy;
        if (!(0 < f * a))
            if (0 === a)
                if (0 === b) {
                    a = e.sx;
                    var k = e.sy,
                        p = d.radius,
                        l = d.pos.x - e.pos.x;
                    b = d.pos.y - (e.pos.y - h * e.yw);
                    var m = l * -k + b * a;
                    if (0 > m * f * h) {
                        if (f = Math.sqrt(l * l + b * b), g = p - f, 0 < g) return l /= f, b /= f, d.reportCollisionVsWorld(l * g, b * g, l, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
                    } else if (f = (l - p * a) * a + (b - p * k) * k, 0 > f) {
                        a *= -f;
                        k *= -f;
                        b = Math.sqrt(a * a + k * k);
                        c < g ? (f = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (f = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                        if (f < b) return d.reportCollisionVsWorld(c, g, c / f, g / f, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                        d.reportCollisionVsWorld(a, k, e.sx, e.sy, e);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else if (0 > h * b) {
            c = e.pos.x;
            k = e.pos.y - h * e.yw;
            c = d.pos.x - c;
            k = d.pos.y - k;
            if (0 > c * f) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            f = Math.sqrt(c * c + k * k);
            g = d.radius - f;
            if (0 < g) return 0 === f ? (c = a / Math.SQRT2, k = b / Math.SQRT2) : (c /= f, k /= f), d.reportCollisionVsWorld(c * g, k * g, c, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (a = e.sx, k = e.sy, l = d.pos.x - (e.pos.x - f * e.xw), b = d.pos.y - (e.pos.y + b * e.yw), m = l *
            -k + b * a, 0 < m * f * h) {
            if (f = Math.sqrt(l * l + b * b), g = d.radius - f, 0 < g) return l /= f, b /= f, d.reportCollisionVsWorld(l * g, b * g, l, b, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else {
            if (f = l * a + b * k, g = d.radius - Math.abs(f), 0 < g) return d.reportCollisionVsWorld(a * g, k * g, e.sx, e.sy, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else {
            if (0 === b) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            c = e.pos.x + a * e.xw;
            k = e.pos.y + b * e.yw;
            c = d.pos.x - c;
            k = d.pos.y - k;
            f = Math.sqrt(c * c + k * k);
            g = d.radius - f;
            if (0 < g) return 0 === f ? (c = a /
                Math.SQRT2, k = b / Math.SQRT2) : (c /= f, k /= f), d.reportCollisionVsWorld(c * g, k * g, c, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_67DegB: function(c, g, a, b, d, e) {
        var f = e.signx,
            h = e.signy;
        if (0 === a)
            if (0 === b) {
                b = e.sx;
                a = e.sy;
                var k = d.radius,
                    p = d.pos.x - b * k - (e.pos.x + f * e.xw),
                    k = d.pos.y - a * k - (e.pos.y - h * e.yw),
                    f = p * b + k * a;
                if (0 > f) {
                    b *= -f;
                    a *= -f;
                    h = Math.sqrt(b * b + a * a);
                    c < g ? (f = c, g = 0, 0 > d.pos.x - e.pos.x && (c *= -1)) : (f = g, c = 0, 0 > d.pos.y - e.pos.y && (g *= -1));
                    if (f < h) return d.reportCollisionVsWorld(c,
                        g, c / f, g / f, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                    d.reportCollisionVsWorld(b, a, e.sx, e.sy, e);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                if (0 > h * b) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                p = d.pos.x - e.pos.x;
                k = d.pos.y - (e.pos.y + h * e.yw);
                if (0 > p * f) return d.reportCollisionVsWorld(0, g * b, 0, b, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
                b = e.sx;
                a = e.sy;
                if (0 < (p * -a + k * b) * f * h) {
                    if (g = Math.sqrt(p * p + k * k), c = d.radius - g, 0 < c) return p /= g, k /= g, d.reportCollisionVsWorld(p * c, k * c, p, k, e),
                        Phaser.Physics.Ninja.Circle.COL_OTHER
                } else if (c = d.radius - Math.abs(p * b + k * a), 0 < c) return d.reportCollisionVsWorld(b * c, a * c, b, a, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        else if (0 === b) {
            if (0 > f * a) return d.reportCollisionVsWorld(c * a, 0, a, 0, e), Phaser.Physics.Ninja.Circle.COL_AXIS;
            c = Math.sqrt(5);
            b = 2 * f / c;
            a = 1 * h / c;
            p = d.pos.x - (e.pos.x + f * e.xw);
            k = d.pos.y - (e.pos.y - h * e.yw);
            if (0 > (p * -a + k * b) * f * h) {
                if (g = Math.sqrt(p * p + k * k), c = d.radius - g, 0 < c) return p /= g, k /= g, d.reportCollisionVsWorld(p * c, k * c, p, k, e), Phaser.Physics.Ninja.Circle.COL_OTHER
            } else if (c =
                d.radius - Math.abs(p * b + k * a), 0 < c) return d.reportCollisionVsWorld(b * c, a * c, e.sx, e.sy, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (0 < f * a + h * b) {
            if (b = e.sx, a = e.sy, k = d.radius, p = d.pos.x - b * k - (e.pos.x + f * e.xw), k = d.pos.y - a * k - (e.pos.y - h * e.yw), f = p * b + k * a, 0 > f) return d.reportCollisionVsWorld(-b * f, -a * f, e.sx, e.sy, e), Phaser.Physics.Ninja.Circle.COL_OTHER
        } else if (f = d.pos.x - (e.pos.x + a * e.xw), h = d.pos.y - (e.pos.y + b * e.yw), g = Math.sqrt(f * f + h * h), c = d.radius - g, 0 < c) return 0 === g ? (f = a / Math.SQRT2, h = b / Math.SQRT2) : (f /= g, h /= g), d.reportCollisionVsWorld(f *
            c, h * c, f, h, e), Phaser.Physics.Ninja.Circle.COL_OTHER;
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    destroy: function() {
        this.system = this.body = null
    }
};
! function(c) {
    "object" == typeof exports ? module.exports = c() : "function" == typeof define && define.amd ? define("p2", function() {
        return this.p2 = c()
    }()) : "undefined" != typeof window ? window.p2 = c() : "undefined" != typeof global ? self.p2 = c() : "undefined" != typeof self && (self.p2 = c())
}(function() {
    return function g(a, b, d) {
        function e(h, p) {
            if (!b[h]) {
                if (!a[h]) {
                    var l = "function" == typeof require && require;
                    if (!p && l) return l(h, !0);
                    if (f) return f(h, !0);
                    throw Error("Cannot find module '" + h + "'");
                }
                l = b[h] = {
                    exports: {}
                };
                a[h][0].call(l.exports,
                    function(b) {
                        var d = a[h][1][b];
                        return e(d ? d : b)
                    }, l, l.exports, g, a, b, d)
            }
            return b[h].exports
        }
        for (var f = "function" == typeof require && require, h = 0; h < d.length; h++) e(d[h]);
        return e
    }({
        1: [function(g, a, b) {
            if (!d) var d = 1E-6;
            if (!e) var e = "undefined" !== typeof Float32Array ? Float32Array : Array;
            g = {
                setMatrixArrayType: function(a) {
                    e = a
                }
            };
            "undefined" !== typeof b && (b.glMatrix = g);
            var f = {
                create: function() {
                    var a = new e(2);
                    a[0] = 0;
                    a[1] = 0;
                    return a
                },
                clone: function(a) {
                    var b = new e(2);
                    b[0] = a[0];
                    b[1] = a[1];
                    return b
                },
                fromValues: function(a, b) {
                    var d =
                        new e(2);
                    d[0] = a;
                    d[1] = b;
                    return d
                },
                copy: function(a, b) {
                    a[0] = b[0];
                    a[1] = b[1];
                    return a
                },
                set: function(a, b, e) {
                    a[0] = b;
                    a[1] = e;
                    return a
                },
                add: function(a, b, e) {
                    a[0] = b[0] + e[0];
                    a[1] = b[1] + e[1];
                    return a
                },
                subtract: function(a, b, e) {
                    a[0] = b[0] - e[0];
                    a[1] = b[1] - e[1];
                    return a
                }
            };
            f.sub = f.subtract;
            f.multiply = function(a, b, e) {
                a[0] = b[0] * e[0];
                a[1] = b[1] * e[1];
                return a
            };
            f.mul = f.multiply;
            f.divide = function(a, b, e) {
                a[0] = b[0] / e[0];
                a[1] = b[1] / e[1];
                return a
            };
            f.div = f.divide;
            f.min = function(a, b, e) {
                a[0] = Math.min(b[0], e[0]);
                a[1] = Math.min(b[1], e[1]);
                return a
            };
            f.max = function(a, b, e) {
                a[0] = Math.max(b[0], e[0]);
                a[1] = Math.max(b[1], e[1]);
                return a
            };
            f.scale = function(a, b, e) {
                a[0] = b[0] * e;
                a[1] = b[1] * e;
                return a
            };
            f.distance = function(a, b) {
                var e = b[0] - a[0],
                    d = b[1] - a[1];
                return Math.sqrt(e * e + d * d)
            };
            f.dist = f.distance;
            f.squaredDistance = function(a, b) {
                var e = b[0] - a[0],
                    d = b[1] - a[1];
                return e * e + d * d
            };
            f.sqrDist = f.squaredDistance;
            f.length = function(a) {
                var b = a[0];
                a = a[1];
                return Math.sqrt(b * b + a * a)
            };
            f.len = f.length;
            f.squaredLength = function(a) {
                var b = a[0];
                a = a[1];
                return b * b + a * a
            };
            f.sqrLen =
                f.squaredLength;
            f.negate = function(a, b) {
                a[0] = -b[0];
                a[1] = -b[1];
                return a
            };
            f.normalize = function(a, b) {
                var e = b[0],
                    d = b[1],
                    e = e * e + d * d;
                0 < e && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e);
                return a
            };
            f.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1]
            };
            f.cross = function(a, b, e) {
                b = b[0] * e[1] - b[1] * e[0];
                a[0] = a[1] = 0;
                a[2] = b;
                return a
            };
            f.lerp = function(a, b, e, d) {
                var f = b[0];
                b = b[1];
                a[0] = f + d * (e[0] - f);
                a[1] = b + d * (e[1] - b);
                return a
            };
            f.transformMat2 = function(a, b, e) {
                var d = b[0];
                b = b[1];
                a[0] = e[0] * d + e[2] * b;
                a[1] = e[1] * d + e[3] * b;
                return a
            };
            f.transformMat2d =
                function(a, b, e) {
                    var d = b[0];
                    b = b[1];
                    a[0] = e[0] * d + e[2] * b + e[4];
                    a[1] = e[1] * d + e[3] * b + e[5];
                    return a
                };
            f.transformMat3 = function(a, b, e) {
                var d = b[0];
                b = b[1];
                a[0] = e[0] * d + e[3] * b + e[6];
                a[1] = e[1] * d + e[4] * b + e[7];
                return a
            };
            f.transformMat4 = function(a, b, e) {
                var d = b[0];
                b = b[1];
                a[0] = e[0] * d + e[4] * b + e[12];
                a[1] = e[1] * d + e[5] * b + e[13];
                return a
            };
            f.forEach = function() {
                var a = f.create();
                return function(b, e, d, f, g, q) {
                    e || (e = 2);
                    d || (d = 0);
                    for (f = f ? Math.min(f * e + d, b.length) : b.length; d < f; d += e) a[0] = b[d], a[1] = b[d + 1], g(a, a, q), b[d] = a[0], b[d + 1] = a[1];
                    return b
                }
            }();
            f.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")"
            };
            "undefined" !== typeof b && (b.vec2 = f)
        }, {}],
        2: [function(g, a, b) {
            function d() {}
            var e = g("./Scalar");
            a.exports = d;
            d.lineInt = function(a, b, d) {
                var g = [0, 0],
                    l, m, n, q, s;
                l = a[1][1] - a[0][1];
                m = a[0][0] - a[1][0];
                a = l * a[0][0] + m * a[0][1];
                n = b[1][1] - b[0][1];
                q = b[0][0] - b[1][0];
                b = n * b[0][0] + q * b[0][1];
                s = l * q - n * m;
                e.eq(s, 0, d || 0) || (g[0] = (q * a - m * b) / s, g[1] = (l * b - n * a) / s);
                return g
            };
            d.segmentsIntersect = function(a, b, e, d) {
                var g = b[0] - a[0];
                b = b[1] - a[1];
                var m = d[0] - e[0],
                    n = d[1] - e[1];
                if (0 == m * b - n * g) return !1;
                d = (g * (e[1] - a[1]) + b * (a[0] - e[0])) / (m * b - n * g);
                a = (m * (a[1] - e[1]) + n * (e[0] - a[0])) / (n * g - m * b);
                return 0 <= d && 1 >= d && 0 <= a && 1 >= a
            }
        }, {
            "./Scalar": 5
        }],
        3: [function(g, a, b) {
            function d() {}
            a.exports = d;
            d.area = function(a, b, e) {
                return (b[0] - a[0]) * (e[1] - a[1]) - (e[0] - a[0]) * (b[1] - a[1])
            };
            d.left = function(a, b, e) {
                return 0 < d.area(a, b, e)
            };
            d.leftOn = function(a, b, e) {
                return 0 <= d.area(a, b, e)
            };
            d.right = function(a, b, e) {
                return 0 > d.area(a, b, e)
            };
            d.rightOn = function(a, b, e) {
                return 0 >= d.area(a, b, e)
            };
            var e = [],
                f = [];
            d.collinear = function(a, b, g, l) {
                return l ?
                    (e[0] = b[0] - a[0], e[1] = b[1] - a[1], f[0] = g[0] - b[0], f[1] = g[1] - b[1], a = e[0] * f[0] + e[1] * f[1], b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), g = Math.sqrt(f[0] * f[0] + f[1] * f[1]), Math.acos(a / (b * g)) < l) : 0 == d.area(a, b, g)
            };
            d.sqdist = function(a, b) {
                var e = b[0] - a[0],
                    d = b[1] - a[1];
                return e * e + d * d
            }
        }, {}],
        4: [function(g, a, b) {
            function d() {
                this.vertices = []
            }

            function e(a, b, e, d, f) {
                var h = b[1] - a[1];
                b = a[0] - b[0];
                a = h * a[0] + b * a[1];
                var g = d[1] - e[1];
                d = e[0] - d[0];
                e = g * e[0] + d * e[1];
                var l = h * d - g * b;
                return k.eq(l, 0, f || 0) ? [0, 0] : [(d * a - b * e) / l, (h * e - g * a) / l]
            }
            var f = g("./Line"),
                h = g("./Point"),
                k = g("./Scalar");
            a.exports = d;
            d.prototype.at = function(a) {
                var b = this.vertices,
                    e = b.length;
                return b[0 > a ? a % e + e : a % e]
            };
            d.prototype.first = function() {
                return this.vertices[0]
            };
            d.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            };
            d.prototype.clear = function() {
                this.vertices.length = 0
            };
            d.prototype.append = function(a, b, e) {
                if ("undefined" == typeof b) throw Error("From is not given!");
                if ("undefined" == typeof e) throw Error("To is not given!");
                if (e - 1 < b) throw Error("lol1");
                if (e > a.vertices.length) throw Error("lol2");
                if (0 > b) throw Error("lol3");
                for (; b < e; b++) this.vertices.push(a.vertices[b])
            };
            d.prototype.makeCCW = function() {
                for (var a = 0, b = this.vertices, e = 1; e < this.vertices.length; ++e)
                    if (b[e][1] < b[a][1] || b[e][1] == b[a][1] && b[e][0] > b[a][0]) a = e;
                h.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse()
            };
            d.prototype.reverse = function() {
                for (var a = [], b = 0, e = this.vertices.length; b !== e; b++) a.push(this.vertices.pop());
                this.vertices = a
            };
            d.prototype.isReflex = function(a) {
                return h.right(this.at(a - 1), this.at(a), this.at(a + 1))
            };
            var p = [],
                l = [];
            d.prototype.canSee = function(a, b) {
                var e, d;
                if (h.leftOn(this.at(a + 1), this.at(a), this.at(b)) && h.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
                d = h.sqdist(this.at(a), this.at(b));
                for (var g = 0; g !== this.vertices.length; ++g)
                    if (!((g + 1) % this.vertices.length === a || g === a) && h.leftOn(this.at(a), this.at(b), this.at(g + 1)) && h.rightOn(this.at(a), this.at(b), this.at(g)))
                        if (p[0] = this.at(a), p[1] = this.at(b), l[0] = this.at(g), l[1] = this.at(g + 1), e = f.lineInt(p, l), h.sqdist(this.at(a), e) < d) return !1;
                return !0
            };
            d.prototype.copy =
                function(a, b, e) {
                    e = e || new d;
                    e.clear();
                    if (a < b)
                        for (var f = a; f <= b; f++) e.vertices.push(this.vertices[f]);
                    else {
                        for (f = 0; f <= b; f++) e.vertices.push(this.vertices[f]);
                        for (f = a; f < this.vertices.length; f++) e.vertices.push(this.vertices[f])
                    }
                    return e
                };
            d.prototype.getCutEdges = function() {
                for (var a = [], b = [], e = [], f = new d, h = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g)
                    if (this.isReflex(g))
                        for (var k = 0; k < this.vertices.length; ++k)
                            if (this.canSee(g, k)) {
                                for (var b = this.copy(g, k, f).getCutEdges(), e = this.copy(k, g, f).getCutEdges(),
                                        l = 0; l < e.length; l++) b.push(e[l]);
                                b.length < h && (a = b, h = b.length, a.push([this.at(g), this.at(k)]))
                            }
                return a
            };
            d.prototype.decomp = function() {
                var a = this.getCutEdges();
                return 0 < a.length ? this.slice(a) : [this]
            };
            d.prototype.slice = function(a) {
                if (0 == a.length) return [this];
                if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                    for (var b = [this], e = 0; e < a.length; e++)
                        for (var d = a[e], f = 0; f < b.length; f++) {
                            var h = b[f].slice(d);
                            if (h) {
                                b.splice(f, 1);
                                b.push(h[0], h[1]);
                                break
                            }
                        }
                    return b
                }
                d = a;
                e = this.vertices.indexOf(d[0]);
                f = this.vertices.indexOf(d[1]);
                return -1 != e && -1 != f ? [this.copy(e, f), this.copy(f, e)] : !1
            };
            d.prototype.isSimple = function() {
                for (var a = this.vertices, b = 0; b < a.length - 1; b++)
                    for (var e = 0; e < b - 1; e++)
                        if (f.segmentsIntersect(a[b], a[b + 1], a[e], a[e + 1])) return !1;
                for (b = 1; b < a.length - 2; b++)
                    if (f.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
                return !0
            };
            d.prototype.quickDecomp = function(a, b, f, g, k, l) {
                k = k || 100;
                l = l || 0;
                g = g || 25;
                a = "undefined" != typeof a ? a : [];
                b = b || [];
                f = f || [];
                var p = [0, 0],
                    A = [0,
                        0
                    ],
                    r = [0, 0],
                    x = 0,
                    z = 0,
                    w = 0,
                    B = x = 0,
                    C = 0,
                    F = 0,
                    y = new d,
                    D = new d,
                    I = this.vertices;
                if (3 > I.length) return a;
                l++;
                if (l > k) return console.warn("quickDecomp: max level (" + k + ") reached."), a;
                for (var E = 0; E < this.vertices.length; ++E)
                    if (this.isReflex(E)) {
                        b.push(this.vertices[E]);
                        for (var x = z = Number.MAX_VALUE, H = 0; H < this.vertices.length; ++H) h.left(this.at(E - 1), this.at(E), this.at(H)) && h.rightOn(this.at(E - 1), this.at(E), this.at(H - 1)) && (r = e(this.at(E - 1), this.at(E), this.at(H), this.at(H - 1)), h.right(this.at(E + 1), this.at(E), r) && (w = h.sqdist(this.vertices[E],
                            r), w < z && (z = w, A = r, C = H))), h.left(this.at(E + 1), this.at(E), this.at(H + 1)) && h.rightOn(this.at(E + 1), this.at(E), this.at(H)) && (r = e(this.at(E + 1), this.at(E), this.at(H), this.at(H + 1)), h.left(this.at(E - 1), this.at(E), r) && (w = h.sqdist(this.vertices[E], r), w < x && (x = w, p = r, B = H)));
                        if (C == (B + 1) % this.vertices.length) r[0] = (A[0] + p[0]) / 2, r[1] = (A[1] + p[1]) / 2, f.push(r), E < B ? (y.append(this, E, B + 1), y.vertices.push(r), D.vertices.push(r), 0 != C && D.append(this, C, this.vertices.length), D.append(this, 0, E + 1)) : (0 != E && y.append(this, E, this.vertices.length),
                            y.append(this, 0, B + 1), y.vertices.push(r), D.vertices.push(r), D.append(this, C, E + 1));
                        else {
                            C > B && (B += this.vertices.length);
                            x = Number.MAX_VALUE;
                            if (B < C) return a;
                            for (H = C; H <= B; ++H) h.leftOn(this.at(E - 1), this.at(E), this.at(H)) && h.rightOn(this.at(E + 1), this.at(E), this.at(H)) && (w = h.sqdist(this.at(E), this.at(H)), w < x && (x = w, F = H % this.vertices.length));
                            E < F ? (y.append(this, E, F + 1), 0 != F && D.append(this, F, I.length), D.append(this, 0, E + 1)) : (0 != E && y.append(this, E, I.length), y.append(this, 0, F + 1), D.append(this, F, E + 1))
                        }
                        y.vertices.length <
                            D.vertices.length ? (y.quickDecomp(a, b, f, g, k, l), D.quickDecomp(a, b, f, g, k, l)) : (D.quickDecomp(a, b, f, g, k, l), y.quickDecomp(a, b, f, g, k, l));
                        return a
                    }
                a.push(this);
                return a
            };
            d.prototype.removeCollinearPoints = function(a) {
                for (var b = 0, e = this.vertices.length - 1; 3 < this.vertices.length && 0 <= e; --e) h.collinear(this.at(e - 1), this.at(e), this.at(e + 1), a) && (this.vertices.splice(e % this.vertices.length, 1), e--, b++);
                return b
            }
        }, {
            "./Line": 2,
            "./Point": 3,
            "./Scalar": 5
        }],
        5: [function(g, a, b) {
            function d() {}
            a.exports = d;
            d.eq = function(a, b,
                d) {
                return Math.abs(a - b) < (d || 0)
            }
        }, {}],
        6: [function(g, a, b) {
            a.exports = {
                Polygon: g("./Polygon"),
                Point: g("./Point")
            }
        }, {
            "./Point": 3,
            "./Polygon": 4
        }],
        7: [function(g, a, b) {
            a.exports = {
                name: "p2",
                version: "0.5.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "~0.4.0",
                    "grunt-contrib-jshint": "~0.9.2",
                    "grunt-contrib-nodeunit": "~0.1.2",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "z-schema": "~2.4.6"
                },
                dependencies: {
                    "poly-decomp": "0.1.0",
                    "gl-matrix": "2.1.0"
                }
            }
        }, {}],
        8: [function(g, a, b) {
            function d(a) {
                this.lowerBound = e.create();
                a && a.lowerBound && e.copy(this.lowerBound, a.lowerBound);
                this.upperBound = e.create();
                a && a.upperBound && e.copy(this.upperBound, a.upperBound)
            }
            var e = g("../math/vec2");
            g("../utils/Utils");
            a.exports = d;
            var f = e.create();
            d.prototype.setFromPoints = function(a, b, d) {
                var g = this.lowerBound,
                    m = this.upperBound;
                e.set(g, Number.MAX_VALUE, Number.MAX_VALUE);
                e.set(m, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (var n = 0; n < a.length; n++) {
                    var q = a[n];
                    "number" === typeof d && (e.rotate(f, q, d), q = f);
                    for (var s = 0; 2 > s; s++) q[s] > m[s] && (m[s] = q[s]), q[s] < g[s] && (g[s] = q[s])
                }
                b && (e.add(this.lowerBound, this.lowerBound, b), e.add(this.upperBound, this.upperBound, b))
            };
            d.prototype.copy = function(a) {
                e.copy(this.lowerBound,
                    a.lowerBound);
                e.copy(this.upperBound, a.upperBound)
            };
            d.prototype.extend = function(a) {
                for (var b = 0; 2 > b; b++) a.lowerBound[b] < this.lowerBound[b] && (this.lowerBound[b] = a.lowerBound[b]), a.upperBound[b] > this.upperBound[b] && (this.upperBound[b] = a.upperBound[b])
            };
            d.prototype.overlaps = function(a) {
                var b = this.lowerBound,
                    e = this.upperBound,
                    d = a.lowerBound;
                a = a.upperBound;
                return (d[0] <= e[0] && e[0] <= a[0] || b[0] <= a[0] && a[0] <= e[0]) && (d[1] <= e[1] && e[1] <= a[1] || b[1] <= a[1] && a[1] <= e[1])
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 47
        }],
        9: [function(g, a, b) {
            function d(a) {
                this.type = a;
                this.result = [];
                this.world = null;
                this.boundingVolumeType = d.AABB
            }
            var e = g("../math/vec2"),
                f = g("../objects/Body");
            a.exports = d;
            d.AABB = 1;
            d.BOUNDING_CIRCLE = 2;
            d.prototype.setWorld = function(a) {
                this.world = a
            };
            d.prototype.getCollisionPairs = function(a) {
                throw Error("getCollisionPairs must be implemented in a subclass!");
            };
            var h = e.create();
            d.boundingRadiusCheck = function(a, b) {
                e.sub(h, a.position, b.position);
                var d = e.squaredLength(h),
                    f = a.boundingRadius + b.boundingRadius;
                return d <=
                    f * f
            };
            d.aabbCheck = function(a, b) {
                a.aabbNeedsUpdate && a.updateAABB();
                b.aabbNeedsUpdate && b.updateAABB();
                return a.aabb.overlaps(b.aabb)
            };
            d.prototype.boundingVolumeCheck = function(a, b) {
                var e;
                switch (this.boundingVolumeType) {
                    case d.BOUNDING_CIRCLE:
                        e = d.boundingRadiusCheck(a, b);
                        break;
                    case d.AABB:
                        e = d.aabbCheck(a, b);
                        break;
                    default:
                        throw Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                }
                return e
            };
            d.canCollide = function(a, b) {
                return a.motionState === f.STATIC && b.motionState === f.STATIC || (a.motionState ===
                    f.KINEMATIC && b.motionState === f.STATIC || a.motionState === f.STATIC && b.motionState === f.KINEMATIC) || a.motionState === f.KINEMATIC && b.motionState === f.KINEMATIC || a.sleepState === f.SLEEPING && b.sleepState === f.SLEEPING || a.sleepState === f.SLEEPING && b.motionState === f.STATIC || b.sleepState === f.SLEEPING && a.motionState === f.STATIC ? !1 : !0
            };
            d.NAIVE = 1;
            d.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        10: [function(g, a, b) {
            function d(a) {
                e.apply(this);
                a = f.defaults(a, {
                    xmin: -100,
                    xmax: 100,
                    ymin: -100,
                    ymax: 100,
                    nx: 10,
                    ny: 10
                });
                this.xmin =
                    a.xmin;
                this.ymin = a.ymin;
                this.xmax = a.xmax;
                this.ymax = a.ymax;
                this.nx = a.nx;
                this.ny = a.ny;
                this.binsizeX = (this.xmax - this.xmin) / this.nx;
                this.binsizeY = (this.ymax - this.ymin) / this.ny
            }
            g("../shapes/Circle");
            g("../shapes/Plane");
            g("../shapes/Particle");
            var e = g("../collision/Broadphase");
            g("../math/vec2");
            var f = g("../utils/Utils");
            a.exports = d;
            d.prototype = new e;
            d.prototype.getCollisionPairs = function(a) {
                var b = [],
                    d = a.bodies,
                    f = d.length,
                    g = this.nx,
                    n = this.ny,
                    q = this.xmin,
                    s = this.ymin,
                    v = this.xmax,
                    t = this.ymax;
                a = [];
                for (var u =
                        g * n, A = 0; A < u; A++) a.push([]);
                for (var r = g / (v - q), x = n / (t - s), A = 0; A !== f; A++)
                    for (var g = d[A], z = g.aabb, w = Math.max(z.lowerBound[0], q), B = Math.max(z.lowerBound[1], s), C = Math.min(z.upperBound[0], v), F = Math.min(z.upperBound[1], t), B = Math.floor(x * (B - s)), z = Math.floor(r * (C - q)), F = Math.floor(x * (F - s)), w = Math.floor(r * (w - q)); w <= z; w++)
                        for (C = B; C <= F; C++) {
                            var y = w * (n - 1) + C;
                            0 <= y && y < u && a[y].push(g)
                        }
                for (A = 0; A !== u; A++) {
                    d = a[A];
                    w = 0;
                    for (f = d.length; w !== f; w++) {
                        g = d[w];
                        for (C = 0; C !== w; C++) n = d[C], e.canCollide(g, n) && this.boundingVolumeCheck(g,
                            n) && b.push(g, n)
                    }
                }
                return b
            }
        }, {
            "../collision/Broadphase": 9,
            "../math/vec2": 30,
            "../shapes/Circle": 35,
            "../shapes/Particle": 39,
            "../shapes/Plane": 40,
            "../utils/Utils": 47
        }],
        11: [function(g, a, b) {
            function d() {
                e.call(this, e.NAIVE)
            }
            g("../shapes/Circle");
            g("../shapes/Plane");
            g("../shapes/Shape");
            g("../shapes/Particle");
            var e = g("../collision/Broadphase");
            g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.getCollisionPairs = function(a) {
                a = a.bodies;
                for (var b = this.result, d = b.length = 0, g = a.length; d !== g; d++)
                    for (var l =
                            a[d], m = 0; m < d; m++) {
                        var n = a[m];
                        e.canCollide(l, n) && this.boundingVolumeCheck(l, n) && b.push(l, n)
                    }
                return b
            }
        }, {
            "../collision/Broadphase": 9,
            "../math/vec2": 30,
            "../shapes/Circle": 35,
            "../shapes/Particle": 39,
            "../shapes/Plane": 40,
            "../shapes/Shape": 42
        }],
        12: [function(g, a, b) {
            function d() {
                this.contactEquations = [];
                this.frictionEquations = [];
                this.enableFriction = !0;
                this.slipForce = 10;
                this.frictionCoefficient = 0.3;
                this.surfaceVelocity = 0;
                this.reuseObjects = !0;
                this.reusableContactEquations = [];
                this.reusableFrictionEquations = [];
                this.restitution = 0;
                this.stiffness = q.DEFAULT_STIFFNESS;
                this.relaxation = q.DEFAULT_RELAXATION;
                this.frictionStiffness = q.DEFAULT_STIFFNESS;
                this.frictionRelaxation = q.DEFAULT_RELAXATION;
                this.collidingBodiesLastStep = new n
            }

            function e(a, b) {
                h.set(a.vertices[0], 0.5 * -b.length, -b.radius);
                h.set(a.vertices[1], 0.5 * b.length, -b.radius);
                h.set(a.vertices[2], 0.5 * b.length, b.radius);
                h.set(a.vertices[3], 0.5 * -b.length, b.radius)
            }

            function f(a, b, e, d) {
                var f = ja,
                    g = na,
                    l = oa,
                    m = W;
                b = b.vertices;
                for (var n = null, q = 0; q !== b.length + 1; q++) {
                    var s =
                        b[(q + 1) % b.length];
                    h.rotate(f, b[q % b.length], d);
                    h.rotate(g, s, d);
                    p(f, f, e);
                    p(g, g, e);
                    k(l, f, a);
                    k(m, g, a);
                    s = h.crossLength(l, m);
                    null === n && (n = s);
                    if (0 >= s * n) return !1;
                    n = s
                }
                return !0
            }
            var h = g("../math/vec2"),
                k = h.sub,
                p = h.add,
                l = h.dot,
                m = g("../utils/Utils"),
                n = g("../utils/TupleDictionary"),
                q = g("../equations/Equation"),
                s = g("../equations/ContactEquation"),
                v = g("../equations/FrictionEquation");
            b = g("../shapes/Circle");
            var t = g("../shapes/Convex"),
                u = g("../shapes/Shape");
            g("../objects/Body");
            g = g("../shapes/Rectangle");
            a.exports =
                d;
            var A = h.fromValues(0, 1),
                r = h.fromValues(0, 0),
                x = h.fromValues(0, 0),
                z = h.fromValues(0, 0),
                w = h.fromValues(0, 0),
                B = h.fromValues(0, 0),
                C = h.fromValues(0, 0),
                F = h.fromValues(0, 0),
                y = h.fromValues(0, 0),
                D = h.fromValues(0, 0),
                I = h.fromValues(0, 0),
                E = h.fromValues(0, 0),
                H = h.fromValues(0, 0),
                P = h.fromValues(0, 0),
                Q = h.fromValues(0, 0),
                pa = h.fromValues(0, 0),
                qa = h.fromValues(0, 0),
                X = h.fromValues(0, 0),
                ra = h.fromValues(0, 0),
                Y = [];
            d.prototype.collidedLastStep = function(a, b) {
                return !!this.collidingBodiesLastStep.get(a.id | 0, b.id | 0)
            };
            d.prototype.reset =
                function(a) {
                    this.collidingBodiesLastStep.reset();
                    for (a = 0; a !== this.contactEquations.length; a++) {
                        var b = this.contactEquations[a];
                        this.collidingBodiesLastStep.set(b.bodyA.id | 0, b.bodyB.id | 0, !0)
                    }
                    this.reuseObjects && (a = this.frictionEquations, b = this.reusableFrictionEquations, m.appendArray(this.reusableContactEquations, this.contactEquations), m.appendArray(b, a));
                    this.contactEquations.length = this.frictionEquations.length = 0
                };
            d.prototype.createContactEquation = function(a, b, e, d) {
                var f = this.reusableContactEquations.length ?
                    this.reusableContactEquations.pop() : new s(a, b);
                f.bodyA = a;
                f.bodyB = b;
                f.shapeA = e;
                f.shapeB = d;
                f.restitution = this.restitution;
                f.firstImpact = !this.collidedLastStep(a, b);
                f.stiffness = this.stiffness;
                f.relaxation = this.relaxation;
                f.needsUpdate = !0;
                f.enabled = !0;
                return f
            };
            d.prototype.createFrictionEquation = function(a, b, e, d) {
                var f = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new v(a, b);
                f.bodyA = a;
                f.bodyB = b;
                f.shapeA = e;
                f.shapeB = d;
                f.setSlipForce(this.slipForce);
                f.frictionCoefficient = this.frictionCoefficient;
                f.relativeVelocity = this.surfaceVelocity;
                f.enabled = !0;
                f.needsUpdate = !0;
                f.stiffness = this.frictionStiffness;
                f.relaxation = this.frictionRelaxation;
                return f
            };
            d.prototype.createFrictionFromContact = function(a) {
                var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
                h.copy(b.contactPointA, a.contactPointA);
                h.copy(b.contactPointB, a.contactPointB);
                h.rotate90cw(b.t, a.normalA);
                b.contactEquation = a;
                return b
            };
            d.prototype[u.LINE | u.CONVEX] = d.prototype.convexLine = function(a, b, e, d, f, h, g, k, l) {
                return l ? !1 :
                    0
            };
            d.prototype[u.LINE | u.RECTANGLE] = d.prototype.lineRectangle = function(a, b, e, d, f, h, g, k, l) {
                return l ? !1 : 0
            };
            var ka = new g(1, 1),
                M = h.create();
            d.prototype[u.CAPSULE | u.CONVEX] = d.prototype[u.CAPSULE | u.RECTANGLE] = d.prototype.convexCapsule = function(a, b, d, f, g, k, l, m, p) {
                h.set(M, k.length / 2, 0);
                h.rotate(M, M, m);
                h.add(M, M, l);
                var n = this.circleConvex(g, k, M, m, a, b, d, f, p, k.radius);
                h.set(M, -k.length / 2, 0);
                h.rotate(M, M, m);
                h.add(M, M, l);
                var q = this.circleConvex(g, k, M, m, a, b, d, f, p, k.radius);
                if (p && (n || q)) return !0;
                e(ka, k);
                return this.convexConvex(a,
                    b, d, f, g, ka, l, m, p) + n + q
            };
            d.prototype[u.CAPSULE | u.LINE] = d.prototype.lineCapsule = function(a, b, e, d, f, h, g, k, l) {
                return l ? !1 : 0
            };
            var R = h.create(),
                S = h.create(),
                Z = new g(1, 1);
            d.prototype[u.CAPSULE | u.CAPSULE] = d.prototype.capsuleCapsule = function(a, b, d, f, g, k, l, m, p) {
                for (var n = 0, q = 0; 2 > q; q++) {
                    h.set(R, (0 == q ? -1 : 1) * b.length / 2, 0);
                    h.rotate(R, R, f);
                    h.add(R, R, d);
                    for (var s = 0; 2 > s; s++) {
                        h.set(S, (0 == s ? -1 : 1) * k.length / 2, 0);
                        h.rotate(S, S, m);
                        h.add(S, S, l);
                        var t = this.circleCircle(a, b, R, f, g, k, S, m, p, b.radius, k.radius);
                        if (p && t) return !0;
                        n += t
                    }
                }
                e(Z, b);
                q = this.convexCapsule(a, Z, d, f, g, k, l, m, p);
                if (p && q) return !0;
                n += q;
                e(Z, k);
                a = this.convexCapsule(g, Z, l, m, a, b, d, f, p);
                return p && a ? !0 : n + a
            };
            d.prototype[u.LINE | u.LINE] = d.prototype.lineLine = function(a, b, e, d, f, h, g, k, l) {
                return l ? !1 : 0
            };
            d.prototype[u.PLANE | u.LINE] = d.prototype.planeLine = function(a, b, e, d, f, g, m, n, q) {
                numContacts = 0;
                h.set(r, -g.length / 2, 0);
                h.set(x, g.length / 2, 0);
                h.rotate(z, r, n);
                h.rotate(w, x, n);
                p(z, z, m);
                p(w, w, m);
                h.copy(r, z);
                h.copy(x, w);
                k(B, x, r);
                h.normalize(C, B);
                h.rotate90cw(D, C);
                h.rotate(y, A,
                    d);
                Y[0] = r;
                Y[1] = x;
                for (d = 0; d < Y.length; d++) {
                    n = Y[d];
                    k(F, n, e);
                    var s = l(F, y);
                    if (0 > s) {
                        if (q) return !0;
                        var t = this.createContactEquation(a, f, b, g);
                        numContacts++;
                        h.copy(t.normalA, y);
                        h.normalize(t.normalA, t.normalA);
                        h.scale(F, y, s);
                        k(t.contactPointA, n, F);
                        k(t.contactPointA, t.contactPointA, a.position);
                        k(t.contactPointB, n, m);
                        p(t.contactPointB, t.contactPointB, m);
                        k(t.contactPointB, t.contactPointB, f.position);
                        this.contactEquations.push(t);
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(t))
                    }
                }
                return numContacts
            };
            d.prototype[u.PARTICLE | u.CAPSULE] = d.prototype.particleCapsule = function(a, b, e, d, f, h, g, k, l) {
                return this.circleLine(a, b, e, d, f, h, g, k, l, h.radius, 0)
            };
            d.prototype[u.CIRCLE | u.LINE] = d.prototype.circleLine = function(a, b, e, d, f, g, m, n, q, s, t) {
                s = s || 0;
                t = "undefined" != typeof t ? t : b.radius;
                h.set(y, -g.length / 2, 0);
                h.set(D, g.length / 2, 0);
                h.rotate(I, y, n);
                h.rotate(E, D, n);
                p(I, I, m);
                p(E, E, m);
                h.copy(y, I);
                h.copy(D, E);
                k(C, D, y);
                h.normalize(F, C);
                h.rotate90cw(B, F);
                k(H, e, y);
                d = l(H, B);
                k(w, y, m);
                k(P, e, m);
                if (Math.abs(d) < t + s) {
                    h.scale(r, B,
                        d);
                    k(z, e, r);
                    h.scale(x, B, l(B, P));
                    h.normalize(x, x);
                    h.scale(x, x, s);
                    p(z, z, x);
                    d = l(F, z);
                    n = l(F, y);
                    var u = l(F, D);
                    if (d > n && d < u) {
                        if (q) return !0;
                        b = this.createContactEquation(a, f, b, g);
                        h.scale(b.normalA, r, -1);
                        h.normalize(b.normalA, b.normalA);
                        h.scale(b.contactPointA, b.normalA, t);
                        p(b.contactPointA, b.contactPointA, e);
                        k(b.contactPointA, b.contactPointA, a.position);
                        k(b.contactPointB, z, m);
                        p(b.contactPointB, b.contactPointB, m);
                        k(b.contactPointB, b.contactPointB, f.position);
                        this.contactEquations.push(b);
                        this.enableFriction &&
                            this.frictionEquations.push(this.createFrictionFromContact(b));
                        return 1
                    }
                }
                Y[0] = y;
                Y[1] = D;
                for (n = 0; n < Y.length; n++)
                    if (d = Y[n], k(H, d, e), h.squaredLength(H) < (t + s) * (t + s)) {
                        if (q) return !0;
                        b = this.createContactEquation(a, f, b, g);
                        h.copy(b.normalA, H);
                        h.normalize(b.normalA, b.normalA);
                        h.scale(b.contactPointA, b.normalA, t);
                        p(b.contactPointA, b.contactPointA, e);
                        k(b.contactPointA, b.contactPointA, a.position);
                        k(b.contactPointB, d, m);
                        h.scale(Q, b.normalA, -s);
                        p(b.contactPointB, b.contactPointB, Q);
                        p(b.contactPointB, b.contactPointB,
                            m);
                        k(b.contactPointB, b.contactPointB, f.position);
                        this.contactEquations.push(b);
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b));
                        return 1
                    }
                return 0
            };
            d.prototype[u.CIRCLE | u.CAPSULE] = d.prototype.circleCapsule = function(a, b, e, d, f, h, g, k, l) {
                return this.circleLine(a, b, e, d, f, h, g, k, l, h.radius)
            };
            d.prototype[u.CIRCLE | u.CONVEX] = d.prototype[u.CIRCLE | u.RECTANGLE] = d.prototype.circleConvex = function(a, b, e, d, g, l, m, n, q, s) {
                s = "number" == typeof s ? s : b.radius;
                d = !1;
                var t = Number.MAX_VALUE;
                verts =
                    l.vertices;
                for (var u = 0; u !== verts.length + 1; u++) {
                    var G = verts[(u + 1) % verts.length];
                    h.rotate(r, verts[u % verts.length], n);
                    h.rotate(x, G, n);
                    p(r, r, m);
                    p(x, x, m);
                    k(z, x, r);
                    h.normalize(w, z);
                    h.rotate90cw(B, w);
                    h.scale(Q, B, -b.radius);
                    p(Q, Q, e);
                    f(Q, l, m, n) && (h.sub(pa, r, Q), G = Math.abs(h.dot(pa, B)), G < t && (h.copy(qa, Q), t = G, h.scale(P, B, G), h.add(P, P, Q), d = !0))
                }
                if (d) {
                    if (q) return !0;
                    b = this.createContactEquation(a, g, b, l);
                    h.sub(b.normalA, qa, e);
                    h.normalize(b.normalA, b.normalA);
                    h.scale(b.contactPointA, b.normalA, s);
                    p(b.contactPointA,
                        b.contactPointA, e);
                    k(b.contactPointA, b.contactPointA, a.position);
                    k(b.contactPointB, P, m);
                    p(b.contactPointB, b.contactPointB, m);
                    k(b.contactPointB, b.contactPointB, g.position);
                    this.contactEquations.push(b);
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b));
                    return 1
                }
                if (0 < s)
                    for (u = 0; u < verts.length; u++)
                        if (h.rotate(E, verts[u], n), p(E, E, m), k(I, E, e), h.squaredLength(I) < s * s) {
                            if (q) return !0;
                            b = this.createContactEquation(a, g, b, l);
                            h.copy(b.normalA, I);
                            h.normalize(b.normalA, b.normalA);
                            h.scale(b.contactPointA, b.normalA, s);
                            p(b.contactPointA, b.contactPointA, e);
                            k(b.contactPointA, b.contactPointA, a.position);
                            k(b.contactPointB, E, m);
                            p(b.contactPointB, b.contactPointB, m);
                            k(b.contactPointB, b.contactPointB, g.position);
                            this.contactEquations.push(b);
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b));
                            return 1
                        }
                return 0
            };
            var ja = h.create(),
                na = h.create(),
                oa = h.create(),
                W = h.create();
            d.prototype[u.PARTICLE | u.CONVEX] = d.prototype[u.PARTICLE | u.RECTANGLE] = d.prototype.particleConvex =
                function(a, b, e, d, g, m, n, s, q) {
                    d = Number.MAX_VALUE;
                    var t = !1,
                        u = m.vertices;
                    if (!f(e, m, n, s)) return 0;
                    if (q) return !0;
                    for (q = 0; q !== u.length + 1; q++) {
                        var G = u[(q + 1) % u.length];
                        h.rotate(r, u[q % u.length], s);
                        h.rotate(x, G, s);
                        p(r, r, n);
                        p(x, x, n);
                        k(z, x, r);
                        h.normalize(w, z);
                        h.rotate90cw(B, w);
                        k(I, e, r);
                        l(I, B);
                        k(C, r, n);
                        k(F, e, n);
                        h.sub(X, r, e);
                        G = Math.abs(h.dot(X, B));
                        G < d && (d = G, h.scale(P, B, G), h.add(P, P, e), h.copy(ra, B), t = !0)
                    }
                    return t ? (b = this.createContactEquation(a, g, b, m), h.scale(b.normalA, ra, -1), h.normalize(b.normalA, b.normalA), h.set(b.contactPointA,
                        0, 0), p(b.contactPointA, b.contactPointA, e), k(b.contactPointA, b.contactPointA, a.position), k(b.contactPointB, P, n), p(b.contactPointB, b.contactPointB, n), k(b.contactPointB, b.contactPointB, g.position), this.contactEquations.push(b), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b)), 1) : 0
                };
            d.prototype[u.CIRCLE] = d.prototype.circleCircle = function(a, b, e, d, f, g, l, m, n, q, s) {
                q = q || b.radius;
                s = s || g.radius;
                k(r, e, l);
                d = q + s;
                if (h.squaredLength(r) > d * d) return 0;
                if (n) return !0;
                b = this.createContactEquation(a,
                    f, b, g);
                k(b.normalA, l, e);
                h.normalize(b.normalA, b.normalA);
                h.scale(b.contactPointA, b.normalA, q);
                h.scale(b.contactPointB, b.normalA, -s);
                p(b.contactPointA, b.contactPointA, e);
                k(b.contactPointA, b.contactPointA, a.position);
                p(b.contactPointB, b.contactPointB, l);
                k(b.contactPointB, b.contactPointB, f.position);
                this.contactEquations.push(b);
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b));
                return 1
            };
            d.prototype[u.PLANE | u.CONVEX] = d.prototype[u.PLANE | u.RECTANGLE] = d.prototype.planeConvex =
                function(a, b, e, f, g, m, n, q, s) {
                    var t = 0;
                    h.rotate(x, A, f);
                    for (f = 0; f < m.vertices.length; f++)
                        if (h.rotate(r, m.vertices[f], q), p(r, r, n), k(z, r, e), l(z, x) <= d.convexPrecision) {
                            if (s) return !0;
                            t++;
                            var u = this.createContactEquation(a, g, b, m);
                            k(z, r, e);
                            h.copy(u.normalA, x);
                            var G = l(z, u.normalA);
                            h.scale(z, u.normalA, G);
                            k(u.contactPointB, r, g.position);
                            k(u.contactPointA, r, z);
                            k(u.contactPointA, u.contactPointA, a.position);
                            this.contactEquations.push(u);
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(u))
                        }
                    return t
                };
            d.prototype.convexPlane = function(a, b, e, d, f, h, g, k, l) {
                console.warn("Narrowphase.prototype.convexPlane is deprecated. Use planeConvex instead!");
                return this.planeConvex(f, h, g, k, a, b, e, d, l)
            };
            d.prototype[u.PARTICLE | u.PLANE] = d.prototype.particlePlane = function(a, b, e, d, f, g, m, p, n) {
                d = p || 0;
                k(r, e, m);
                h.rotate(x, A, d);
                m = l(r, x);
                if (0 < m) return 0;
                if (n) return !0;
                b = this.createContactEquation(f, a, g, b);
                h.copy(b.normalA, x);
                h.scale(r, b.normalA, m);
                k(b.contactPointA, e, r);
                k(b.contactPointA, b.contactPointA, f.position);
                k(b.contactPointB,
                    e, a.position);
                this.contactEquations.push(b);
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b));
                return 1
            };
            d.prototype[u.CIRCLE | u.PARTICLE] = d.prototype.circleParticle = function(a, b, e, d, f, g, l, m, n) {
                k(r, l, e);
                if (h.squaredLength(r) > b.radius * b.radius) return 0;
                if (n) return !0;
                d = this.createContactEquation(a, f, b, g);
                h.copy(d.normalA, r);
                h.normalize(d.normalA, d.normalA);
                h.scale(d.contactPointA, d.normalA, b.radius);
                p(d.contactPointA, d.contactPointA, e);
                k(d.contactPointA, d.contactPointA,
                    a.position);
                k(d.contactPointB, l, f.position);
                this.contactEquations.push(d);
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d));
                return 1
            };
            var la = new b(1),
                ba = h.create(),
                G = h.create();
            h.create();
            d.prototype[u.PLANE | u.CAPSULE] = d.prototype.planeCapsule = function(a, b, e, d, f, g, k, l, m) {
                h.set(ba, -g.length / 2, 0);
                h.rotate(ba, ba, l);
                p(ba, ba, k);
                h.set(G, g.length / 2, 0);
                h.rotate(G, G, l);
                p(G, G, k);
                la.radius = g.radius;
                g = this.circlePlane(f, la, ba, 0, a, b, e, d, m);
                a = this.circlePlane(f, la, G, 0, a, b, e, d,
                    m);
                return m ? g || a : g + a
            };
            d.prototype.capsulePlane = function(a, b, e, d, f, h, g, k, l) {
                console.warn("Narrowphase.prototype.capsulePlane() is deprecated. Use .planeCapsule() instead!");
                return this.planeCapsule(f, h, g, k, a, b, e, d, l)
            };
            d.prototype[u.CIRCLE | u.PLANE] = d.prototype.circlePlane = function(a, b, e, d, f, g, m, n, q) {
                d = n || 0;
                k(r, e, m);
                h.rotate(x, A, d);
                d = l(x, r);
                if (d > b.radius) return 0;
                if (q) return !0;
                g = this.createContactEquation(f, a, g, b);
                h.copy(g.normalA, x);
                h.scale(g.contactPointB, g.normalA, -b.radius);
                p(g.contactPointB, g.contactPointB,
                    e);
                k(g.contactPointB, g.contactPointB, a.position);
                h.scale(z, g.normalA, d);
                k(g.contactPointA, r, z);
                p(g.contactPointA, g.contactPointA, m);
                k(g.contactPointA, g.contactPointA, f.position);
                this.contactEquations.push(g);
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g));
                return 1
            };
            d.convexPrecision = 1E-7;
            d.prototype[u.CONVEX] = d.prototype[u.CONVEX | u.RECTANGLE] = d.prototype[u.RECTANGLE] = d.prototype.convexConvex = function(a, b, e, f, g, m, n, q, s, t) {
                var u = 0;
                t = t || d.convexPrecision;
                if (!d.findSeparatingAxis(b,
                        e, f, m, n, q, r)) return 0;
                k(y, n, e);
                0 < l(r, y) && h.scale(r, r, -1);
                var G = d.getClosestEdge(b, f, r, !0),
                    ma = d.getClosestEdge(m, q, r);
                if (-1 === G || -1 === ma) return 0;
                for (var A = 0; 2 > A; A++) {
                    var v = G,
                        ca = ma,
                        L = b,
                        N = m,
                        O = e,
                        U = n,
                        C = f,
                        E = q,
                        $ = a,
                        ea = g;
                    if (0 === A) {
                        var K;
                        K = v;
                        v = ca;
                        ca = K;
                        K = L;
                        L = N;
                        N = K;
                        K = O;
                        O = U;
                        U = K;
                        K = C;
                        C = E;
                        E = K;
                        K = $;
                        $ = ea;
                        ea = K
                    }
                    for (K = ca; K < ca + 2; K++) {
                        h.rotate(x, N.vertices[(K + N.vertices.length) % N.vertices.length], E);
                        p(x, x, U);
                        for (var J = 0, da = v - 1; da < v + 2; da++) {
                            var H = L.vertices[(da + L.vertices.length) % L.vertices.length],
                                I = L.vertices[(da + 1 + L.vertices.length) %
                                    L.vertices.length];
                            h.rotate(z, H, C);
                            h.rotate(w, I, C);
                            p(z, z, O);
                            p(w, w, O);
                            k(B, w, z);
                            h.rotate90cw(D, B);
                            h.normalize(D, D);
                            k(y, x, z);
                            H = l(D, y);
                            H <= t && J++
                        }
                        if (3 <= J) {
                            if (s) return !0;
                            J = this.createContactEquation($, ea, L, N);
                            u++;
                            H = L.vertices[v % L.vertices.length];
                            I = L.vertices[(v + 1) % L.vertices.length];
                            h.rotate(z, H, C);
                            h.rotate(w, I, C);
                            p(z, z, O);
                            p(w, w, O);
                            k(B, w, z);
                            h.rotate90cw(J.normalA, B);
                            h.normalize(J.normalA, J.normalA);
                            k(y, x, z);
                            H = l(J.normalA, y);
                            h.scale(F, J.normalA, H);
                            k(J.contactPointA, x, O);
                            k(J.contactPointA, J.contactPointA,
                                F);
                            p(J.contactPointA, J.contactPointA, O);
                            k(J.contactPointA, J.contactPointA, $.position);
                            k(J.contactPointB, x, U);
                            p(J.contactPointB, J.contactPointB, U);
                            k(J.contactPointB, J.contactPointB, ea.position);
                            this.contactEquations.push(J);
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(J))
                        }
                    }
                }
                return u
            };
            var ca = h.fromValues(0, 0);
            d.projectConvexOntoAxis = function(a, b, e, d, f) {
                var g = null,
                    k = null,
                    m;
                h.rotate(ca, d, -e);
                for (e = 0; e < a.vertices.length; e++) {
                    m = a.vertices[e];
                    m = l(m, ca);
                    if (null === g || m > g) g =
                        m;
                    if (null === k || m < k) k = m
                }
                k > g && (a = k, k = g, g = a);
                b = l(b, d);
                h.set(f, k + b, g + b)
            };
            var ma = h.fromValues(0, 0),
                L = h.fromValues(0, 0),
                da = h.fromValues(0, 0),
                N = h.fromValues(0, 0),
                J = h.fromValues(0, 0),
                $ = h.fromValues(0, 0);
            d.findSeparatingAxis = function(a, b, e, f, g, l, m) {
                for (var p = null, n = !1, q = !1, s = 0; 2 !== s; s++) {
                    var t = a,
                        u = e;
                    1 === s && (t = f, u = l);
                    for (var r = 0; r !== t.vertices.length; r++) {
                        h.rotate(L, t.vertices[r], u);
                        h.rotate(da, t.vertices[(r + 1) % t.vertices.length], u);
                        k(ma, da, L);
                        h.rotate90cw(N, ma);
                        h.normalize(N, N);
                        d.projectConvexOntoAxis(a, b,
                            e, N, J);
                        d.projectConvexOntoAxis(f, g, l, N, $);
                        var n = J,
                            G = $;
                        J[0] > $[0] && (G = J, n = $);
                        G = G[0] - n[1];
                        n = G <= d.convexPrecision;
                        if (null === p || G > p) h.copy(m, N), p = G, q = n
                    }
                }
                return q
            };
            var O = h.fromValues(0, 0),
                ea = h.fromValues(0, 0),
                K = h.fromValues(0, 0);
            d.getClosestEdge = function(a, b, e, d) {
                h.rotate(O, e, -b);
                d && h.scale(O, O, -1);
                b = -1;
                e = a.vertices.length;
                for (d = 0; d !== e; d++) {
                    k(ea, a.vertices[(d + 1) % e], a.vertices[d % e]);
                    h.rotate90cw(K, ea);
                    h.normalize(K, K);
                    var f = l(K, O);
                    if (-1 == b || f > maxDot) b = d % e, maxDot = f
                }
                return b
            };
            var fa = h.create(),
                ga = h.create(),
                T = h.create(),
                U = h.create(),
                ta = h.create(),
                aa = h.create(),
                ua = h.create();
            d.prototype[u.CIRCLE | u.HEIGHTFIELD] = d.prototype.circleHeightfield = function(a, b, e, d, f, g, l, m, n, q) {
                d = g.data;
                q = q || b.radius;
                m = g.elementWidth;
                var s = Math.floor((e[0] - q - l[0]) / m),
                    t = Math.ceil((e[0] + q - l[0]) / m);
                0 > s && (s = 0);
                t >= d.length && (t = d.length - 1);
                for (var u = d[s], r = d[t], G = s; G < t; G++) d[G] < r && (r = d[G]), d[G] > u && (u = d[G]);
                if (e[1] - q > u) return n ? !1 : 0;
                u = !1;
                for (G = s; G < t; G++)
                    if (h.set(T, G * m, d[G]), h.set(U, (G + 1) * m, d[G + 1]), h.add(T, T, l), h.add(U, U, l), h.sub(aa,
                            U, T), h.rotate(aa, aa, Math.PI / 2), h.normalize(aa, aa), h.scale(fa, aa, -q), h.add(fa, fa, e), h.sub(ga, fa, T), u = h.dot(ga, aa), fa[0] >= T[0] && fa[0] < U[0] && 0 >= u) {
                        if (n) return !0;
                        h.scale(ga, aa, -u);
                        h.add(ta, fa, ga);
                        h.copy(ua, aa);
                        r = this.createContactEquation(f, a, g, b);
                        h.copy(r.normalA, ua);
                        h.scale(r.contactPointB, r.normalA, -q);
                        p(r.contactPointB, r.contactPointB, e);
                        k(r.contactPointB, r.contactPointB, a.position);
                        h.copy(r.contactPointA, ta);
                        h.sub(r.contactPointA, r.contactPointA, f.position);
                        this.contactEquations.push(r);
                        this.enableFriction &&
                            this.frictionEquations.push(this.createFrictionFromContact(r))
                    }
                u = !1;
                if (0 < q)
                    for (G = s; G <= t; G++)
                        if (h.set(T, G * m, d[G]), h.add(T, T, l), h.sub(ga, e, T), h.squaredLength(ga) < q * q) {
                            if (n) return !0;
                            u = !0;
                            r = this.createContactEquation(f, a, g, b);
                            h.copy(r.normalA, ga);
                            h.normalize(r.normalA, r.normalA);
                            h.scale(r.contactPointB, r.normalA, -q);
                            p(r.contactPointB, r.contactPointB, e);
                            k(r.contactPointB, r.contactPointB, a.position);
                            k(r.contactPointA, T, l);
                            p(r.contactPointA, r.contactPointA, l);
                            k(r.contactPointA, r.contactPointA, f.position);
                            this.contactEquations.push(r);
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(r))
                        }
                return u ? 1 : 0
            };
            var ha = h.create(),
                ia = h.create(),
                sa = h.create(),
                V = new t([h.create(), h.create(), h.create(), h.create()]);
            d.prototype[u.RECTANGLE | u.HEIGHTFIELD] = d.prototype[u.CONVEX | u.HEIGHTFIELD] = d.prototype.convexHeightfield = function(a, b, e, d, f, g, k, l, m) {
                l = g.data;
                g = g.elementWidth;
                var p = Math.floor((a.aabb.lowerBound[0] - k[0]) / g),
                    n = Math.ceil((a.aabb.upperBound[0] - k[0]) / g);
                0 > p && (p = 0);
                n >= l.length &&
                    (n = l.length - 1);
                for (var q = l[p], s = l[n], t = p; t < n; t++) l[t] < s && (s = l[t]), l[t] > q && (q = l[t]);
                if (a.aabb.lowerBound[1] > q) return m ? !1 : 0;
                q = 0;
                for (t = p; t < n; t++) h.set(ha, t * g, l[t]), h.set(ia, (t + 1) * g, l[t + 1]), h.add(ha, ha, k), h.add(ia, ia, k), h.set(sa, 0.5 * (ia[0] + ha[0]), 0.5 * (ia[1] + ha[1] - 100)), h.sub(V.vertices[0], ia, sa), h.sub(V.vertices[1], ha, sa), h.copy(V.vertices[2], V.vertices[1]), h.copy(V.vertices[3], V.vertices[0]), V.vertices[2][1] -= 100, V.vertices[3][1] -= 100, q += this.convexConvex(a, b, e, d, f, V, sa, 0, m);
                return q
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Circle": 35,
            "../shapes/Convex": 36,
            "../shapes/Rectangle": 41,
            "../shapes/Shape": 42,
            "../utils/TupleDictionary": 46,
            "../utils/Utils": 47
        }],
        13: [function(g, a, b) {
            function d() {
                f.call(this, f.SAP);
                this.axisList = [];
                this.world = null;
                this.axisIndex = 0;
                var a = this.axisList;
                this._addBodyHandler = function(b) {
                    a.push(b.body)
                };
                this._removeBodyHandler = function(b) {
                    b = a.indexOf(b.body); - 1 !== b && a.splice(b, 1)
                }
            }
            var e = g("../utils/Utils"),
                f = g("../collision/Broadphase");
            a.exports = d;
            d.prototype = new f;
            d.prototype.setWorld = function(a) {
                this.axisList.length = 0;
                e.appendArray(this.axisList, a.bodies);
                a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                this.world = a
            };
            d.sortAxisList = function(a, b) {
                b |= 0;
                for (var e = 1, d = a.length; e < d; e++) {
                    for (var f = a[e], g = e - 1; 0 <= g && !(a[g].aabb.lowerBound[b] <= f.aabb.lowerBound[b]); g--) a[g + 1] = a[g];
                    a[g + 1] = f
                }
                return a
            };
            d.prototype.getCollisionPairs = function(a) {
                a = this.axisList;
                var b = this.result,
                    e = this.axisIndex;
                b.length = 0;
                for (var g = a.length; g--;) {
                    var m = a[g];
                    m.aabbNeedsUpdate && m.updateAABB()
                }
                d.sortAxisList(a, e);
                g = 0;
                for (m = a.length | 0; g !== m; g++)
                    for (var n = a[g], q = g + 1; q < m; q++) {
                        var s = a[q];
                        if (!(s.aabb.lowerBound[e] <= n.aabb.upperBound[e])) break;
                        f.canCollide(n, s) && this.boundingVolumeCheck(n, s) && b.push(n, s)
                    }
                return b
            }
        }, {
            "../collision/Broadphase": 9,
            "../utils/Utils": 47
        }],
        14: [function(g, a, b) {
            function d(a, b, d, g) {
                this.type = d;
                g = e.defaults(g, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                });
                this.equations = [];
                this.bodyA = a;
                this.bodyB = b;
                this.collideConnected = g.collideConnected;
                g.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp())
            }
            a.exports = d;
            var e = g("../utils/Utils");
            d.prototype.update = function() {
                throw Error("method update() not implmemented in this Constraint subclass!");
            };
            d.DISTANCE = 1;
            d.GEAR = 2;
            d.LOCK = 3;
            d.PRISMATIC = 4;
            d.REVOLUTE = 5;
            d.prototype.setStiffness = function(a) {
                for (var b = this.equations, e = 0; e !== b.length; e++) {
                    var d = b[e];
                    d.stiffness = a;
                    d.needsUpdate = !0
                }
            };
            d.prototype.setRelaxation = function(a) {
                for (var b = this.equations, e = 0; e !== b.length; e++) {
                    var d = b[e];
                    d.relaxation = a;
                    d.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 47
        }],
        15: [function(g, a, b) {
            function d(a, b, d, g) {
                g = g || {};
                e.call(this, a, b, e.DISTANCE, g);
                this.distance = d;
                this.localAnchorA = h.create();
                this.localAnchorB = h.create();
                var k = this.localAnchorA,
                    l = this.localAnchorB;
                d = "undefined" === typeof g.maxForce ? Number.MAX_VALUE : g.maxForce;
                a = new f(a, b, -d, d);
                this.equations = [a];
                var p = h.create(),
                    A = h.create(),
                    r = h.create(),
                    x = this;
                a.computeGq =
                    function() {
                        var a = this.bodyA,
                            b = this.bodyB,
                            e = a.position;
                        h.rotate(A, k, a.angle);
                        h.rotate(r, l, b.angle);
                        h.add(p, e, r);
                        h.sub(p, p, A);
                        h.sub(p, p, e);
                        h.sub(p, b.position, a.position);
                        return h.length(p) - x.distance
                    };
                this.setMaxForce(d)
            }
            var e = g("./Constraint"),
                f = g("../equations/Equation"),
                h = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            var k = h.create(),
                p = h.create(),
                l = h.create();
            d.prototype.update = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    e = this.equations[0].G;
                h.rotate(p, this.localAnchorA, a.angle);
                h.rotate(l, this.localAnchorB,
                    b.angle);
                h.crossLength(p, k);
                h.crossLength(l, k);
                h.sub(k, b.position, a.position);
                h.normalize(k, k);
                e[0] = -k[0];
                e[1] = -k[1];
                e[3] = k[0];
                e[4] = k[1]
            };
            d.prototype.setMaxForce = function(a) {
                var b = this.equations[0];
                b.minForce = -a;
                b.maxForce = a
            };
            d.prototype.getMaxForce = function(a) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        16: [function(g, a, b) {
                function d(a, b, d) {
                    d = d || {};
                    e.call(this, a, b, e.GEAR, d);
                    this.equations = [new f(a, b, d)];
                    this.angle = "number" === typeof d.angle ?
                        d.angle : 0;
                    this.ratio = "number" === typeof d.ratio ? d.ratio : 1;
                    "number" === typeof d.maxTorque && this.setMaxTorque(d.maxTorque)
                }
                var e = g("./Constraint");
                g("../equations/Equation");
                var f = g("../equations/AngleLockEquation");
                g("../math/vec2");
                a.exports = d;
                d.prototype = new e;
                d.prototype.update = function() {
                    var a = this.equations[0];
                    a.ratio !== this.ratio && a.setRatio(this.ratio);
                    a.angle = this.angle
                };
                d.prototype.setMaxTorque = function(a) {
                    this.equations[0].setMaxTorque(a)
                };
                d.prototype.getMaxTorque = function(a) {
                    return this.equations[0].maxForce
                }
            },
            {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        17: [function(g, a, b) {
            function d(a, b, d) {
                d = d || {};
                e.call(this, a, b, e.LOCK, d);
                var g = "undefined" === typeof d.maxForce ? Number.MAX_VALUE : d.maxForce,
                    k = d.localOffsetB || f.fromValues(0, 0),
                    k = f.fromValues(k[0], k[1]);
                d = d.localAngleB || 0;
                var l = new h(a, b, -g, g),
                    m = new h(a, b, -g, g),
                    p = new h(a, b, -g, g),
                    n = f.create(),
                    w = f.create(),
                    B = this;
                l.computeGq = function() {
                    f.rotate(n, B.localOffsetB, a.angle);
                    f.sub(w, b.position, a.position);
                    f.sub(w, w, n);
                    return w[0]
                };
                m.computeGq = function() {
                    f.rotate(n, B.localOffsetB, a.angle);
                    f.sub(w, b.position, a.position);
                    f.sub(w, w, n);
                    return w[1]
                };
                var C = f.create(),
                    F = f.create();
                p.computeGq = function() {
                    f.rotate(C, B.localOffsetB, b.angle - B.localAngleB);
                    f.scale(C, C, -1);
                    f.sub(w, a.position, b.position);
                    f.add(w, w, C);
                    f.rotate(F, C, -Math.PI / 2);
                    f.normalize(F, F);
                    return f.dot(w, F)
                };
                this.localOffsetB = k;
                this.localAngleB = d;
                this.equations.push(l, m, p);
                this.setMaxForce(g)
            }
            var e = g("./Constraint"),
                f = g("../math/vec2"),
                h = g("../equations/Equation");
            a.exports = d;
            d.prototype = new e;
            d.prototype.setMaxForce = function(a) {
                for (var b = this.equations, e = 0; e < this.equations.length; e++) b[e].maxForce = a, b[e].minForce = -a
            };
            d.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var k = f.create(),
                p = f.create(),
                l = f.create(),
                m = f.fromValues(1, 0),
                n = f.fromValues(0, 1);
            d.prototype.update = function() {
                var a = this.equations[0],
                    b = this.equations[1],
                    e = this.equations[2],
                    d = this.bodyB;
                f.rotate(k, this.localOffsetB, this.bodyA.angle);
                f.rotate(p, this.localOffsetB, d.angle -
                    this.localAngleB);
                f.scale(p, p, -1);
                f.rotate(l, p, Math.PI / 2);
                f.normalize(l, l);
                a.G[0] = -1;
                a.G[1] = 0;
                a.G[2] = -f.crossLength(k, m);
                a.G[3] = 1;
                b.G[0] = 0;
                b.G[1] = -1;
                b.G[2] = -f.crossLength(k, n);
                b.G[4] = 1;
                e.G[0] = -l[0];
                e.G[1] = -l[1];
                e.G[3] = l[0];
                e.G[4] = l[1];
                e.G[5] = f.crossLength(p, l)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(g, a, b) {
            function d(a, b, d) {
                d = d || {};
                e.call(this, a, b, e.PRISMATIC, d);
                var g = k.fromValues(0, 0),
                    l = k.fromValues(1, 0),
                    m = k.fromValues(0, 0);
                d.localAnchorA && k.copy(g, d.localAnchorA);
                d.localAxisA && k.copy(l, d.localAxisA);
                d.localAnchorB && k.copy(m, d.localAnchorB);
                this.localAnchorA = g;
                this.localAnchorB = m;
                this.localAxisA = l;
                var n = this.maxForce = "undefined" != typeof d.maxForce ? d.maxForce : Number.MAX_VALUE,
                    q = new h(a, b, -n, n),
                    s = new k.create,
                    v = new k.create,
                    y = new k.create,
                    D = new k.create;
                q.computeGq = function() {
                    return k.dot(y, D)
                };
                q.updateJacobian = function() {
                    var e = this.G,
                        d = a.position,
                        f = b.position;
                    k.rotate(s, g, a.angle);
                    k.rotate(v, m, b.angle);
                    k.add(y, f, v);
                    k.sub(y, y, d);
                    k.sub(y, y, s);
                    k.rotate(D, l, a.angle +
                        Math.PI / 2);
                    e[0] = -D[0];
                    e[1] = -D[1];
                    e[2] = -k.crossLength(s, D) + k.crossLength(D, y);
                    e[3] = D[0];
                    e[4] = D[1];
                    e[5] = k.crossLength(v, D)
                };
                this.equations.push(q);
                d.disableRotationalLock || (q = new p(a, b, -n, n), this.equations.push(q));
                this.velocity = this.position = 0;
                this.lowerLimitEnabled = "undefined" !== typeof d.lowerLimit ? !0 : !1;
                this.upperLimitEnabled = "undefined" !== typeof d.upperLimit ? !0 : !1;
                this.lowerLimit = "undefined" !== typeof d.lowerLimit ? d.lowerLimit : 0;
                this.upperLimit = "undefined" !== typeof d.upperLimit ? d.upperLimit : 1;
                this.upperLimitEquation =
                    new f(a, b);
                this.lowerLimitEquation = new f(a, b);
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = n;
                this.motorEquation = new h(a, b);
                this.motorEnabled = !1;
                this.motorSpeed = 0;
                var I = this;
                d = this.motorEquation;
                d.computeGq = function() {
                    return 0
                };
                d.computeGW = function() {
                    var a = this.bodyA,
                        b = this.bodyB;
                    return this.transformedGmult(this.G, a.velocity, a.angularVelocity, b.velocity, b.angularVelocity) + I.motorSpeed
                }
            }
            var e = g("./Constraint"),
                f = g("../equations/ContactEquation"),
                h = g("../equations/Equation"),
                k = g("../math/vec2"),
                p = g("../equations/RotationalLockEquation");
            a.exports = d;
            d.prototype = new e;
            var l = k.create(),
                m = k.create(),
                n = k.create(),
                q = k.create(),
                s = k.create(),
                v = k.create();
            d.prototype.update = function() {
                var a = this.equations,
                    b = this.upperLimit,
                    e = this.lowerLimit,
                    d = this.upperLimitEquation,
                    f = this.lowerLimitEquation,
                    h = this.bodyA,
                    g = this.bodyB,
                    p = this.localAxisA,
                    C = this.localAnchorA,
                    F = this.localAnchorB;
                a[0].updateJacobian();
                k.rotate(l, p, h.angle);
                k.rotate(q, C, h.angle);
                k.add(m, q, h.position);
                k.rotate(s, F, g.angle);
                k.add(n, s, g.position);
                p = this.position = k.dot(n, l) - k.dot(m, l);
                this.motorEnabled && (C = this.motorEquation.G, C[0] = l[0], C[1] = l[1], C[2] = k.crossLength(l, s), C[3] = -l[0], C[4] = -l[1], C[5] = -k.crossLength(l, q));
                this.upperLimitEnabled && p > b ? (k.scale(d.normalA, l, -1), k.sub(d.contactPointA, m, h.position), k.sub(d.contactPointB, n, g.position), k.scale(v, l, b), k.add(d.contactPointA, d.contactPointA, v), -1 == a.indexOf(d) && a.push(d)) : (b = a.indexOf(d), -1 != b && a.splice(b,
                    1));
                this.lowerLimitEnabled && p < e ? (k.scale(f.normalA, l, 1), k.sub(f.contactPointA, m, h.position), k.sub(f.contactPointB, n, g.position), k.scale(v, l, e), k.sub(f.contactPointB, f.contactPointB, v), -1 == a.indexOf(f) && a.push(f)) : (b = a.indexOf(f), -1 != b && a.splice(b, 1))
            };
            d.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            };
            d.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a,
                        1);
                    this.motorEnabled = !1
                }
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(g, a, b) {
            function d(a, b, d, g, r) {
                r = r || {};
                e.call(this, a, d, e.REVOLUTE, r);
                r = this.maxForce = "undefined" !== typeof r.maxForce ? r.maxForce : Number.MAX_VALUE;
                this.pivotA = p.fromValues(b[0], b[1]);
                this.pivotB = p.fromValues(g[0], g[1]);
                g = this.equations = [new f(a, d, -r, r), new f(a, d, -r, r)];
                b = g[0];
                g = g[1];
                var x = this;
                b.computeGq = function() {
                    p.rotate(l,
                        x.pivotA, a.angle);
                    p.rotate(m, x.pivotB, d.angle);
                    p.add(s, d.position, m);
                    p.sub(s, s, a.position);
                    p.sub(s, s, l);
                    return p.dot(s, n)
                };
                g.computeGq = function() {
                    p.rotate(l, x.pivotA, a.angle);
                    p.rotate(m, x.pivotB, d.angle);
                    p.add(s, d.position, m);
                    p.sub(s, s, a.position);
                    p.sub(s, s, l);
                    return p.dot(s, q)
                };
                g.minForce = b.minForce = -r;
                g.maxForce = b.maxForce = r;
                this.motorEquation = new h(a, d);
                this.motorEnabled = !1;
                this.angle = 0;
                this.upperLimitEnabled = this.lowerLimitEnabled = !1;
                this.upperLimit = this.lowerLimit = 0;
                this.upperLimitEquation = new k(a,
                    d);
                this.lowerLimitEquation = new k(a, d);
                this.upperLimitEquation.minForce = 0;
                this.lowerLimitEquation.maxForce = 0
            }
            var e = g("./Constraint"),
                f = g("../equations/Equation"),
                h = g("../equations/RotationalVelocityEquation"),
                k = g("../equations/RotationalLockEquation"),
                p = g("../math/vec2");
            a.exports = d;
            var l = p.create(),
                m = p.create(),
                n = p.fromValues(1, 0),
                q = p.fromValues(0, 1),
                s = p.create();
            d.prototype = new e;
            d.prototype.update = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    e = this.pivotA,
                    d = this.pivotB,
                    f = this.equations,
                    h = f[0],
                    g = f[1],
                    k = this.upperLimit,
                    s = this.lowerLimit,
                    C = this.upperLimitEquation,
                    F = this.lowerLimitEquation,
                    y = this.angle = b.angle - a.angle;
                this.upperLimitEnabled && y > k ? (C.angle = k, -1 == f.indexOf(C) && f.push(C)) : (k = f.indexOf(C), -1 != k && f.splice(k, 1));
                this.lowerLimitEnabled && y < s ? (F.angle = s, -1 == f.indexOf(F) && f.push(F)) : (k = f.indexOf(F), -1 != k && f.splice(k, 1));
                p.rotate(l, e, a.angle);
                p.rotate(m, d, b.angle);
                h.G[0] = -1;
                h.G[1] = 0;
                h.G[2] = -p.crossLength(l, n);
                h.G[3] = 1;
                h.G[4] = 0;
                h.G[5] = p.crossLength(m, n);
                g.G[0] = 0;
                g.G[1] = -1;
                g.G[2] = -p.crossLength(l,
                    q);
                g.G[3] = 0;
                g.G[4] = 1;
                g.G[5] = p.crossLength(m, q)
            };
            d.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            };
            d.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1);
                    this.motorEnabled = !1
                }
            };
            d.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            };
            d.prototype.setMotorSpeed = function(a) {
                if (this.motorEnabled) {
                    var b = this.equations.indexOf(this.motorEquation);
                    this.equations[b].relativeVelocity =
                        a
                }
            };
            d.prototype.getMotorSpeed = function() {
                return !this.motorEnabled ? !1 : this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(g, a, b) {
            function d(a, b, d) {
                d = d || {};
                e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = d.angle || 0;
                this.ratio = "number" === typeof d.ratio ? d.ratio : 1;
                this.setRatio(this.ratio)
            }
            var e = g("./Equation");
            g("../math/vec2");
            a.exports =
                d;
            d.prototype = new e;
            d.prototype.constructor = d;
            d.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            };
            d.prototype.setRatio = function(a) {
                var b = this.G;
                b[2] = a;
                b[5] = -1;
                this.ratio = a
            };
            d.prototype.setMaxTorque = function(a) {
                this.maxForce = a;
                this.minForce = -a
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(g, a, b) {
            function d(a, b) {
                e.call(this, a, b, 0, Number.MAX_VALUE);
                this.contactPointA = f.create();
                this.penetrationVec = f.create();
                this.contactPointB = f.create();
                this.normalA =
                    f.create();
                this.restitution = 0;
                this.firstImpact = !1;
                this.shapeB = this.shapeA = null
            }
            var e = g("./Equation"),
                f = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.constructor = d;
            d.prototype.computeB = function(a, b, e) {
                var d = this.contactPointA,
                    g = this.contactPointB,
                    n = this.bodyA.position,
                    q = this.bodyB.position,
                    s = this.penetrationVec,
                    v = this.normalA,
                    t = this.G,
                    u = f.crossLength(d, v),
                    A = f.crossLength(g, v);
                t[0] = -v[0];
                t[1] = -v[1];
                t[2] = -u;
                t[3] = v[0];
                t[4] = v[1];
                t[5] = A;
                f.add(s, q, g);
                f.sub(s, s, n);
                f.sub(s, s, d);
                this.firstImpact &&
                    0 !== this.restitution ? (g = 0, d = 1 / b * (1 + this.restitution) * this.computeGW()) : (g = f.dot(v, s), d = this.computeGW());
                n = this.computeGiMf();
                return -g * a - d * b - e * n
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(g, a, b) {
            function d(a, b, e, f) {
                this.minForce = "undefined" === typeof e ? -Number.MAX_VALUE : e;
                this.maxForce = "undefined" === typeof f ? Number.MAX_VALUE : f;
                this.bodyA = a;
                this.bodyB = b;
                this.stiffness = d.DEFAULT_STIFFNESS;
                this.relaxation = d.DEFAULT_RELAXATION;
                this.G = new p.ARRAY_TYPE(6);
                for (a = 0; 6 > a; a++) this.G[a] = 0;
                this.epsilon =
                    this.b = this.a = this.offset = 0;
                this.timeStep = 1 / 60;
                this.needsUpdate = !0;
                this.relativeVelocity = this.multiplier = 0;
                this.enabled = !0
            }

            function e(a, b, e, d, f) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * e + a[3] * d[0] + a[4] * d[1] + a[5] * f
            }

            function f(a) {
                return a.sleepState === l.SLEEPING ? 0 : a.invMass
            }

            function h(a) {
                return a.sleepState === l.SLEEPING ? 0 : a.invInertia
            }
            a.exports = d;
            var k = g("../math/vec2"),
                p = g("../utils/Utils"),
                l = g("../objects/Body");
            d.prototype.constructor = d;
            d.DEFAULT_STIFFNESS = 1E6;
            d.DEFAULT_RELAXATION = 4;
            d.prototype.update = function() {
                var a =
                    this.stiffness,
                    b = this.relaxation,
                    e = this.timeStep;
                this.a = 4 / (e * (1 + 4 * b));
                this.b = 4 * b / (1 + 4 * b);
                this.epsilon = 4 / (e * e * a * (1 + 4 * b));
                this.needsUpdate = !1
            };
            d.prototype.computeB = function(a, b, e) {
                var d = this.computeGW(),
                    f = this.computeGq(),
                    h = this.computeGiMf();
                return -f * a - d * b - h * e
            };
            var m = k.create(),
                n = k.create();
            d.prototype.computeGq = function() {
                return e(this.G, m, this.bodyA.angle, n, this.bodyB.angle) + this.offset
            };
            d.prototype.computeGW = function() {
                var a = this.bodyA,
                    b = this.bodyB;
                return e(this.G, a.velocity, a.angularVelocity, b.velocity,
                    b.angularVelocity) + this.relativeVelocity
            };
            d.prototype.computeGWlambda = function() {
                var a = this.bodyA,
                    b = this.bodyB;
                return e(this.G, a.vlambda, a.wlambda, b.vlambda, b.wlambda)
            };
            var q = k.create(),
                s = k.create();
            d.prototype.computeGiMf = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    d = a.force,
                    g = a.angularForce,
                    l = b.force,
                    m = b.angularForce,
                    p = f(a),
                    n = f(b),
                    a = h(a),
                    b = h(b),
                    t = this.G;
                k.scale(q, d, p);
                k.scale(s, l, n);
                return e(t, q, g * a, s, m * b)
            };
            d.prototype.computeGiMGt = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    e = f(a),
                    d = f(b),
                    a = h(a),
                    b = h(b),
                    g = this.G;
                return g[0] * g[0] * e + g[1] * g[1] * e + g[2] * g[2] * a + g[3] * g[3] * d + g[4] * g[4] * d + g[5] * g[5] * b
            };
            var v = k.create(),
                t = k.create(),
                u = k.create();
            k.create();
            k.create();
            k.create();
            d.prototype.addToWlambda = function(a) {
                var b = this.bodyA,
                    e = this.bodyB,
                    d = f(b),
                    g = f(e),
                    l = h(b),
                    m = h(e),
                    p = this.G;
                t[0] = p[0];
                t[1] = p[1];
                u[0] = p[3];
                u[1] = p[4];
                k.scale(v, t, d * a);
                k.add(b.vlambda, b.vlambda, v);
                b.wlambda += l * p[2] * a;
                k.scale(v, u, g * a);
                k.add(e.vlambda, e.vlambda, v);
                e.wlambda += m * p[5] * a
            };
            d.prototype.computeInvC = function(a) {
                return 1 / (this.computeGiMGt() +
                    a)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 47
        }],
        23: [function(g, a, b) {
            function d(a, b, d) {
                f.call(this, a, b, -d, d);
                this.contactPointA = e.create();
                this.contactPointB = e.create();
                this.t = e.create();
                this.shapeB = this.shapeA = this.contactEquation = null;
                this.frictionCoefficient = 0.3
            }
            var e = g("../math/vec2"),
                f = g("./Equation");
            g("../utils/Utils");
            a.exports = d;
            d.prototype = new f;
            d.prototype.constructor = d;
            d.prototype.setSlipForce = function(a) {
                this.maxForce = a;
                this.minForce = -a
            };
            d.prototype.getSlipForce = function() {
                return this.maxForce
            };
            d.prototype.computeB = function(a, b, d) {
                a = this.contactPointA;
                var f = this.contactPointB,
                    g = this.t,
                    n = this.G;
                n[0] = -g[0];
                n[1] = -g[1];
                n[2] = -e.crossLength(a, g);
                n[3] = g[0];
                n[4] = g[1];
                n[5] = e.crossLength(f, g);
                a = this.computeGW();
                f = this.computeGiMf();
                return -a * b - d * f
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 47,
            "./Equation": 22
        }],
        24: [function(g, a, b) {
            function d(a, b, d) {
                d = d || {};
                e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = d.angle || 0;
                a = this.G;
                a[2] = 1;
                a[5] = -1
            }
            var e = g("./Equation"),
                f = g("../math/vec2");
            a.exports =
                d;
            d.prototype = new e;
            d.prototype.constructor = d;
            var h = f.create(),
                k = f.create(),
                p = f.fromValues(1, 0),
                l = f.fromValues(0, 1);
            d.prototype.computeGq = function() {
                f.rotate(h, p, this.bodyA.angle + this.angle);
                f.rotate(k, l, this.bodyB.angle);
                return f.dot(h, k)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(g, a, b) {
            function d(a, b) {
                e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.ratio = this.relativeVelocity = 1
            }
            var e = g("./Equation");
            g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.constructor = d;
            d.prototype.computeB =
                function(a, b, e) {
                    a = this.G;
                    a[2] = -1;
                    a[5] = this.ratio;
                    a = this.computeGiMf();
                    return -this.computeGW() * b - e * a
                }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(g, a, b) {
            g = function() {};
            a.exports = g;
            g.prototype = {
                constructor: g,
                on: function(a, b, f) {
                    b.context = f || this;
                    void 0 === this._listeners && (this._listeners = {});
                    f = this._listeners;
                    void 0 === f[a] && (f[a] = []); - 1 === f[a].indexOf(b) && f[a].push(b);
                    return this
                },
                has: function(a, b) {
                    if (void 0 === this._listeners) return !1;
                    var f = this._listeners;
                    if (b) {
                        if (void 0 !== f[a] && -1 !== f[a].indexOf(b)) return !0
                    } else if (void 0 !==
                        f[a]) return !0;
                    return !1
                },
                off: function(a, b) {
                    if (void 0 === this._listeners) return this;
                    var f = this._listeners,
                        h = f[a].indexOf(b); - 1 !== h && f[a].splice(h, 1);
                    return this
                },
                emit: function(a) {
                    if (void 0 === this._listeners) return this;
                    var b = this._listeners[a.type];
                    if (void 0 !== b) {
                        a.target = this;
                        for (var f = 0, h = b.length; f < h; f++) {
                            var g = b[f];
                            g.call(g.context, a)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(g, a, b) {
            function d(a, b, g) {
                g = g || {};
                if (!(a instanceof e) || !(b instanceof e)) throw Error("First two arguments must be Material instances.");
                this.id = d.idCounter++;
                this.materialA = a;
                this.materialB = b;
                this.friction = "undefined" !== typeof g.friction ? Number(g.friction) : 0.3;
                this.restitution = "undefined" !== typeof g.restitution ? Number(g.restitution) : 0;
                this.stiffness = "undefined" !== typeof g.stiffness ? Number(g.stiffness) : f.DEFAULT_STIFFNESS;
                this.relaxation = "undefined" !== typeof g.relaxation ? Number(g.relaxation) : f.DEFAULT_RELAXATION;
                this.frictionStiffness = "undefined" !== typeof g.frictionStiffness ? Number(g.frictionStiffness) : f.DEFAULT_STIFFNESS;
                this.frictionRelaxation =
                    "undefined" !== typeof g.frictionRelaxation ? Number(g.frictionRelaxation) : f.DEFAULT_RELAXATION;
                this.surfaceVelocity = "undefined" !== typeof g.surfaceVelocity ? Number(g.surfaceVelocity) : 0
            }
            var e = g("./Material"),
                f = g("../equations/Equation");
            a.exports = d;
            d.idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(g, a, b) {
            function d() {
                this.id = d.idCounter++
            }
            a.exports = d;
            d.idCounter = 0
        }, {}],
        29: [function(g, a, b) {
            var d = {
                GetArea: function(a) {
                    if (6 > a.length) return 0;
                    for (var b = a.length - 2, d = 0, g = 0; g < b; g += 2) d +=
                        (a[g + 2] - a[g]) * (a[g + 1] + a[g + 3]);
                    d += (a[0] - a[b]) * (a[b + 1] + a[1]);
                    return 0.5 * -d
                },
                Triangulate: function(a) {
                    var b = a.length >> 1;
                    if (3 > b) return [];
                    for (var h = [], g = [], p = 0; p < b; p++) g.push(p);
                    for (p = 0; 3 < b;) {
                        var l = g[(p + 0) % b],
                            m = g[(p + 1) % b],
                            n = g[(p + 2) % b],
                            q = a[2 * l],
                            s = a[2 * l + 1],
                            v = a[2 * m],
                            t = a[2 * m + 1],
                            u = a[2 * n],
                            A = a[2 * n + 1],
                            r = !1;
                        if (d._convex(q, s, v, t, u, A))
                            for (var r = !0, x = 0; x < b; x++) {
                                var z = g[x];
                                if (!(z == l || z == m || z == n) && d._PointInTriangle(a[2 * z], a[2 * z + 1], q, s, v, t, u, A)) {
                                    r = !1;
                                    break
                                }
                            }
                        if (r) h.push(l, m, n), g.splice((p + 1) % b, 1), b--, p = 0;
                        else if (p++ >
                            3 * b) break
                    }
                    h.push(g[0], g[1], g[2]);
                    return h
                },
                _PointInTriangle: function(a, b, d, g, p, l, m, n) {
                    m -= d;
                    n -= g;
                    p -= d;
                    l -= g;
                    a -= d;
                    d = b - g;
                    b = m * m + n * n;
                    g = m * p + n * l;
                    m = m * a + n * d;
                    n = p * p + l * l;
                    p = p * a + l * d;
                    l = 1 / (b * n - g * g);
                    n = (n * m - g * p) * l;
                    m = (b * p - g * m) * l;
                    return 0 <= n && 0 <= m && 1 > n + m
                },
                _convex: function(a, b, d, g, p, l) {
                    return 0 <= (b - g) * (p - d) + (d - a) * (l - g)
                }
            };
            a.exports = d
        }, {}],
        30: [function(g, a, b) {
            var d = g("../../build/vec2").vec2;
            d.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0]
            };
            d.crossVZ = function(a, b, g) {
                d.rotate(a, b, -Math.PI / 2);
                d.scale(a, a, g);
                return a
            };
            d.crossZV = function(a, b, g) {
                d.rotate(a, g, Math.PI / 2);
                d.scale(a, a, b);
                return a
            };
            d.rotate = function(a, b, d) {
                var g = Math.cos(d);
                d = Math.sin(d);
                var p = b[0];
                b = b[1];
                a[0] = g * p - d * b;
                a[1] = d * p + g * b
            };
            d.rotate90cw = function(a, b) {
                a[0] = b[1];
                a[1] = -b[0]
            };
            d.toLocalFrame = function(a, b, g, k) {
                d.copy(a, b);
                d.sub(a, a, g);
                d.rotate(a, a, -k)
            };
            d.toGlobalFrame = function(a, b, g, k) {
                d.copy(a, b);
                d.rotate(a, a, k);
                d.add(a, a, g)
            };
            d.centroid = function(a, b, g, k) {
                d.add(a, b, g);
                d.add(a, a, k);
                d.scale(a, a, 1 / 3);
                return a
            };
            a.exports = d
        }, {
            "../../build/vec2": 1
        }],
        31: [function(g,
            a, b) {
            function d(a) {
                a = a || {};
                p.call(this);
                this.id = ++d._idCounter;
                this.world = null;
                this.shapes = [];
                this.shapeOffsets = [];
                this.shapeAngles = [];
                this.mass = a.mass || 0;
                this.invInertia = this.inertia = this.invMass = 0;
                this.fixedRotation = !!a.fixedRotation || !1;
                this.position = e.fromValues(0, 0);
                a.position && e.copy(this.position, a.position);
                this.interpolatedPosition = e.fromValues(0, 0);
                this.interpolatedAngle = 0;
                this.previousPosition = e.fromValues(0, 0);
                this.previousAngle = 0;
                this.velocity = e.fromValues(0, 0);
                a.velocity && e.copy(this.velocity,
                    a.velocity);
                this.vlambda = e.fromValues(0, 0);
                this.wlambda = 0;
                this.angle = a.angle || 0;
                this.angularVelocity = a.angularVelocity || 0;
                this.force = e.create();
                a.force && e.copy(this.force, a.force);
                this.angularForce = a.angularForce || 0;
                this.damping = "number" == typeof a.damping ? a.damping : 0.1;
                this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : 0.1;
                this.motionState = 0 === this.mass ? d.STATIC : d.DYNAMIC;
                this.boundingRadius = 0;
                this.aabb = new k;
                this.allowSleep = this.aabbNeedsUpdate = !0;
                this.wantsToSleep = !1;
                this.sleepState =
                    d.AWAKE;
                this.sleepSpeedLimit = 0.2;
                this.gravityScale = this.sleepTimeLimit = 1;
                this.timeLastSleepy = 0;
                this.concavePath = null;
                this.lastAngularDampingScale = this.lastDampingScale = 1;
                this.lastDampingTimeStep = -1;
                this._wakeUpAfterNarrowphase = !1;
                this.updateMassProperties()
            }
            var e = g("../math/vec2"),
                f = g("poly-decomp"),
                h = g("../shapes/Convex"),
                k = g("../collision/AABB"),
                p = g("../events/EventEmitter");
            a.exports = d;
            d.prototype = new p;
            d._idCounter = 0;
            d.prototype.setDensity = function(a) {
                this.mass = this.getArea() * a;
                this.updateMassProperties()
            };
            d.prototype.getArea = function() {
                for (var a = 0, b = 0; b < this.shapes.length; b++) a += this.shapes[b].area;
                return a
            };
            var l = new k,
                m = e.create();
            d.prototype.updateAABB = function() {
                for (var a = this.shapes, b = this.shapeOffsets, d = this.shapeAngles, f = a.length, g = 0; g !== f; g++) {
                    var h = a[g],
                        k = m,
                        p = d[g] + this.angle;
                    e.rotate(k, b[g], this.angle);
                    e.add(k, k, this.position);
                    h.computeAABB(l, k, p);
                    0 === g ? this.aabb.copy(l) : this.aabb.extend(l)
                }
                this.aabbNeedsUpdate = !1
            };
            d.prototype.updateBoundingRadius = function() {
                for (var a = this.shapes, b = this.shapeOffsets,
                        d = a.length, f = 0, g = 0; g !== d; g++) {
                    var h = a[g],
                        k = e.length(b[g]),
                        h = h.boundingRadius;
                    k + h > f && (f = k + h)
                }
                this.boundingRadius = f
            };
            d.prototype.addShape = function(a, b, d) {
                d = d || 0;
                b = b ? e.fromValues(b[0], b[1]) : e.fromValues(0, 0);
                this.shapes.push(a);
                this.shapeOffsets.push(b);
                this.shapeAngles.push(d);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = !0
            };
            d.prototype.removeShape = function(a) {
                a = this.shapes.indexOf(a);
                return -1 !== a ? (this.shapes.splice(a, 1), this.shapeOffsets.splice(a, 1), this.shapeAngles.splice(a,
                    1), this.aabbNeedsUpdate = !0) : !1
            };
            d.prototype.updateMassProperties = function() {
                if (this.motionState === d.STATIC || this.motionState === d.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var a = this.shapes,
                        b = a.length,
                        f = this.mass / b,
                        g = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var h = 0; h < b; h++) var k = a[h],
                            l = e.squaredLength(this.shapeOffsets[h]),
                            k = k.computeMomentOfInertia(f),
                            g = g + (k + f * l);
                        this.inertia = g;
                        this.invInertia = 0 <
                            g ? 1 / g : 0
                    }
                    this.invMass = 1 / this.mass
                }
            };
            var n = e.create();
            d.prototype.applyForce = function(a, b) {
                e.sub(n, b, this.position);
                e.add(this.force, this.force, a);
                var d = e.crossLength(n, a);
                this.angularForce += d
            };
            d.prototype.toLocalFrame = function(a, b) {
                e.toLocalFrame(a, b, this.position, this.angle)
            };
            d.prototype.toWorldFrame = function(a, b) {
                e.toGlobalFrame(a, b, this.position, this.angle)
            };
            d.prototype.fromPolygon = function(a, b) {
                b = b || {};
                for (var d = this.shapes.length; 0 <= d; --d) this.removeShape(this.shapes[d]);
                var g = new f.Polygon;
                g.vertices =
                    a;
                g.makeCCW();
                "number" == typeof b.removeCollinearPoints && g.removeCollinearPoints(b.removeCollinearPoints);
                if ("undefined" == typeof b.skipSimpleCheck && !g.isSimple()) return !1;
                this.concavePath = g.vertices.slice(0);
                for (d = 0; d < this.concavePath.length; d++) {
                    var k = [0, 0];
                    e.copy(k, this.concavePath[d]);
                    this.concavePath[d] = k
                }
                for (var g = b.optimalDecomp ? g.decomp() : g.quickDecomp(), l = e.create(), d = 0; d !== g.length; d++) {
                    for (var m = new h(g[d].vertices), p = 0; p !== m.vertices.length; p++) k = m.vertices[p], e.sub(k, k, m.centerOfMass);
                    e.scale(l, m.centerOfMass, 1);
                    m.updateTriangles();
                    m.updateCenterOfMass();
                    m.updateBoundingRadius();
                    this.addShape(m, l)
                }
                this.adjustCenterOfMass();
                return this.aabbNeedsUpdate = !0
            };
            e.fromValues(0, 0);
            var q = e.fromValues(0, 0),
                s = e.fromValues(0, 0),
                v = e.fromValues(0, 0);
            d.prototype.adjustCenterOfMass = function() {
                var a = 0;
                e.set(s, 0, 0);
                for (var b = 0; b !== this.shapes.length; b++) {
                    var d = this.shapes[b],
                        f = this.shapeOffsets[b];
                    e.scale(q, f, d.area);
                    e.add(s, s, q);
                    a += d.area
                }
                e.scale(v, s, 1 / a);
                for (b = 0; b !== this.shapes.length; b++)(f = this.shapeOffsets[b]) ||
                    (f = this.shapeOffsets[b] = e.create()), e.sub(f, f, v);
                e.add(this.position, this.position, v);
                for (b = 0; this.concavePath && b < this.concavePath.length; b++) e.sub(this.concavePath[b], this.concavePath[b], v);
                this.updateMassProperties();
                this.updateBoundingRadius()
            };
            d.prototype.setZeroForce = function() {
                e.set(this.force, 0, 0);
                this.angularForce = 0
            };
            d.prototype.resetConstraintVelocity = function() {
                e.set(this.vlambda, 0, 0);
                this.wlambda = 0
            };
            d.prototype.addConstraintVelocity = function() {
                var a = this.velocity;
                e.add(a, a, this.vlambda);
                this.angularVelocity += this.wlambda
            };
            d.prototype.applyDamping = function(a) {
                this.motionState === d.DYNAMIC && (a !== this.lastDampingTimeStep && (this.lastDampingScale = Math.pow(1 - this.damping, a), this.lastAngularDampingScale = Math.pow(1 - this.angularDamping, a), this.lastDampingTimeStep = a), a = this.velocity, e.scale(a, a, this.lastDampingScale), this.angularVelocity *= this.lastAngularDampingScale)
            };
            d.prototype.wakeUp = function() {
                var a = this.sleepState;
                this.sleepState = d.AWAKE;
                this.idleTime = 0;
                a !== d.AWAKE && this.emit(d.wakeUpEvent)
            };
            d.prototype.sleep = function() {
                this.sleepState = d.SLEEPING;
                this.angularForce = this.angularVelocity = 0;
                e.set(this.velocity, 0, 0);
                e.set(this.force, 0, 0);
                this.emit(d.sleepEvent)
            };
            d.prototype.sleepTick = function(a, b, f) {
                if (this.allowSleep && this.motionState !== d.SLEEPING) {
                    this.wantsToSleep = !1;
                    a = e.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2);
                    var g = Math.pow(this.sleepSpeedLimit, 2);
                    a >= g ? (this.idleTime = 0, this.sleepState = d.AWAKE) : (this.idleTime += f, this.sleepState = d.SLEEPY);
                    this.idleTime > this.sleepTimeLimit &&
                        (b ? this.wantsToSleep = !0 : this.sleep())
                }
            };
            d.prototype.getVelocityFromPosition = function(a, b) {
                a = a || e.create();
                e.sub(a, this.position, this.previousPosition);
                e.scale(a, a, 1 / b);
                return a
            };
            d.prototype.getAngularVelocityFromPosition = function(a) {
                return (this.angle - this.previousAngle) / a
            };
            d.sleepyEvent = {
                type: "sleepy"
            };
            d.sleepEvent = {
                type: "sleep"
            };
            d.wakeUpEvent = {
                type: "wakeup"
            };
            d.DYNAMIC = 1;
            d.STATIC = 2;
            d.KINEMATIC = 4;
            d.AWAKE = 0;
            d.SLEEPY = 1;
            d.SLEEPING = 2
        }, {
            "../collision/AABB": 8,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 36,
            "poly-decomp": 6
        }],
        32: [function(g, a, b) {
            function d(a, b, d) {
                d = f.defaults(d, {
                    restLength: 1,
                    stiffness: 100,
                    damping: 1,
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                });
                this.restLength = d.restLength;
                this.stiffness = d.stiffness;
                this.damping = d.damping;
                this.bodyA = a;
                this.bodyB = b;
                this.localAnchorA = e.create();
                e.copy(this.localAnchorA, d.localAnchorA);
                this.localAnchorB = e.create();
                e.copy(this.localAnchorB, d.localAnchorB);
                d.worldAnchorA && this.setWorldAnchorA(d.worldAnchorA);
                d.worldAnchorB && this.setWorldAnchorB(d.worldAnchorB)
            }
            var e = g("../math/vec2"),
                f = g("../utils/Utils");
            a.exports = d;
            d.prototype.setWorldAnchorA = function(a) {
                this.bodyA.toLocalFrame(this.localAnchorA, a)
            };
            d.prototype.setWorldAnchorB = function(a) {
                this.bodyB.toLocalFrame(this.localAnchorB, a)
            };
            d.prototype.getWorldAnchorA = function(a) {
                this.bodyA.toWorldFrame(a, this.localAnchorA)
            };
            d.prototype.getWorldAnchorB = function(a) {
                this.bodyB.toWorldFrame(a, this.localAnchorB)
            };
            var h = e.create(),
                k = e.create(),
                p = e.create(),
                l = e.create(),
                m = e.create(),
                n = e.create(),
                q = e.create(),
                s = e.create(),
                v = e.create();
            d.prototype.applyForce = function() {
                var a = this.stiffness,
                    b = this.damping,
                    d = this.restLength,
                    f = this.bodyA,
                    g = this.bodyB;
                this.getWorldAnchorA(m);
                this.getWorldAnchorB(n);
                e.sub(q, m, f.position);
                e.sub(s, n, g.position);
                e.sub(h, n, m);
                var z = e.len(h);
                e.normalize(k, h);
                e.sub(p, g.velocity, f.velocity);
                e.crossZV(v, g.angularVelocity, s);
                e.add(p, p, v);
                e.crossZV(v, f.angularVelocity, q);
                e.sub(p, p, v);
                e.scale(l, k, -a * (z - d) - b * e.dot(p, k));
                e.sub(f.force, f.force, l);
                e.add(g.force, g.force, l);
                a = e.crossLength(q, l);
                b = e.crossLength(s,
                    l);
                f.angularForce -= a;
                g.angularForce += b
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 47
        }],
        33: [function(g, a, b) {
            a.exports = {
                AABB: g("./collision/AABB"),
                AngleLockEquation: g("./equations/AngleLockEquation"),
                Body: g("./objects/Body"),
                Broadphase: g("./collision/Broadphase"),
                Capsule: g("./shapes/Capsule"),
                Circle: g("./shapes/Circle"),
                Constraint: g("./constraints/Constraint"),
                ContactEquation: g("./equations/ContactEquation"),
                ContactMaterial: g("./material/ContactMaterial"),
                Convex: g("./shapes/Convex"),
                DistanceConstraint: g("./constraints/DistanceConstraint"),
                Equation: g("./equations/Equation"),
                EventEmitter: g("./events/EventEmitter"),
                FrictionEquation: g("./equations/FrictionEquation"),
                GearConstraint: g("./constraints/GearConstraint"),
                GridBroadphase: g("./collision/GridBroadphase"),
                GSSolver: g("./solver/GSSolver"),
                Heightfield: g("./shapes/Heightfield"),
                Line: g("./shapes/Line"),
                LockConstraint: g("./constraints/LockConstraint"),
                Material: g("./material/Material"),
                Narrowphase: g("./collision/Narrowphase"),
                NaiveBroadphase: g("./collision/NaiveBroadphase"),
                Particle: g("./shapes/Particle"),
                Plane: g("./shapes/Plane"),
                RevoluteConstraint: g("./constraints/RevoluteConstraint"),
                PrismaticConstraint: g("./constraints/PrismaticConstraint"),
                Rectangle: g("./shapes/Rectangle"),
                RotationalVelocityEquation: g("./equations/RotationalVelocityEquation"),
                SAPBroadphase: g("./collision/SAPBroadphase"),
                Shape: g("./shapes/Shape"),
                Solver: g("./solver/Solver"),
                Spring: g("./objects/Spring"),
                Utils: g("./utils/Utils"),
                World: g("./world/World"),
                vec2: g("./math/vec2"),
                version: g("../package.json").version
            }
        }, {
            "../package.json": 7,
            "./collision/AABB": 8,
            "./collision/Broadphase": 9,
            "./collision/GridBroadphase": 10,
            "./collision/NaiveBroadphase": 11,
            "./collision/Narrowphase": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/Spring": 32,
            "./shapes/Capsule": 34,
            "./shapes/Circle": 35,
            "./shapes/Convex": 36,
            "./shapes/Heightfield": 37,
            "./shapes/Line": 38,
            "./shapes/Particle": 39,
            "./shapes/Plane": 40,
            "./shapes/Rectangle": 41,
            "./shapes/Shape": 42,
            "./solver/GSSolver": 43,
            "./solver/Solver": 44,
            "./utils/Utils": 47,
            "./world/World": 51
        }],
        34: [function(g, a, b) {
            function d(a, b) {
                this.length =
                    a || 1;
                this.radius = b || 1;
                e.call(this, e.CAPSULE)
            }
            var e = g("./Shape"),
                f = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius,
                    e = this.length + b,
                    b = 2 * b;
                return a * (b * b + e * e) / 12
            };
            d.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            };
            d.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var h = f.create();
            d.prototype.computeAABB = function(a, b, e) {
                var d = this.radius;
                f.set(h,
                    this.length, 0);
                f.rotate(h, h, e);
                f.set(a.upperBound, Math.max(h[0] + d, -h[0] + d), Math.max(h[1] + d, -h[1] + d));
                f.set(a.lowerBound, Math.min(h[0] - d, -h[0] - d), Math.min(h[1] - d, -h[1] - d));
                f.add(a.lowerBound, a.lowerBound, b);
                f.add(a.upperBound, a.upperBound, b)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 42
        }],
        35: [function(g, a, b) {
            function d(a) {
                this.radius = a || 1;
                e.call(this, e.CIRCLE)
            }
            var e = g("./Shape"),
                f = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius;
                return a * b * b / 2
            };
            d.prototype.updateBoundingRadius =
                function() {
                    this.boundingRadius = this.radius
                };
            d.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            };
            d.prototype.computeAABB = function(a, b, e) {
                e = this.radius;
                f.set(a.upperBound, e, e);
                f.set(a.lowerBound, -e, -e);
                b && (f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b))
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 42
        }],
        36: [function(g, a, b) {
            function d(a) {
                this.vertices = [];
                for (var b = 0; b < a.length; b++) {
                    var d = f.create();
                    f.copy(d, a[b]);
                    this.vertices.push(d)
                }
                this.centerOfMass = f.fromValues(0,
                    0);
                this.triangles = [];
                this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass());
                this.boundingRadius = 0;
                e.call(this, e.CONVEX);
                this.updateBoundingRadius();
                this.updateArea();
                if (0 > this.area) throw Error("Convex vertices must be given in conter-clockwise winding.");
            }
            var e = g("./Shape"),
                f = g("../math/vec2"),
                h = g("../math/polyk");
            g("poly-decomp");
            a.exports = d;
            d.prototype = new e;
            d.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var a = [], b = 0; b < this.vertices.length; b++) {
                    var e = this.vertices[b];
                    a.push(e[0], e[1])
                }
                a = h.Triangulate(a);
                for (b = 0; b < a.length; b += 3) this.triangles.push([a[b], a[b + 1], a[b + 2]])
            };
            var k = f.create(),
                p = f.create(),
                l = f.create(),
                m = f.create(),
                n = f.create();
            f.create();
            f.create();
            f.create();
            f.create();
            d.prototype.updateCenterOfMass = function() {
                var a = this.triangles,
                    b = this.vertices,
                    e = this.centerOfMass,
                    g = l,
                    h = m,
                    A = n;
                f.set(e, 0, 0);
                for (var r = 0, x = 0; x !== a.length; x++) A = a[x], g = b[A[0]], h = b[A[1]], A = b[A[2]], f.centroid(k, g, h, A), g = d.triangleArea(g, h, A), r += g, f.scale(p, k, g), f.add(e, e, p);
                f.scale(e, e, 1 /
                    r)
            };
            d.prototype.computeMomentOfInertia = function(a) {
                for (var b = 0, e = 0, d = this.vertices.length, g = d - 1, h = 0; h < d; g = h, h++) var k = this.vertices[g],
                    l = this.vertices[h],
                    g = Math.abs(f.crossLength(k, l)),
                    k = f.dot(l, l) + f.dot(l, k) + f.dot(k, k),
                    b = b + g * k,
                    e = e + g;
                return a / 6 * (b / e)
            };
            d.prototype.updateBoundingRadius = function() {
                for (var a = this.vertices, b = 0, e = 0; e !== a.length; e++) {
                    var d = f.squaredLength(a[e]);
                    d > b && (b = d)
                }
                this.boundingRadius = Math.sqrt(b)
            };
            d.triangleArea = function(a, b, e) {
                return 0.5 * ((b[0] - a[0]) * (e[1] - a[1]) - (e[0] - a[0]) * (b[1] -
                    a[1]))
            };
            d.prototype.updateArea = function() {
                this.updateTriangles();
                this.area = 0;
                for (var a = this.triangles, b = this.vertices, e = 0; e !== a.length; e++) {
                    var f = a[e],
                        f = d.triangleArea(b[f[0]], b[f[1]], b[f[2]]);
                    this.area += f
                }
            };
            d.prototype.computeAABB = function(a, b, e) {
                a.setFromPoints(this.vertices, b, e)
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 42,
            "poly-decomp": 6
        }],
        37: [function(g, a, b) {
            function d(a, b) {
                b = f.defaults(b, {
                    maxValue: null,
                    minValue: null,
                    elementWidth: 0.1
                });
                if (null === b.minValue || null === b.maxValue) {
                    b.maxValue =
                        a[0];
                    b.minValue = a[0];
                    for (var d = 0; d !== a.length; d++) {
                        var g = a[d];
                        g > b.maxValue && (b.maxValue = g);
                        g < b.minValue && (b.minValue = g)
                    }
                }
                this.data = a;
                this.maxValue = b.maxValue;
                this.minValue = b.minValue;
                this.elementWidth = b.elementWidth;
                e.call(this, e.HEIGHTFIELD)
            }
            var e = g("./Shape");
            g("../math/vec2");
            var f = g("../utils/Utils");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia = function(a) {
                return Number.MAX_VALUE
            };
            d.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            };
            d.prototype.updateArea =
                function() {
                    for (var a = this.data, b = 0, e = 0; e < a.length - 1; e++) b += (a[e] + a[e + 1]) / 2 * this.elementWidth;
                    this.area = b
                };
            d.prototype.computeAABB = function(a, b, e) {
                a.upperBound[0] = this.elementWidth * this.data.length + b[0];
                a.upperBound[1] = this.maxValue + b[1];
                a.lowerBound[0] = b[0];
                a.lowerBound[1] = -Number.MAX_VALUE
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 47,
            "./Shape": 42
        }],
        38: [function(g, a, b) {
            function d(a) {
                this.length = a || 1;
                e.call(this, e.LINE)
            }
            var e = g("./Shape"),
                f = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia =
                function(a) {
                    return a * Math.pow(this.length, 2) / 12
                };
            d.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var h = [f.create(), f.create()];
            d.prototype.computeAABB = function(a, b, e) {
                var d = this.length;
                f.set(h[0], -d / 2, 0);
                f.set(h[1], d / 2, 0);
                a.setFromPoints(h, b, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 42
        }],
        39: [function(g, a, b) {
            function d() {
                e.call(this, e.PARTICLE)
            }
            var e = g("./Shape"),
                f = g("../math/vec2");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia = function(a) {
                return 0
            };
            d.prototype.updateBoundingRadius =
                function() {
                    this.boundingRadius = 0
                };
            d.prototype.computeAABB = function(a, b, e) {
                f.copy(a.lowerBound, b);
                f.copy(a.upperBound, b)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 42
        }],
        40: [function(g, a, b) {
            function d() {
                e.call(this, e.PLANE)
            }
            var e = g("./Shape"),
                f = g("../math/vec2");
            g("../utils/Utils");
            a.exports = d;
            d.prototype = new e;
            d.prototype.computeMomentOfInertia = function(a) {
                return 0
            };
            d.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            };
            d.prototype.computeAABB = function(a, b, e) {
                var d = 0,
                    g = f.set;
                "number" ==
                typeof e && (d = e % (2 * Math.PI));
                0 == d ? (g(a.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), g(a.upperBound, Number.MAX_VALUE, 0)) : d == Math.PI / 2 ? (g(a.lowerBound, 0, -Number.MAX_VALUE), g(a.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)) : d == Math.PI ? (g(a.lowerBound, -Number.MAX_VALUE, 0), g(a.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)) : d == 3 * Math.PI / 2 ? (g(a.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), g(a.upperBound, 0, Number.MAX_VALUE)) : (g(a.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), g(a.upperBound, Number.MAX_VALUE,
                    Number.MAX_VALUE));
                f.add(a.lowerBound, a.lowerBound, b);
                f.add(a.upperBound, a.upperBound, b)
            };
            d.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 47,
            "./Shape": 42
        }],
        41: [function(g, a, b) {
            function d(a, b) {
                a = a || 1;
                b = b || 1;
                var d = [e.fromValues(-a / 2, -b / 2), e.fromValues(a / 2, -b / 2), e.fromValues(a / 2, b / 2), e.fromValues(-a / 2, b / 2)];
                this.width = a;
                this.height = b;
                h.call(this, d);
                this.type = f.RECTANGLE
            }
            var e = g("../math/vec2"),
                f = g("./Shape"),
                h = g("./Convex");
            a.exports = d;
            d.prototype = new h([]);
            d.prototype.computeMomentOfInertia = function(a) {
                var b = this.width,
                    e = this.height;
                return a * (e * e + b * b) / 12
            };
            d.prototype.updateBoundingRadius = function() {
                var a = this.width,
                    b = this.height;
                this.boundingRadius = Math.sqrt(a * a + b * b) / 2
            };
            e.create();
            e.create();
            e.create();
            e.create();
            d.prototype.computeAABB = function(a, b, e) {
                a.setFromPoints(this.vertices, b, e)
            };
            d.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 36,
            "./Shape": 42
        }],
        42: [function(g, a, b) {
            function d(a) {
                this.type = a;
                this.id = d.idCounter++;
                this.boundingRadius = 0;
                this.collisionMask = this.collisionGroup = 1;
                a && this.updateBoundingRadius();
                this.material = null;
                this.area = 0;
                this.sensor = !1;
                this.updateArea()
            }
            a.exports = d;
            d.idCounter = 0;
            d.CIRCLE = 1;
            d.PARTICLE = 2;
            d.PLANE = 4;
            d.CONVEX = 8;
            d.LINE = 16;
            d.RECTANGLE = 32;
            d.CAPSULE = 64;
            d.HEIGHTFIELD = 128;
            d.prototype.computeMomentOfInertia = function(a) {
                throw Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
            };
            d.prototype.updateBoundingRadius = function() {
                throw Error("Shape.updateBoundingRadius is not implemented in this Shape...");
            };
            d.prototype.updateArea = function() {};
            d.prototype.computeAABB = function(a, b, d) {}
        }, {}],
        43: [function(g, a, b) {
            function d(a) {
                e.call(this, a, e.GS);
                a = a || {};
                this.iterations = a.iterations || 10;
                this.tolerance = a.tolerance || 1E-10;
                this.arrayStep = 30;
                this.lambda = new f.ARRAY_TYPE(this.arrayStep);
                this.Bs = new f.ARRAY_TYPE(this.arrayStep);
                this.invCs = new f.ARRAY_TYPE(this.arrayStep);
                this.useZeroRHS = !1;
                this.usedIterations = this.frictionIterations = 0
            }
            g("../math/vec2");
            var e = g("./Solver"),
                f = g("../utils/Utils"),
                h = g("../equations/FrictionEquation");
            a.exports = d;
            d.prototype = new e;
            d.prototype.solve = function(a, b) {
                this.sortEquations();
                var e = 0,
                    g = this.iterations,
                    n = this.frictionIterations,
                    q = this.equations,
                    s = q.length,
                    v = Math.pow(this.tolerance * s, 2),
                    t = b.bodies,
                    u = b.bodies.length,
                    A = this.useZeroRHS,
                    r = this.lambda;
                this.usedIterations = 0;
                r.length < s && (r = this.lambda = new f.ARRAY_TYPE(s + this.arrayStep), this.Bs = new f.ARRAY_TYPE(s + this.arrayStep), this.invCs = new f.ARRAY_TYPE(s + this.arrayStep));
                for (var x = r.length; x--;) r[x] = 0;
                for (var x = this.invCs, z = this.Bs, r = this.lambda,
                        w = 0; w !== q.length; w++) {
                    var B = q[w];
                    if (B.timeStep !== a || B.needsUpdate) B.timeStep = a, B.update();
                    z[w] = B.computeB(B.a, B.b, a);
                    x[w] = B.computeInvC(B.epsilon)
                }
                var C;
                if (0 !== s) {
                    for (w = 0; w !== u; w++) t[w].resetConstraintVelocity();
                    if (n) {
                        for (e = 0; e !== n; e++) {
                            for (w = C = 0; w !== s; w++) B = q[w], B = d.iterateEquation(w, B, B.epsilon, z, x, r, A, a, e), C += Math.abs(B);
                            this.usedIterations++;
                            if (C * C <= v) break
                        }
                        d.updateMultipliers(q, r, 1 / a);
                        for (w = 0; w !== s; w++) n = q[w], n instanceof h && (e = n.contactEquation.multiplier * n.frictionCoefficient, n.maxForce = e,
                            n.minForce = -e)
                    }
                    for (e = 0; e !== g; e++) {
                        for (w = C = 0; w !== s; w++) B = q[w], B = d.iterateEquation(w, B, B.epsilon, z, x, r, A, a, e), C += Math.abs(B);
                        this.usedIterations++;
                        if (C * C <= v) break
                    }
                    for (w = 0; w !== u; w++) t[w].addConstraintVelocity();
                    d.updateMultipliers(q, r, 1 / a)
                }
            };
            d.updateMultipliers = function(a, b, e) {
                for (var d = a.length; d--;) a[d].multiplier = b[d] * e
            };
            d.iterateEquation = function(a, b, e, d, f, g, h, v, t) {
                var u = d[a],
                    A = f[a];
                f = g[a];
                var r = b.computeGWlambda();
                d = b.maxForce;
                t = b.minForce;
                h && (u = 0);
                e = A * (u - r - e * f);
                h = f + e;
                h < t * v ? e = t * v - f : h > d * v && (e = d *
                    v - f);
                g[a] += e;
                b.addToWlambda(e);
                return e
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 47,
            "./Solver": 44
        }],
        44: [function(g, a, b) {
            function d(a, b) {
                a = a || {};
                e.call(this);
                this.type = b;
                this.equations = [];
                this.equationSortFunction = a.equationSortFunction || !1
            }
            g("../utils/Utils");
            var e = g("../events/EventEmitter");
            a.exports = d;
            d.prototype = new e;
            d.prototype.solve = function(a, b) {
                throw Error("Solver.solve should be implemented by subclasses!");
            };
            var f = {
                bodies: []
            };
            d.prototype.solveIsland = function(a,
                b) {
                this.removeAllEquations();
                b.equations.length && (this.addEquations(b.equations), f.bodies.length = 0, b.getBodies(f.bodies), f.bodies.length && this.solve(a, f))
            };
            d.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            };
            d.prototype.addEquation = function(a) {
                a.enabled && this.equations.push(a)
            };
            d.prototype.addEquations = function(a) {
                for (var b = 0, e = a.length; b !== e; b++) {
                    var d = a[b];
                    d.enabled && this.equations.push(d)
                }
            };
            d.prototype.removeEquation = function(a) {
                a = this.equations.indexOf(a); -
                1 !== a && this.equations.splice(a, 1)
            };
            d.prototype.removeAllEquations = function() {
                this.equations.length = 0
            };
            d.GS = 1;
            d.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 47
        }],
        45: [function(g, a, b) {
            function d() {
                this.overlappingLastState = new f;
                this.overlappingCurrentState = new f;
                this.recordPool = [];
                this.tmpDict = new f;
                this.tmpArray1 = []
            }

            function e(a, b, e, d) {
                this.shapeA = b;
                this.shapeB = d;
                this.bodyA = a;
                this.bodyB = e
            }
            var f = g("./TupleDictionary");
            g("./Utils");
            a.exports = d;
            d.prototype.tick = function() {
                for (var a = this.overlappingLastState,
                        b = this.overlappingCurrentState, e = b.keys.length; e--;) this.recordPool.push(b.getByKey(b.keys[e]));
                a.reset();
                a.copy(b);
                b.reset()
            };
            d.prototype.setOverlapping = function(a, b, d, f) {
                var g = this.overlappingCurrentState;
                g.get(b.id, f.id) || (a = this.recordPool.length ? this.recordPool.pop() : new e(a, b, d, f), g.set(b.id, f.id, a))
            };
            d.prototype.getNewOverlaps = function(a) {
                return this.getDiff(this.overlappingLastState, this.overlappingCurrentState, a)
            };
            d.prototype.getEndOverlaps = function(a) {
                return this.getDiff(this.overlappingCurrentState,
                    this.overlappingLastState, a)
            };
            d.prototype.getDiff = function(a, b, e) {
                e = e || [];
                e.length = 0;
                for (var d = b.keys.length; d--;) {
                    var f = b.keys[d],
                        g = b.data[f];
                    if (!g) throw Error("Key " + f + " had no data!");
                    a.data[f] || e.push(g)
                }
                return e
            };
            d.prototype.isNewOverlap = function(a, b) {
                var e = a.id | 0,
                    d = b.id | 0;
                return !this.overlappingLastState.get(e, d) && !!this.overlappingCurrentState.get(e, d)
            };
            d.prototype.getNewBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a)
            };
            d.prototype.getEndBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a)
            };
            d.prototype.getBodyDiff = function(a, b) {
                b = b || [];
                for (var e = this.tmpDict, d = a.length; d--;) {
                    var f = a[d];
                    e.set(f.bodyA.id | 0, f.bodyB.id | 0, f)
                }
                for (d = e.keys.length; d--;) f = e.keys[d], b.push(f.bodyA, f.bodyB);
                e.reset();
                return b
            };
            e.prototype.set = function(a, b, d, f) {
                e.call(this, a, b, d, f)
            }
        }, {
            "./TupleDictionary": 46,
            "./Utils": 47
        }],
        46: [function(g, a, b) {
            function d() {
                this.data = [];
                this.keys = []
            }
            var e = g("./Utils");
            a.exports = d;
            d.prototype.getKey = function(a, b) {
                a |= 0;
                b |= 0;
                return (a | 0) === (b | 0) ? -1 : ((a | 0) > (b | 0) ? a << 16 | b & 65535 : b << 16 | a & 65535) | 0
            };
            d.prototype.getByKey = function(a) {
                return this.data[a | 0]
            };
            d.prototype.get = function(a, b) {
                var e = this.getKey(a | 0, b | 0) | 0;
                return this.data[e]
            };
            d.prototype.set = function(a, b, e) {
                if (!e) throw Error("No data!");
                a |= 0;
                b |= 0;
                var d = this.getKey(a, b) | 0;
                this.get(a, b) || this.keys.push(d);
                this.data[d] = e;
                return d
            };
            d.prototype.reset = function() {
                for (var a = this.data, b = this.keys, e = b.length |
                        0; e--;) a[b[e] | 0] = void 0;
                b.length = 0
            };
            d.prototype.copy = function(a) {
                this.reset();
                e.appendArray(this.keys, a.keys);
                for (var b = a.keys.length | 0; b--;) {
                    var d = a.keys[b] | 0;
                    this.data[d] = a.data[d]
                }
            }
        }, {
            "./Utils": 47
        }],
        47: [function(g, a, b) {
            function d() {}
            a.exports = d;
            d.appendArray = function(a, b) {
                if (15E4 > b.length) a.push.apply(a, b);
                else
                    for (var d = 0, g = b.length; d !== g; ++d) a.push(b[d])
            };
            d.splice = function(a, b, d) {
                d = d || 1;
                for (var g = a.length - d; b < g; b++) a[b] = a[b + d];
                a.length = g
            };
            d.ARRAY_TYPE = window.Float32Array || Array;
            d.extend = function(a,
                b) {
                for (var d in b) a[d] = b[d]
            };
            d.defaults = function(a, b) {
                a = a || {};
                for (var d in b) d in a || (a[d] = b[d]);
                return a
            }
        }, {}],
        48: [function(g, a, b) {
            function d() {
                this.equations = [];
                this.bodies = []
            }
            var e = g("../objects/Body");
            a.exports = d;
            d.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var f = [];
            d.prototype.getBodies = function(a) {
                a = a || [];
                for (var b = this.equations, e = f.length = 0; e !== b.length; e++) {
                    var d = b[e]; - 1 === f.indexOf(d.bodyA.id) && (a.push(d.bodyA), f.push(d.bodyA.id)); - 1 === f.indexOf(d.bodyB.id) &&
                        (a.push(d.bodyB), f.push(d.bodyB.id))
                }
                return a
            };
            d.prototype.wantsToSleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    var b = this.bodies[a];
                    if (b.motionState === e.DYNAMIC && !b.wantsToSleep) return !1
                }
                return !0
            };
            d.prototype.sleep = function() {
                for (var a = 0; a < this.bodies.length; a++) this.bodies[a].sleep();
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        49: [function(g, a, b) {
            function d(a) {
                this._nodePool = [];
                this._islandPool = [];
                this.equations = [];
                this.islands = [];
                this.nodes = [];
                this.queue = []
            }
            g("../math/vec2");
            var e = g("./Island"),
                f = g("./IslandNode"),
                h = g("../objects/Body");
            a.exports = d;
            d.getUnvisitedNode = function(a) {
                for (var b = a.length, e = 0; e !== b; e++) {
                    var d = a[e];
                    if (!d.visited && d.body.motionState === h.DYNAMIC) return d
                }
                return !1
            };
            d.prototype.visit = function(a, b, e) {
                b.push(a.body);
                b = a.equations.length;
                for (var d = 0; d !== b; d++) {
                    var f = a.equations[d]; - 1 === e.indexOf(f) && e.push(f)
                }
            };
            d.prototype.bfs = function(a, b, e) {
                var f = this.queue;
                f.length = 0;
                f.push(a);
                a.visited = !0;
                for (this.visit(a, b, e); f.length;) {
                    a = f.pop();
                    for (var g; g = d.getUnvisitedNode(a.neighbors);) g.visited = !0, this.visit(g, b, e), g.body.motionState === h.DYNAMIC && f.push(g)
                }
            };
            d.prototype.split = function(a) {
                var b = a.bodies;
                a = this.nodes;
                for (var g = this.equations; a.length;) this._nodePool.push(a.pop());
                for (var h = 0; h !== b.length; h++)
                    if (this._nodePool.length) {
                        var n = this._nodePool.pop();
                        n.reset();
                        n.body = b[h];
                        a.push(n)
                    } else a.push(new f(b[h]));
                for (n = 0; n !== g.length; n++) {
                    var q = g[n],
                        h = b.indexOf(q.bodyA),
                        s = b.indexOf(q.bodyB),
                        h = a[h],
                        s = a[s];
                    h.neighbors.push(s);
                    s.neighbors.push(h);
                    h.equations.push(q);
                    s.equations.push(q)
                }
                for (b =
                    this.islands; b.length;) g = b.pop(), g.reset(), this._islandPool.push(g);
                for (; n = d.getUnvisitedNode(a);) g = this._islandPool.length ? this._islandPool.pop() : new e, this.bfs(n, g.bodies, g.equations), b.push(g);
                return b
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./Island": 48,
            "./IslandNode": 50
        }],
        50: [function(g, a, b) {
                function d(a) {
                    this.body = a;
                    this.neighbors = [];
                    this.equations = [];
                    this.visited = !1
                }
                a.exports = d;
                d.prototype.reset = function() {
                    this.equations.length = 0;
                    this.neighbors.length = 0;
                    this.visited = !1;
                    this.body = null
                }
            },
            {}
        ],
        51: [function(g, a, b) {
            function d(a) {
                r.apply(this);
                a = a || {};
                this.springs = [];
                this.bodies = [];
                this.disabledBodyCollisionPairs = [];
                this.solver = a.solver || new k;
                this.narrowphase = new qa(this);
                this.islandManager = new Y;
                this.gravity = m.fromValues(0, -9.78);
                a.gravity && m.copy(this.gravity, a.gravity);
                this.frictionGravity = m.length(this.gravity) || 10;
                this.useFrictionGravityOnZeroGravity = this.useWorldGravityAsFrictionGravity = !0;
                this.doProfiling = a.doProfiling || !1;
                this.lastStepTime = 0;
                this.broadphase = a.broadphase || new l;
                this.broadphase.setWorld(this);
                this.constraints = [];
                this.defaultMaterial = new B;
                this.defaultContactMaterial = new C(this.defaultMaterial, this.defaultMaterial);
                this.lastTimeStep = 1 / 60;
                this.solveConstraints = this.applyGravity = this.applyDamping = this.applySpringForces = !0;
                this.contactMaterials = [];
                this.time = 0;
                this.stepping = !1;
                this.bodiesToBeRemoved = [];
                this.fixedStepTime = 0;
                this.islandSplit = "undefined" !== typeof a.islandSplit ? !!a.islandSplit : !1;
                this.emitImpactEvent = !0;
                this._bodyIdCounter = this._constraintIdCounter =
                    0;
                this.postStepEvent = {
                    type: "postStep"
                };
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                };
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                };
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                };
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                };
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                };
                this.enableIslandSleeping = this.enableBodySleeping = !1;
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                };
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                };
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                };
                this.overlappingShapesLastState = {
                    keys: []
                };
                this.overlappingShapesCurrentState = {
                    keys: []
                };
                this.overlapKeeper = new ra
            }

            function e(a) {
                return !a ? a : [a[0], a[1]]
            }

            function f(a, b) {
                for (var e in b) a[e] = b[e]
            }

            function h(a) {
                return {
                    id: a.id,
                    materialA: a.materialA.id,
                    materialB: a.materialB.id,
                    friction: a.friction,
                    restitution: a.restitution,
                    stiffness: a.stiffness,
                    relaxation: a.relaxation,
                    frictionStiffness: a.frictionStiffness,
                    frictionRelaxation: a.frictionRelaxation
                }
            }
            var k = g("../solver/GSSolver"),
                p = g("../solver/Solver"),
                l = g("../collision/NaiveBroadphase"),
                m = g("../math/vec2"),
                n = g("../shapes/Circle"),
                q = g("../shapes/Rectangle"),
                s = g("../shapes/Convex"),
                v = g("../shapes/Line"),
                t = g("../shapes/Plane"),
                u = g("../shapes/Capsule"),
                A = g("../shapes/Particle"),
                r = g("../events/EventEmitter"),
                x = g("../objects/Body"),
                z = g("../shapes/Shape"),
                w = g("../objects/Spring"),
                B = g("../material/Material"),
                C = g("../material/ContactMaterial"),
                F = g("../constraints/DistanceConstraint"),
                y = g("../constraints/Constraint"),
                D = g("../constraints/LockConstraint"),
                I = g("../constraints/RevoluteConstraint"),
                E = g("../constraints/PrismaticConstraint"),
                H = g("../constraints/GearConstraint"),
                P = g("../../package.json"),
                Q = g("../collision/Broadphase"),
                pa = g("../collision/SAPBroadphase"),
                qa = g("../collision/Narrowphase"),
                X = g("../utils/Utils"),
                ra = g("../utils/OverlapKeeper"),
                Y = g("./IslandManager");
            a.exports = d;
            "undefined" === typeof performance &&
                (performance = {});
            if (!performance.now) {
                var ka = Date.now();
                performance.timing && performance.timing.navigationStart && (ka = performance.timing.navigationStart);
                performance.now = function() {
                    return Date.now() - ka
                }
            }
            d.prototype = Object(r.prototype);
            d.prototype.addConstraint = function(a) {
                this.constraints.push(a)
            };
            d.prototype.addContactMaterial = function(a) {
                this.contactMaterials.push(a)
            };
            d.prototype.removeContactMaterial = function(a) {
                a = this.contactMaterials.indexOf(a); - 1 !== a && X.splice(this.contactMaterials, a, 1)
            };
            d.prototype.getContactMaterial =
                function(a, b) {
                    for (var e = this.contactMaterials, d = 0, f = e.length; d !== f; d++) {
                        var g = e[d];
                        if (g.materialA === a && g.materialB === b || g.materialA === b && g.materialB === a) return g
                    }
                    return !1
                };
            d.prototype.removeConstraint = function(a) {
                a = this.constraints.indexOf(a); - 1 !== a && X.splice(this.constraints, a, 1)
            };
            m.create();
            m.create();
            m.create();
            m.create();
            m.create();
            m.create();
            var M = m.create(),
                R = m.fromValues(0, 0),
                S = m.fromValues(0, 0);
            m.fromValues(0, 0);
            var Z = m.fromValues(0, 0);
            d.prototype.step = function(a, b, e) {
                e = e || 10;
                b = b || 0;
                if (0 ===
                    b) this.internalStep(a), this.time += a;
                else {
                    var d = Math.floor((this.time + b) / a) - Math.floor(this.time / a),
                        d = Math.min(d, e);
                    for (e = 0; e !== d; e++) this.internalStep(a);
                    this.time += b;
                    a = this.time % a / a;
                    for (b = 0; b !== this.bodies.length; b++) d = this.bodies[b], d.motionState !== x.STATIC && d.sleepState !== x.SLEEPING ? (m.sub(Z, d.position, d.previousPosition), m.scale(Z, Z, a), m.add(d.interpolatedPosition, d.position, Z), d.interpolatedAngle = d.angle + (d.angle - d.previousAngle) * a) : (m.copy(d.interpolatedPosition, d.position), d.interpolatedAngle =
                        d.angle)
                }
            };
            var ja = [];
            d.prototype.internalStep = function(a) {
                this.stepping = !0;
                var b = this.doProfiling,
                    e = this.springs.length,
                    f = this.springs,
                    g = this.bodies,
                    h = this.gravity,
                    k = this.solver,
                    l = this.bodies.length,
                    n = this.broadphase,
                    p = this.narrowphase,
                    q = this.constraints,
                    s, t = m.add,
                    u = this.islandManager;
                this.lastTimeStep = a;
                b && (s = performance.now());
                if (this.useWorldGravityAsFrictionGravity) {
                    var r = m.length(this.gravity);
                    0 === r && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = r)
                }
                if (this.applyGravity)
                    for (r = 0; r !==
                        l; r++) {
                        var v = g[r],
                            w = v.force;
                        v.motionState !== x.DYNAMIC || v.sleepState === x.SLEEPING || (m.scale(M, h, v.mass * v.gravityScale), t(w, w, M))
                    }
                if (this.applySpringForces)
                    for (r = 0; r !== e; r++) f[r].applyForce();
                if (this.applyDamping)
                    for (r = 0; r !== l; r++) v = g[r], v.motionState === x.DYNAMIC && v.applyDamping(a);
                e = n.getCollisionPairs(this);
                h = this.disabledBodyCollisionPairs;
                for (r = h.length - 2; 0 <= r; r -= 2)
                    for (f = e.length - 2; 0 <= f; f -= 2)(h[r] === e[f] && h[r + 1] === e[f + 1] || h[r + 1] === e[f] && h[r] === e[f + 1]) && e.splice(f, 2);
                h = q.length;
                for (r = 0; r !== h; r++)
                    if (n =
                        q[r], !n.collideConnected)
                        for (f = e.length - 2; 0 <= f; f -= 2)(n.bodyA === e[f] && n.bodyB === e[f + 1] || n.bodyB === e[f] && n.bodyA === e[f + 1]) && e.splice(f, 2);
                this.postBroadphaseEvent.pairs = e;
                this.emit(this.postBroadphaseEvent);
                p.reset(this);
                r = 0;
                for (h = e.length; r !== h; r += 2) {
                    n = e[r];
                    t = e[r + 1];
                    v = 0;
                    for (w = n.shapes.length; v !== w; v++)
                        for (var y = n.shapes[v], z = n.shapeOffsets[v], A = n.shapeAngles[v], f = 0, B = t.shapes.length; f !== B; f++) {
                            var C = t.shapes[f],
                                D = t.shapeOffsets[f],
                                E = t.shapeAngles[f],
                                F = this.defaultContactMaterial;
                            if (y.material && C.material) {
                                var H =
                                    this.getContactMaterial(y.material, C.material);
                                H && (F = H)
                            }
                            this.runNarrowphase(p, n, y, z, A, t, C, D, E, F, this.frictionGravity)
                        }
                }
                for (r = 0; r !== l; r++) e = g[r], e._wakeUpAfterNarrowphase && (e.wakeUp(), e._wakeUpAfterNarrowphase = !1);
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(ja);
                    r = this.endContactEvent;
                    for (f = ja.length; f--;) e = ja[f], r.shapeA = e.shapeA, r.shapeB = e.shapeB, r.bodyA = e.bodyA, r.bodyB = e.bodyA, this.emit(r)
                }
                this.overlapKeeper.tick();
                r = this.preSolveEvent;
                r.contactEquations = p.contactEquations;
                r.frictionEquations =
                    p.frictionEquations;
                this.emit(r);
                h = q.length;
                for (r = 0; r !== h; r++) q[r].update();
                if (p.contactEquations.length || p.frictionEquations.length || q.length)
                    if (this.islandSplit) {
                        u.equations.length = 0;
                        X.appendArray(u.equations, p.contactEquations);
                        X.appendArray(u.equations, p.frictionEquations);
                        for (r = 0; r !== h; r++) X.appendArray(u.equations, q[r].equations);
                        u.split(this);
                        for (r = 0; r !== u.islands.length; r++) q = u.islands[r], q.equations.length && k.solveIsland(a, q)
                    } else {
                        k.addEquations(p.contactEquations);
                        k.addEquations(p.frictionEquations);
                        for (r = 0; r !== h; r++) k.addEquations(q[r].equations);
                        this.solveConstraints && k.solve(a, this);
                        k.removeAllEquations()
                    }
                for (r = 0; r !== l; r++) e = g[r], e.sleepState !== x.SLEEPING && e.motionState !== x.STATIC && d.integrateBody(e, a);
                for (r = 0; r !== l; r++) g[r].setZeroForce();
                b && (b = performance.now(), this.lastStepTime = b - s);
                if (this.emitImpactEvent && this.has("impact")) {
                    s = this.impactEvent;
                    for (r = 0; r !== p.contactEquations.length; r++) b = p.contactEquations[r], b.firstImpact && (s.bodyA = b.bodyA, s.bodyB = b.bodyB, s.shapeA = b.shapeA, s.shapeB = b.shapeB,
                        s.contactEquation = b, this.emit(s))
                }
                if (this.enableBodySleeping)
                    for (r = 0; r !== l; r++) g[r].sleepTick(this.time, !1, a);
                else if (this.enableIslandSleeping && this.islandSplit) {
                    for (r = 0; r !== l; r++) g[r].sleepTick(this.time, !0, a);
                    for (r = 0; r < this.islandManager.islands.length; r++) q = this.islandManager.islands[r], q.wantsToSleep() && q.sleep()
                }
                this.stepping = !1;
                if (this.bodiesToBeRemoved.length) {
                    for (r = 0; r !== this.bodiesToBeRemoved.length; r++) this.removeBody(this.bodiesToBeRemoved[r]);
                    this.bodiesToBeRemoved.length = 0
                }
                this.emit(this.postStepEvent)
            };
            var na = m.create(),
                oa = m.create();
            d.integrateBody = function(a, b) {
                var e = a.invMass,
                    d = a.force,
                    f = a.position,
                    g = a.velocity;
                m.copy(a.previousPosition, a.position);
                a.previousAngle = a.angle;
                a.fixedRotation || (a.angularVelocity += a.angularForce * a.invInertia * b, a.angle += a.angularVelocity * b);
                m.scale(na, d, b * e);
                m.add(g, na, g);
                m.scale(oa, g, b);
                m.add(f, f, oa);
                a.aabbNeedsUpdate = !0
            };
            d.prototype.runNarrowphase = function(a, b, e, d, f, g, h, k, l, n, p) {
                if (0 !== (e.collisionGroup & h.collisionMask) && 0 !== (h.collisionGroup & e.collisionMask) && (m.rotate(R,
                            d, b.angle), m.rotate(S, k, g.angle), m.add(R, R, b.position), m.add(S, S, g.position), d = f + b.angle, l += g.angle, a.enableFriction = 0 < n.friction, a.frictionCoefficient = n.friction, a.slipForce = n.friction * p * (b.motionState === x.STATIC || b.motionState === x.KINEMATIC ? g.mass : g.motionState === x.STATIC || g.motionState === x.KINEMATIC ? b.mass : b.mass * g.mass / (b.mass + g.mass)), a.restitution = n.restitution, a.surfaceVelocity = n.surfaceVelocity, a.frictionStiffness = n.frictionStiffness, a.frictionRelaxation = n.frictionRelaxation, a.stiffness = n.stiffness,
                        a.relaxation = n.relaxation, p = a[e.type | h.type], n = 0, p && (n = e.sensor || h.sensor, f = a.frictionEquations.length, n = e.type < h.type ? p.call(a, b, e, R, d, g, h, S, l, n) : p.call(a, g, h, S, l, b, e, R, d, n), d = a.frictionEquations.length - f, n))) {
                    b.allowSleep && (b.motionState === x.DYNAMIC && b.sleepState === x.SLEEPING && g.sleepState === x.AWAKE && g.motionState !== x.STATIC) && (p = m.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2), l = Math.pow(g.sleepSpeedLimit, 2), p >= 2 * l && (b._wakeUpAfterNarrowphase = !0));
                    g.allowSleep && (g.motionState === x.DYNAMIC &&
                        g.sleepState === x.SLEEPING && b.sleepState === x.AWAKE && b.motionState !== x.STATIC) && (p = m.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2), l = Math.pow(b.sleepSpeedLimit, 2), p >= 2 * l && (g._wakeUpAfterNarrowphase = !0));
                    this.overlapKeeper.setOverlapping(b, e, g, h);
                    if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(e, h)) {
                        p = this.beginContactEvent;
                        p.shapeA = e;
                        p.shapeB = h;
                        p.bodyA = b;
                        p.bodyB = g;
                        p.contactEquations.length = 0;
                        if ("number" === typeof n)
                            for (b = a.contactEquations.length - n; b < a.contactEquations.length; b++) p.contactEquations.push(a.contactEquations[b]);
                        this.emit(p)
                    }
                    if ("number" === typeof n && 1 < d)
                        for (b = a.frictionEquations.length - d; b < a.frictionEquations.length; b++) e = a.frictionEquations[b], e.setSlipForce(e.getSlipForce() / d)
                }
            };
            d.prototype.addSpring = function(a) {
                this.springs.push(a);
                this.addSpringEvent.spring = a;
                this.emit(this.addSpringEvent)
            };
            d.prototype.removeSpring = function(a) {
                a = this.springs.indexOf(a); - 1 === a && X.splice(this.springs, a, 1)
            };
            d.prototype.addBody = function(a) {
                -1 === this.bodies.indexOf(a) && (this.bodies.push(a), a.world = this, this.addBodyEvent.body =
                    a, this.emit(this.addBodyEvent))
            };
            d.prototype.removeBody = function(a) {
                if (this.stepping) this.bodiesToBeRemoved.push(a);
                else {
                    a.world = null;
                    var b = this.bodies.indexOf(a); - 1 !== b && (X.splice(this.bodies, b, 1), this.removeBodyEvent.body = a, a.resetConstraintVelocity(), this.emit(this.removeBodyEvent))
                }
            };
            d.prototype.getBodyById = function(a) {
                for (var b = this.bodies, e = 0; e < b.length; e++) {
                    var d = b[e];
                    if (d.id === a) return d
                }
                return !1
            };
            d.prototype.disableBodyCollision = function(a, b) {
                this.disabledBodyCollisionPairs.push(a, b)
            };
            d.prototype.enableBodyCollision =
                function(a, b) {
                    for (var e = this.disabledBodyCollisionPairs, d = 0; d < e.length; d += 2)
                        if (e[d] === a && e[d + 1] === b || e[d + 1] === a && e[d] === b) {
                            e.splice(d, 2);
                            break
                        }
                };
            d.prototype.toJSON = function() {
                var a = {
                        p2: P.version,
                        bodies: [],
                        springs: [],
                        solver: {},
                        gravity: e(this.gravity),
                        broadphase: {},
                        distanceConstraints: [],
                        revoluteConstraints: [],
                        prismaticConstraints: [],
                        lockConstraints: [],
                        gearConstraints: [],
                        contactMaterials: [],
                        materials: [],
                        defaultContactMaterial: h(this.defaultContactMaterial),
                        islandSplit: this.islandSplit,
                        enableIslandSleeping: this.enableIslandSleeping,
                        enableBodySleeping: this.enableBodySleeping
                    },
                    b = a.solver,
                    d = this.solver;
                d.type === p.GS && (b.type = "GSSolver", b.iterations = d.iterations);
                b = a.broadphase;
                d = this.broadphase;
                d.type === Q.NAIVE ? b.type = "NaiveBroadphase" : d.type === Q.SAP ? b.type = "SAPBroadphase" : console.error("Broadphase not supported: " + d.type);
                for (b = 0; b !== this.springs.length; b++) d = this.springs[b], a.springs.push({
                    bodyA: this.bodies.indexOf(d.bodyA),
                    bodyB: this.bodies.indexOf(d.bodyB),
                    stiffness: d.stiffness,
                    damping: d.damping,
                    restLength: d.restLength,
                    localAnchorA: e(d.localAnchorA),
                    localAnchorB: e(d.localAnchorB)
                });
                for (b = 0; b < this.constraints.length; b++) {
                    var d = this.constraints[b],
                        g = {
                            bodyA: this.bodies.indexOf(d.bodyA),
                            bodyB: this.bodies.indexOf(d.bodyB),
                            collideConnected: d.collideConnected
                        };
                    switch (d.type) {
                        case y.DISTANCE:
                            f(g, {
                                distance: d.distance,
                                maxForce: d.getMaxForce()
                            });
                            a.distanceConstraints.push(g);
                            break;
                        case y.REVOLUTE:
                            f(g, {
                                pivotA: e(d.pivotA),
                                pivotB: e(d.pivotB),
                                maxForce: d.maxForce,
                                motorSpeed: d.getMotorSpeed() || 0,
                                motorEnabled: !!d.getMotorSpeed(),
                                lowerLimit: d.lowerLimit,
                                lowerLimitEnabled: d.lowerLimitEnabled,
                                upperLimit: d.upperLimit,
                                upperLimitEnabled: d.upperLimitEnabled
                            });
                            a.revoluteConstraints.push(g);
                            break;
                        case y.PRISMATIC:
                            f(g, {
                                localAxisA: e(d.localAxisA),
                                localAnchorA: e(d.localAnchorA),
                                localAnchorB: e(d.localAnchorB),
                                maxForce: d.maxForce,
                                upperLimitEnabled: d.upperLimitEnabled,
                                lowerLimitEnabled: d.lowerLimitEnabled,
                                upperLimit: d.upperLimit,
                                lowerLimit: d.lowerLimit,
                                motorEnabled: d.motorEnabled,
                                motorSpeed: d.motorSpeed
                            });
                            a.prismaticConstraints.push(g);
                            break;
                        case y.LOCK:
                            f(g, {
                                localOffsetB: e(d.localOffsetB),
                                localAngleB: d.localAngleB,
                                maxForce: d.getMaxForce()
                            });
                            a.lockConstraints.push(g);
                            break;
                        case y.GEAR:
                            f(g, {
                                angle: d.angle,
                                ratio: d.ratio,
                                maxForce: d.maxForce || 1E6
                            });
                            a.gearConstraints.push(g);
                            break;
                        default:
                            console.error("Constraint not supported yet: ", d.type)
                    }
                }
                for (b = 0; b !== this.bodies.length; b++) {
                    var g = this.bodies[b],
                        k = g.shapes,
                        l = {
                            id: g.id,
                            mass: g.mass,
                            angle: g.angle,
                            position: e(g.position),
                            velocity: e(g.velocity),
                            angularVelocity: g.angularVelocity,
                            force: e(g.force),
                            motionState: g.motionState,
                            fixedRotation: g.fixedRotation,
                            circleShapes: [],
                            planeShapes: [],
                            particleShapes: [],
                            lineShapes: [],
                            rectangleShapes: [],
                            convexShapes: [],
                            capsuleShapes: []
                        };
                    g.concavePath && (l.concavePath = g.concavePath);
                    for (var m = 0; m < k.length; m++) {
                        var d = k[m],
                            n = {};
                        n.offset = e(g.shapeOffsets[m]);
                        n.angle = g.shapeAngles[m];
                        n.collisionGroup = d.collisionGroup;
                        n.collisionMask = d.collisionMask;
                        n.material = d.material ? d.material.id : null;
                        switch (d.type) {
                            case z.CIRCLE:
                                f(n, {
                                    radius: d.radius
                                });
                                l.circleShapes.push(n);
                                break;
                            case z.PLANE:
                                l.planeShapes.push(n);
                                break;
                            case z.PARTICLE:
                                l.particleShapes.push(n);
                                break;
                            case z.LINE:
                                n.length = d.length;
                                l.lineShapes.push(n);
                                break;
                            case z.RECTANGLE:
                                f(n, {
                                    width: d.width,
                                    height: d.height
                                });
                                l.rectangleShapes.push(n);
                                break;
                            case z.CONVEX:
                                for (var q = [], s = 0; s < d.vertices.length; s++) q.push(e(d.vertices[s]));
                                f(n, {
                                    vertices: q
                                });
                                l.convexShapes.push(n);
                                break;
                            case z.CAPSULE:
                                f(n, {
                                    length: d.length,
                                    radius: d.radius
                                });
                                l.capsuleShapes.push(n);
                                break;
                            default:
                                console.error("Shape type not supported yet!")
                        }
                    }
                    a.bodies.push(l)
                }
                for (b = 0; b < this.contactMaterials.length; b++) g = this.contactMaterials[b],
                    a.contactMaterials.push(h(g));
                d = {};
                for (b = 0; b < this.contactMaterials.length; b++) g = this.contactMaterials[b], d[g.materialA.id + ""] = g.materialA, d[g.materialB.id + ""] = g.materialB;
                for (var r in d) b = d[parseInt(r)], a.materials.push({
                    id: b.id
                });
                return a
            };
            d.prototype.fromJSON = function(a) {
                this.clear();
                if (!a.p2) return !1;
                m.copy(this.gravity, a.gravity);
                this.islandSplit = a.islandSplit;
                this.enableIslandSleeping = a.enableIslandSleeping;
                this.enableBodySleeping = a.enableBodySleeping;
                switch (a.solver.type) {
                    case "GSSolver":
                        var b =
                            a.solver,
                            d = new k;
                        this.solver = d;
                        d.iterations = b.iterations;
                        break;
                    default:
                        throw Error("Solver type not recognized: " + a.solver.type);
                }
                switch (a.broadphase.type) {
                    case "NaiveBroadphase":
                        this.broadphase = new l;
                        break;
                    case "SAPBroadphase":
                        this.broadphase = new pa
                }
                this.broadphase.setWorld(this);
                for (var e = this.bodies, f = {}, g = 0; g !== a.materials.length; g++) d = a.materials[g], b = new B, f[d.id + ""] = b, b.id = d.id;
                this.defaultMaterial.id = a.defaultContactMaterial.materialA;
                for (g = 0; g !== a.bodies.length; g++) {
                    var b = a.bodies[g],
                        h = new x({
                            mass: b.mass,
                            position: b.position,
                            angle: b.angle,
                            velocity: b.velocity,
                            angularVelocity: b.angularVelocity,
                            force: b.force,
                            fixedRotation: b.fixedRotation
                        });
                    h.id = b.id;
                    h.motionState = b.motionState;
                    for (var p = 0; p < b.circleShapes.length; p++) d = b.circleShapes[p], r(h, new n(d.radius), d);
                    for (p = 0; p < b.planeShapes.length; p++) d = b.planeShapes[p], r(h, new t, d);
                    for (p = 0; p < b.particleShapes.length; p++) d = b.particleShapes[p], r(h, new A, d);
                    for (p = 0; p < b.lineShapes.length; p++) d = b.lineShapes[p], r(h, new v(d.length), d);
                    for (p = 0; p < b.rectangleShapes.length; p++) d =
                        b.rectangleShapes[p], r(h, new q(d.width, d.height), d);
                    for (p = 0; p < b.convexShapes.length; p++) d = b.convexShapes[p], r(h, new s(d.vertices), d);
                    for (p = 0; p < b.capsuleShapes.length; p++) d = b.capsuleShapes[p], r(h, new u(d.length, d.radius), d);
                    var r = function(a, b, d) {
                        b.collisionMask = d.collisionMask;
                        b.collisionGroup = d.collisionGroup;
                        d.material && (b.material = f[d.material + ""]);
                        a.addShape(b, d.offset, d.angle)
                    };
                    b.concavePath && (h.concavePath = b.concavePath);
                    this.addBody(h)
                }
                for (g = 0; g < a.springs.length; g++) {
                    b = a.springs[g];
                    r = e[b.bodyA];
                    d = e[b.bodyB];
                    if (!r) return this.error = "instance.springs[" + g + "] references instance.body[" + b.bodyA + "], which does not exist.", !1;
                    if (!d) return this.error = "instance.springs[" + g + "] references instance.body[" + b.bodyB + "], which does not exist.", !1;
                    d = new w(r, d, {
                        stiffness: b.stiffness,
                        damping: b.damping,
                        restLength: b.restLength,
                        localAnchorA: b.localAnchorA,
                        localAnchorB: b.localAnchorB
                    });
                    this.addSpring(d)
                }
                for (g = 0; g < a.contactMaterials.length; g++) {
                    d = a.contactMaterials[g];
                    r = f[d.materialA + ""];
                    b = f[d.materialB + ""];
                    if (!r) return this.error =
                        "Reference to material id " + d.materialA + ": material not found", !1;
                    if (!b) return this.error = "Reference to material id " + d.materialB + ": material not found", !1;
                    r = new C(r, b, {
                        friction: d.friction,
                        restitution: d.restitution,
                        stiffness: d.stiffness,
                        relaxation: d.relaxation,
                        frictionStiffness: d.frictionStiffness,
                        frictionRelaxation: d.frictionRelaxation
                    });
                    r.id = d.id;
                    this.addContactMaterial(r)
                }
                d = a.defaultContactMaterial;
                b = r = this.defaultMaterial;
                r = new C(r, b, {
                    friction: d.friction,
                    restitution: d.restitution,
                    stiffness: d.stiffness,
                    relaxation: d.relaxation,
                    frictionStiffness: d.frictionStiffness,
                    frictionRelaxation: d.frictionRelaxation
                });
                r.id = d.id;
                this.defaultContactMaterial = r;
                for (g = 0; g < a.distanceConstraints.length; g++) r = a.distanceConstraints[g], this.addConstraint(new F(e[r.bodyA], e[r.bodyB], r.distance, {
                    maxForce: r.maxForce,
                    collideConnected: r.collideConnected
                }));
                for (g = 0; g < a.revoluteConstraints.length; g++) r = a.revoluteConstraints[g], d = new I(e[r.bodyA], r.pivotA, e[r.bodyB], r.pivotB, {
                        maxForce: r.maxForce,
                        collideConnected: r.collideConnected
                    }),
                    r.motorEnabled && d.enableMotor(), d.setMotorSpeed(r.motorSpeed), d.lowerLimit = r.lowerLimit, d.upperLimit = r.upperLimit, d.lowerLimitEnabled = r.lowerLimitEnabled, d.upperLimitEnabled = r.upperLimitEnabled, this.addConstraint(d);
                for (g = 0; g < a.prismaticConstraints.length; g++) r = a.prismaticConstraints[g], d = new E(e[r.bodyA], e[r.bodyB], {
                    maxForce: r.maxForce,
                    localAxisA: r.localAxisA,
                    localAnchorA: r.localAnchorA,
                    localAnchorB: r.localAnchorB,
                    collideConnected: r.collideConnected
                }), d.motorSpeed = r.motorSpeed, this.addConstraint(d);
                for (g = 0; g < a.lockConstraints.length; g++) r = a.lockConstraints[g], this.addConstraint(new D(e[r.bodyA], e[r.bodyB], {
                    maxForce: r.maxForce,
                    localOffsetB: r.localOffsetB,
                    localAngleB: r.localAngleB,
                    collideConnected: r.collideConnected
                }));
                for (g = 0; g < a.gearConstraints.length; g++) r = a.gearConstraints[g], this.addConstraint(new H(e[r.bodyA], e[r.bodyB], {
                    maxForce: r.maxForce,
                    angle: r.angle,
                    ratio: r.ratio,
                    collideConnected: r.collideConnected
                }));
                return !0
            };
            d.prototype.clear = function() {
                this.fixedStepTime = this.time = 0;
                this.solver &&
                    this.solver.equations.length && this.solver.removeAllEquations();
                for (var a = this.constraints, b = a.length - 1; 0 <= b; b--) this.removeConstraint(a[b]);
                a = this.bodies;
                for (b = a.length - 1; 0 <= b; b--) this.removeBody(a[b]);
                a = this.springs;
                for (b = a.length - 1; 0 <= b; b--) this.removeSpring(a[b]);
                a = this.contactMaterials;
                for (b = a.length - 1; 0 <= b; b--) this.removeContactMaterial(a[b]);
                d.apply(this)
            };
            d.prototype.clone = function() {
                var a = new d;
                a.fromJSON(this.toJSON());
                return a
            };
            var W = m.create(),
                la = m.fromValues(0, 0),
                ba = m.fromValues(0, 0);
            d.prototype.hitTest = function(a, b, d) {
                d = d || 0;
                var e = new x({
                        position: a
                    }),
                    f = new A;
                e.addShape(f);
                for (var g = this.narrowphase, h = [], k = 0, l = b.length; k !== l; k++)
                    for (var p = b[k], q = 0, r = p.shapes.length; q !== r; q++) {
                        var v = p.shapes[q],
                            w = p.shapeAngles[q] || 0;
                        m.rotate(W, p.shapeOffsets[q] || la, p.angle);
                        m.add(W, W, p.position);
                        w += p.angle;
                        (v instanceof n && g.circleParticle(p, v, W, w, e, f, a, 0, !0) || v instanceof s && g.particleConvex(e, f, a, 0, p, v, W, w, !0) || v instanceof t && g.particlePlane(e, f, a, 0, p, v, W, w, !0) || v instanceof u && g.particleCapsule(e,
                            f, a, 0, p, v, W, w, !0) || v instanceof A && m.squaredLength(m.sub(ba, W, a)) < d * d) && h.push(p)
                    }
                return h
            };
            d.prototype.setGlobalEquationParameters = function(a) {
                a = a || {};
                for (var b = 0; b !== this.constraints.length; b++)
                    for (var d = this.constraints[b], e = 0; e !== d.equations.length; e++) {
                        var f = d.equations[e];
                        "undefined" !== typeof a.stiffness && (f.stiffness = a.stiffness);
                        "undefined" !== typeof a.relaxation && (f.relaxation = a.relaxation);
                        f.needsUpdate = !0
                    }
                for (b = 0; b !== this.contactMaterials.length; b++) d = this.contactMaterials[b], "undefined" !==
                    typeof a.stiffness && (d.stiffness = a.stiffness, d.frictionStiffness = a.stiffness), "undefined" !== typeof a.relaxation && (d.relaxation = a.relaxation, d.frictionRelaxation = a.relaxation);
                d = this.defaultContactMaterial;
                "undefined" !== typeof a.stiffness && (d.stiffness = a.stiffness, d.frictionStiffness = a.stiffness);
                "undefined" !== typeof a.relaxation && (d.relaxation = a.relaxation, d.frictionRelaxation = a.relaxation)
            };
            d.prototype.setGlobalStiffness = function(a) {
                this.setGlobalEquationParameters({
                    stiffness: a
                })
            };
            d.prototype.setGlobalRelaxation =
                function(a) {
                    this.setGlobalEquationParameters({
                        relaxation: a
                    })
                }
        }, {
            "../../package.json": 7,
            "../collision/Broadphase": 9,
            "../collision/NaiveBroadphase": 11,
            "../collision/Narrowphase": 12,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/Spring": 32,
            "../shapes/Capsule": 34,
            "../shapes/Circle": 35,
            "../shapes/Convex": 36,
            "../shapes/Line": 38,
            "../shapes/Particle": 39,
            "../shapes/Plane": 40,
            "../shapes/Rectangle": 41,
            "../shapes/Shape": 42,
            "../solver/GSSolver": 43,
            "../solver/Solver": 44,
            "../utils/OverlapKeeper": 45,
            "../utils/Utils": 47,
            "./IslandManager": 49
        }]
    }, {}, [33])(33)
});
p2.Body.prototype.parent = null;
p2.Spring.prototype.parent = null;
Phaser.Physics.P2 = function(c, g) {
    this.game = c;
    if ("undefined" === typeof g || !g.hasOwnProperty("gravity") || !g.hasOwnProperty("broadphase")) g = {
        gravity: [0, 0],
        broadphase: new p2.SAPBroadphase
    };
    this.world = new p2.World(g);
    this.frameRate = 1 / 60;
    this.paused = this.useElapsedTime = !1;
    this.materials = [];
    this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);
    this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    };
    this.onBodyAdded = new Phaser.Signal;
    this.onBodyRemoved = new Phaser.Signal;
    this.onSpringAdded =
        new Phaser.Signal;
    this.onSpringRemoved = new Phaser.Signal;
    this.onConstraintAdded = new Phaser.Signal;
    this.onConstraintRemoved = new Phaser.Signal;
    this.onContactMaterialAdded = new Phaser.Signal;
    this.onContactMaterialRemoved = new Phaser.Signal;
    this.callbackContext = this.postBroadphaseCallback = null;
    this.onBeginContact = new Phaser.Signal;
    this.onEndContact = new Phaser.Signal;
    g.hasOwnProperty("mpx") && (g.hasOwnProperty("pxm") && g.hasOwnProperty("mpxi") && g.hasOwnProperty("pxmi")) && (this.mpx = g.mpx, this.mpxi = g.mpxi, this.pxm =
        g.pxm, this.pxmi = g.pxmi);
    this.world.on("beginContact", this.beginContactHandler, this);
    this.world.on("endContact", this.endContactHandler, this);
    this.collisionGroups = [];
    this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
    this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
    this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
    this.boundsCollidesWith = [];
    this._toRemove = [];
    this._collisionGroupID = 2;
    this.setBoundsToWorld(!0, !0, !0, !0, !1)
};
Phaser.Physics.P2.prototype = {
    removeBodyNextStep: function(c) {
        this._toRemove.push(c)
    },
    preUpdate: function() {
        for (var c = this._toRemove.length; c--;) this.removeBody(this._toRemove[c]);
        this._toRemove.length = 0
    },
    enable: function(c, g, a) {
        "undefined" === typeof g && (g = !1);
        "undefined" === typeof a && (a = !0);
        var b = 1;
        if (Array.isArray(c))
            for (b = c.length; b--;) c[b] instanceof Phaser.Group ? this.enable(c[b].children, g, a) : (this.enableBody(c[b], g), a && (c[b].hasOwnProperty("children") && 0 < c[b].children.length) && this.enable(c[b], g, !0));
        else c instanceof Phaser.Group ? this.enable(c.children, g, a) : (this.enableBody(c, g), a && (c.hasOwnProperty("children") && 0 < c.children.length) && this.enable(c.children, g, !0))
    },
    enableBody: function(c, g) {
        c.hasOwnProperty("body") && null === c.body && (c.body = new Phaser.Physics.P2.Body(this.game, c, c.x, c.y, 1), c.body.debug = g, c.anchor.set(0.5))
    },
    setImpactEvents: function(c) {
        if (c) this.world.on("impact", this.impactHandler, this);
        else this.world.off("impact", this.impactHandler, this)
    },
    setPostBroadphaseCallback: function(c, g) {
        this.postBroadphaseCallback =
            c;
        this.callbackContext = g;
        if (null !== c) this.world.on("postBroadphase", this.postBroadphaseHandler, this);
        else this.world.off("postBroadphase", this.postBroadphaseHandler, this)
    },
    postBroadphaseHandler: function(c) {
        if (this.postBroadphaseCallback)
            for (var g = c.pairs.length; g -= 2;) c.pairs[g].parent && (c.pairs[g + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, c.pairs[g].parent, c.pairs[g + 1].parent)) && c.pairs.splice(g, 2)
    },
    impactHandler: function(c) {
        if (c.bodyA.parent && c.bodyB.parent) {
            var g = c.bodyA.parent,
                a = c.bodyB.parent;
            g._bodyCallbacks[c.bodyB.id] && g._bodyCallbacks[c.bodyB.id].call(g._bodyCallbackContext[c.bodyB.id], g, a, c.shapeA, c.shapeB);
            a._bodyCallbacks[c.bodyA.id] && a._bodyCallbacks[c.bodyA.id].call(a._bodyCallbackContext[c.bodyA.id], a, g, c.shapeB, c.shapeA);
            g._groupCallbacks[c.shapeB.collisionGroup] && g._groupCallbacks[c.shapeB.collisionGroup].call(g._groupCallbackContext[c.shapeB.collisionGroup], g, a, c.shapeA, c.shapeB);
            a._groupCallbacks[c.shapeA.collisionGroup] && a._groupCallbacks[c.shapeA.collisionGroup].call(a._groupCallbackContext[c.shapeA.collisionGroup],
                a, g, c.shapeB, c.shapeA)
        }
    },
    beginContactHandler: function(c) {
        this.onBeginContact.dispatch(c.bodyA, c.bodyB, c.shapeA, c.shapeB, c.contactEquations);
        c.bodyA.parent && c.bodyA.parent.onBeginContact.dispatch(c.bodyB.parent, c.shapeA, c.shapeB, c.contactEquations);
        c.bodyB.parent && c.bodyB.parent.onBeginContact.dispatch(c.bodyA.parent, c.shapeB, c.shapeA, c.contactEquations)
    },
    endContactHandler: function(c) {
        this.onEndContact.dispatch(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        c.bodyA.parent && c.bodyA.parent.onEndContact.dispatch(c.bodyB.parent,
            c.shapeA, c.shapeB);
        c.bodyB.parent && c.bodyB.parent.onEndContact.dispatch(c.bodyA.parent, c.shapeB, c.shapeA)
    },
    setBoundsToWorld: function(c, g, a, b, d) {
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, c, g, a, b, d)
    },
    setWorldMaterial: function(c, g, a, b, d) {
        "undefined" === typeof g && (g = !0);
        "undefined" === typeof a && (a = !0);
        "undefined" === typeof b && (b = !0);
        "undefined" === typeof d && (d = !0);
        g && this.walls.left && (this.walls.left.shapes[0].material = c);
        a &&
            this.walls.right && (this.walls.right.shapes[0].material = c);
        b && this.walls.top && (this.walls.top.shapes[0].material = c);
        d && this.walls.bottom && (this.walls.bottom.shapes[0].material = c)
    },
    updateBoundsCollisionGroup: function(c) {
        var g = this.everythingCollisionGroup.mask;
        "undefined" === typeof c && (g = this.boundsCollisionGroup.mask);
        this.walls.left && (this.walls.left.shapes[0].collisionGroup = g);
        this.walls.right && (this.walls.right.shapes[0].collisionGroup = g);
        this.walls.top && (this.walls.top.shapes[0].collisionGroup =
            g);
        this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = g)
    },
    setBounds: function(c, g, a, b, d, e, f, h, k) {
        "undefined" === typeof d && (d = !0);
        "undefined" === typeof e && (e = !0);
        "undefined" === typeof f && (f = !0);
        "undefined" === typeof h && (h = !0);
        "undefined" === typeof k && (k = !0);
        this.walls.left && this.world.removeBody(this.walls.left);
        this.walls.right && this.world.removeBody(this.walls.right);
        this.walls.top && this.world.removeBody(this.walls.top);
        this.walls.bottom && this.world.removeBody(this.walls.bottom);
        d && (this.walls.left =
            new p2.Body({
                mass: 0,
                position: [this.pxmi(c), this.pxmi(g)],
                angle: 1.5707963267948966
            }), this.walls.left.addShape(new p2.Plane), k && (this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.left));
        e && (this.walls.right = new p2.Body({
            mass: 0,
            position: [this.pxmi(c + a), this.pxmi(g)],
            angle: -1.5707963267948966
        }), this.walls.right.addShape(new p2.Plane), k && (this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.right));
        f && (this.walls.top = new p2.Body({
            mass: 0,
            position: [this.pxmi(c), this.pxmi(g)],
            angle: -3.141592653589793
        }), this.walls.top.addShape(new p2.Plane), k && (this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.top));
        h && (this.walls.bottom = new p2.Body({
            mass: 0,
            position: [this.pxmi(c), this.pxmi(b)]
        }), this.walls.bottom.addShape(new p2.Plane), k && (this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.bottom))
    },
    pause: function() {
        this.paused = !0
    },
    resume: function() {
        this.paused = !1
    },
    update: function() {
        this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
    },
    clear: function() {
        this.world.clear();
        this.world.off("beginContact", this.beginContactHandler, this);
        this.world.off("endContact", this.endContactHandler, this);
        this.impactCallback = this.callbackContext = this.postBroadphaseCallback = null;
        this.collisionGroups = [];
        this._toRemove = [];
        this._collisionGroupID = 2;
        this.boundsCollidesWith = []
    },
    destroy: function() {
        this.clear();
        this.game = null
    },
    addBody: function(c) {
        if (c.data.world) return !1;
        this.world.addBody(c.data);
        this.onBodyAdded.dispatch(c);
        return !0
    },
    removeBody: function(c) {
        c.data.world == this.world && (this.world.removeBody(c.data), this.onBodyRemoved.dispatch(c));
        return c
    },
    addSpring: function(c) {
        this.world.addSpring(c);
        this.onSpringAdded.dispatch(c);
        return c
    },
    removeSpring: function(c) {
        this.world.removeSpring(c);
        this.onSpringRemoved.dispatch(c);
        return c
    },
    createDistanceConstraint: function(c, g, a, b) {
        c = this.getBody(c);
        g = this.getBody(g);
        if (!c || !g) console.warn("Cannot create Constraint, invalid body objects given");
        else return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, c, g, a, b))
    },
    createGearConstraint: function(c, g, a, b) {
        c = this.getBody(c);
        g = this.getBody(g);
        if (!c || !g) console.warn("Cannot create Constraint, invalid body objects given");
        else return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, c, g, a, b))
    },
    createRevoluteConstraint: function(c, g, a, b, d) {
        c = this.getBody(c);
        a = this.getBody(a);
        if (!c || !a) console.warn("Cannot create Constraint, invalid body objects given");
        else return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, c, g, a, b, d))
    },
    createLockConstraint: function(c, g, a, b, d) {
        c = this.getBody(c);
        g = this.getBody(g);
        if (!c || !g) console.warn("Cannot create Constraint, invalid body objects given");
        else return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, c, g, a, b, d))
    },
    createPrismaticConstraint: function(c, g, a, b, d, e, f) {
        c = this.getBody(c);
        g = this.getBody(g);
        if (!c || !g) console.warn("Cannot create Constraint, invalid body objects given");
        else return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this,
            c, g, a, b, d, e, f))
    },
    addConstraint: function(c) {
        this.world.addConstraint(c);
        this.onConstraintAdded.dispatch(c);
        return c
    },
    removeConstraint: function(c) {
        this.world.removeConstraint(c);
        this.onConstraintRemoved.dispatch(c);
        return c
    },
    addContactMaterial: function(c) {
        this.world.addContactMaterial(c);
        this.onContactMaterialAdded.dispatch(c);
        return c
    },
    removeContactMaterial: function(c) {
        this.world.removeContactMaterial(c);
        this.onContactMaterialRemoved.dispatch(c);
        return c
    },
    getContactMaterial: function(c, g) {
        return this.world.getContactMaterial(c,
            g)
    },
    setMaterial: function(c, g) {
        for (var a = g.length; a--;) g[a].setMaterial(c)
    },
    createMaterial: function(c, g) {
        var a = new Phaser.Physics.P2.Material(c || "");
        this.materials.push(a);
        "undefined" !== typeof g && g.setMaterial(a);
        return a
    },
    createContactMaterial: function(c, g, a) {
        "undefined" === typeof c && (c = this.createMaterial());
        "undefined" === typeof g && (g = this.createMaterial());
        c = new Phaser.Physics.P2.ContactMaterial(c, g, a);
        return this.addContactMaterial(c)
    },
    getBodies: function() {
        for (var c = [], g = this.world.bodies.length; g--;) c.push(this.world.bodies[g].parent);
        return c
    },
    getBody: function(c) {
        return c instanceof p2.Body ? c : c instanceof Phaser.Physics.P2.Body ? c.data : c.body && c.body.type === Phaser.Physics.P2JS ? c.body.data : null
    },
    getSprings: function() {
        for (var c = [], g = this.world.springs.length; g--;) c.push(this.world.springs[g].parent);
        return c
    },
    getConstraints: function() {
        for (var c = [], g = this.world.constraints.length; g--;) c.push(this.world.constraints[g].parent);
        return c
    },
    hitTest: function(c, g, a, b) {
        "undefined" === typeof g && (g = this.world.bodies);
        "undefined" === typeof a &&
            (a = 5);
        "undefined" === typeof b && (b = !1);
        c = [this.pxmi(c.x), this.pxmi(c.y)];
        for (var d = [], e = g.length; e--;) g[e] instanceof Phaser.Physics.P2.Body && !(b && g[e].data.motionState === p2.Body.STATIC) ? d.push(g[e].data) : g[e] instanceof p2.Body && g[e].parent && !(b && g[e].motionState === p2.Body.STATIC) ? d.push(g[e]) : g[e] instanceof Phaser.Sprite && (g[e].hasOwnProperty("body") && !(b && g[e].body.data.motionState === p2.Body.STATIC)) && d.push(g[e].body.data);
        return this.world.hitTest(c, d, a)
    },
    toJSON: function() {
        return this.world.toJSON()
    },
    createCollisionGroup: function(c) {
        var g = Math.pow(2, this._collisionGroupID);
        this.walls.left && (this.walls.left.shapes[0].collisionMask |= g);
        this.walls.right && (this.walls.right.shapes[0].collisionMask |= g);
        this.walls.top && (this.walls.top.shapes[0].collisionMask |= g);
        this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask |= g);
        this._collisionGroupID++;
        g = new Phaser.Physics.P2.CollisionGroup(g);
        this.collisionGroups.push(g);
        c && this.setCollisionGroup(c, g);
        return g
    },
    setCollisionGroup: function(c, g) {
        if (c instanceof Phaser.Group)
            for (var a = 0; a < c.total; a++) c.children[a].body && c.children[a].body.type === Phaser.Physics.P2JS && c.children[a].body.setCollisionGroup(g);
        else c.body.setCollisionGroup(g)
    },
    createSpring: function(c, g, a, b, d, e, f, h, k) {
        c = this.getBody(c);
        g = this.getBody(g);
        if (!c || !g) console.warn("Cannot create Spring, invalid body objects given");
        else return this.addSpring(new Phaser.Physics.P2.Spring(this, c, g, a, b, d, e, f, h, k))
    },
    createBody: function(c, g, a, b, d, e) {
        "undefined" === typeof b && (b = !1);
        c = new Phaser.Physics.P2.Body(this.game,
            null, c, g, a);
        if (e && !c.addPolygon(d, e)) return !1;
        b && this.world.addBody(c.data);
        return c
    },
    createParticle: function(c, g, a, b, d, e) {
        "undefined" === typeof b && (b = !1);
        c = new Phaser.Physics.P2.Body(this.game, null, c, g, a);
        if (e && !c.addPolygon(d, e)) return !1;
        b && this.world.addBody(c.data);
        return c
    },
    convertCollisionObjects: function(c, g, a) {
        "undefined" === typeof a && (a = !0);
        for (var b = [], d = 0, e = c.collision[g].length; d < e; d++) {
            var f = c.collision[g][d];
            (f = this.createBody(f.x, f.y, 0, a, {}, f.polyline)) && b.push(f)
        }
        return b
    },
    clearTilemapLayerBodies: function(c,
        g) {
        g = c.getLayer(g);
        for (var a = c.layers[g].bodies.length; a--;) c.layers[g].bodies[a].destroy();
        c.layers[g].bodies.length = 0
    },
    convertTilemap: function(c, g, a, b) {
        g = c.getLayer(g);
        "undefined" === typeof a && (a = !0);
        "undefined" === typeof b && (b = !0);
        this.clearTilemapLayerBodies(c, g);
        for (var d = 0, e = 0, f = 0, h = 0, k = c.layers[g].height; h < k; h++)
            for (var p = d = 0, l = c.layers[g].width; p < l; p++) {
                var m = c.layers[g].data[h][p];
                if (m && -1 < m.index && m.collides)
                    if (b) {
                        var n = c.getTileRight(g, p, h);
                        0 === d && (e = m.x * m.width, f = m.y * m.height, d = m.width);
                        n && n.collides ? d += m.width : (n = this.createBody(e, f, 0, !1), n.addRectangle(d, m.height, d / 2, m.height / 2, 0), a && this.addBody(n), c.layers[g].bodies.push(n), d = 0)
                    } else n = this.createBody(m.x * m.width, m.y * m.height, 0, !1), n.addRectangle(m.width, m.height, m.width / 2, m.height / 2, 0), a && this.addBody(n), c.layers[g].bodies.push(n)
            }
        return c.layers[g].bodies
    },
    mpx: function(c) {
        return 20 * c
    },
    pxm: function(c) {
        return 0.05 * c
    },
    mpxi: function(c) {
        return -20 * c
    },
    pxmi: function(c) {
        return -0.05 * c
    }
};
Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
    get: function() {
        return this.world.defaultContactMaterial.friction
    },
    set: function(c) {
        this.world.defaultContactMaterial.friction = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "defaultFriction", {
    get: function() {
        return this.world.defaultContactMaterial.friction
    },
    set: function(c) {
        this.world.defaultContactMaterial.friction = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution
    },
    set: function(c) {
        this.world.defaultContactMaterial.restitution = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "defaultRestitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution
    },
    set: function(c) {
        this.world.defaultContactMaterial.restitution = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
    get: function() {
        return this.world.defaultContactMaterial
    },
    set: function(c) {
        this.world.defaultContactMaterial = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
    get: function() {
        return this.world.applySpringForces
    },
    set: function(c) {
        this.world.applySpringForces = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
    get: function() {
        return this.world.applyDamping
    },
    set: function(c) {
        this.world.applyDamping = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
    get: function() {
        return this.world.applyGravity
    },
    set: function(c) {
        this.world.applyGravity = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
    get: function() {
        return this.world.solveConstraints
    },
    set: function(c) {
        this.world.solveConstraints = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
    get: function() {
        return this.world.time
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
    get: function() {
        return this.world.emitImpactEvent
    },
    set: function(c) {
        this.world.emitImpactEvent = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "enableBodySleeping", {
    get: function() {
        return this.world.enableBodySleeping
    },
    set: function(c) {
        this.world.enableBodySleeping = c
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
    get: function() {
        return this.world.bodies.length
    }
});
Phaser.Physics.P2.FixtureList = function(c) {
    Array.isArray(c) || (c = [c]);
    this.rawList = c;
    this.init();
    this.parse(this.rawList)
};
Phaser.Physics.P2.FixtureList.prototype = {
    init: function() {
        this.namedFixtures = {};
        this.groupedFixtures = [];
        this.allFixtures = []
    },
    setCategory: function(c, g) {
        this.getFixtures(g).forEach(function(a) {
            a.collisionGroup = c
        })
    },
    setMask: function(c, g) {
        this.getFixtures(g).forEach(function(a) {
            a.collisionMask = c
        })
    },
    setSensor: function(c, g) {
        this.getFixtures(g).forEach(function(a) {
            a.sensor = c
        })
    },
    setMaterial: function(c, g) {
        this.getFixtures(g).forEach(function(a) {
            a.material = c
        })
    },
    getFixtures: function(c) {
        var g = [];
        if (c) {
            c instanceof
            Array || (c = [c]);
            var a = this;
            c.forEach(function(b) {
                a.namedFixtures[b] && g.push(a.namedFixtures[b])
            });
            return this.flatten(g)
        }
        return this.allFixtures
    },
    getFixtureByKey: function(c) {
        return this.namedFixtures[c]
    },
    getGroup: function(c) {
        return this.groupedFixtures[c]
    },
    parse: function() {
        var c, g, a, b;
        a = this.rawList;
        b = [];
        for (c in a) g = a[c], isNaN(c - 0) ? this.namedFixtures[c] = this.flatten(g) : (this.groupedFixtures[c] = this.groupedFixtures[c] || [], this.groupedFixtures[c] = this.groupedFixtures[c].concat(g)), b.push(this.allFixtures =
            this.flatten(this.groupedFixtures))
    },
    flatten: function(c) {
        var g, a;
        g = [];
        a = arguments.callee;
        c.forEach(function(b) {
            return Array.prototype.push.apply(g, Array.isArray(b) ? a(b) : [b])
        });
        return g
    }
};
Phaser.Physics.P2.PointProxy = function(c, g) {
    this.world = c;
    this.destination = g
};
Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;
Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
    get: function() {
        return this.destination[0]
    },
    set: function(c) {
        this.destination[0] = this.world.pxm(c)
    }
});
Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
    get: function() {
        return this.destination[1]
    },
    set: function(c) {
        this.destination[1] = this.world.pxm(c)
    }
});
Phaser.Physics.P2.InversePointProxy = function(c, g) {
    this.world = c;
    this.destination = g
};
Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;
Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
    get: function() {
        return this.destination[0]
    },
    set: function(c) {
        this.destination[0] = this.world.pxm(-c)
    }
});
Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
    get: function() {
        return this.destination[1]
    },
    set: function(c) {
        this.destination[1] = this.world.pxm(-c)
    }
});
Phaser.Physics.P2.Body = function(c, g, a, b, d) {
    g = g || null;
    a = a || 0;
    b = b || 0;
    "undefined" === typeof d && (d = 1);
    this.game = c;
    this.world = c.physics.p2;
    this.sprite = g;
    this.type = Phaser.Physics.P2JS;
    this.offset = new Phaser.Point;
    this.data = new p2.Body({
        position: [this.world.pxmi(a), this.world.pxmi(b)],
        mass: d
    });
    this.data.parent = this;
    this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);
    this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);
    this.gravity = new Phaser.Point;
    this.onBeginContact = new Phaser.Signal;
    this.onEndContact = new Phaser.Signal;
    this.collidesWith = [];
    this.removeNextStep = !1;
    this.debugBody = null;
    this._collideWorldBounds = !0;
    this._bodyCallbacks = {};
    this._bodyCallbackContext = {};
    this._groupCallbacks = {};
    this._groupCallbackContext = {};
    g && (this.setRectangleFromSprite(g), g.exists && this.game.physics.p2.addBody(this))
};
Phaser.Physics.P2.Body.prototype = {
    createBodyCallback: function(c, g, a) {
        var b = -1;
        c.id ? b = c.id : c.body && (b = c.body.id); - 1 < b && (null === g ? (delete this._bodyCallbacks[b], delete this._bodyCallbackContext[b]) : (this._bodyCallbacks[b] = g, this._bodyCallbackContext[b] = a))
    },
    createGroupCallback: function(c, g, a) {
        null === g ? (delete this._groupCallbacks[c.mask], delete this._groupCallbacksContext[c.mask]) : (this._groupCallbacks[c.mask] = g, this._groupCallbackContext[c.mask] = a)
    },
    getCollisionMask: function() {
        var c = 0;
        this._collideWorldBounds &&
            (c = this.game.physics.p2.boundsCollisionGroup.mask);
        for (var g = 0; g < this.collidesWith.length; g++) c |= this.collidesWith[g].mask;
        return c
    },
    updateCollisionMask: function(c) {
        var g = this.getCollisionMask();
        if ("undefined" === typeof c)
            for (c = this.data.shapes.length - 1; 0 <= c; c--) this.data.shapes[c].collisionMask = g;
        else c.collisionMask = g
    },
    setCollisionGroup: function(c, g) {
        var a = this.getCollisionMask();
        if ("undefined" === typeof g)
            for (var b = this.data.shapes.length - 1; 0 <= b; b--) this.data.shapes[b].collisionGroup = c.mask, this.data.shapes[b].collisionMask =
                a;
        else g.collisionGroup = c.mask, g.collisionMask = a
    },
    clearCollision: function(c, g, a) {
        if ("undefined" === typeof a)
            for (a = this.data.shapes.length - 1; 0 <= a; a--) c && (this.data.shapes[a].collisionGroup = null), g && (this.data.shapes[a].collisionMask = null);
        else c && (a.collisionGroup = null), g && (a.collisionMask = null);
        c && (this.collidesWith.length = 0)
    },
    collides: function(c, g, a, b) {
        if (Array.isArray(c))
            for (var d = 0; d < c.length; d++) - 1 === this.collidesWith.indexOf(c[d]) && (this.collidesWith.push(c[d]), g && this.createGroupCallback(c[d],
                g, a));
        else -1 === this.collidesWith.indexOf(c) && (this.collidesWith.push(c), g && this.createGroupCallback(c, g, a));
        c = this.getCollisionMask();
        if ("undefined" === typeof b)
            for (d = this.data.shapes.length - 1; 0 <= d; d--) this.data.shapes[d].collisionMask = c;
        else b.collisionMask = c
    },
    adjustCenterOfMass: function() {
        this.data.adjustCenterOfMass()
    },
    applyDamping: function(c) {
        this.data.applyDamping(c)
    },
    applyForce: function(c, g, a) {
        this.data.applyForce(c, [this.world.pxmi(g), this.world.pxmi(a)])
    },
    setZeroForce: function() {
        this.data.setZeroForce()
    },
    setZeroRotation: function() {
        this.data.angularVelocity = 0
    },
    setZeroVelocity: function() {
        this.data.velocity[0] = 0;
        this.data.velocity[1] = 0
    },
    setZeroDamping: function() {
        this.data.damping = 0;
        this.data.angularDamping = 0
    },
    toLocalFrame: function(c, g) {
        return this.data.toLocalFrame(c, g)
    },
    toWorldFrame: function(c, g) {
        return this.data.toWorldFrame(c, g)
    },
    rotateLeft: function(c) {
        this.data.angularVelocity = this.world.pxm(-c)
    },
    rotateRight: function(c) {
        this.data.angularVelocity = this.world.pxm(c)
    },
    moveForward: function(c) {
        c = this.world.pxmi(-c);
        var g = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = c * Math.cos(g);
        this.data.velocity[1] = c * Math.sin(g)
    },
    moveBackward: function(c) {
        c = this.world.pxmi(-c);
        var g = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = -(c * Math.cos(g));
        this.data.velocity[1] = -(c * Math.sin(g))
    },
    thrust: function(c) {
        c = this.world.pxmi(-c);
        var g = this.data.angle + Math.PI / 2;
        this.data.force[0] += c * Math.cos(g);
        this.data.force[1] += c * Math.sin(g)
    },
    reverse: function(c) {
        c = this.world.pxmi(-c);
        var g = this.data.angle + Math.PI / 2;
        this.data.force[0] -= c *
            Math.cos(g);
        this.data.force[1] -= c * Math.sin(g)
    },
    moveLeft: function(c) {
        this.data.velocity[0] = this.world.pxmi(-c)
    },
    moveRight: function(c) {
        this.data.velocity[0] = this.world.pxmi(c)
    },
    moveUp: function(c) {
        this.data.velocity[1] = this.world.pxmi(-c)
    },
    moveDown: function(c) {
        this.data.velocity[1] = this.world.pxmi(c)
    },
    preUpdate: function() {
        this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
    },
    postUpdate: function() {
        this.sprite.x = this.world.mpxi(this.data.position[0]);
        this.sprite.y = this.world.mpxi(this.data.position[1]);
        this.fixedRotation || (this.sprite.rotation = this.data.angle)
    },
    reset: function(c, g, a, b) {
        "undefined" === typeof a && (a = !1);
        "undefined" === typeof b && (b = !1);
        this.setZeroForce();
        this.setZeroVelocity();
        this.setZeroRotation();
        a && this.setZeroDamping();
        b && (this.mass = 1);
        this.x = c;
        this.y = g
    },
    addToWorld: function() {
        this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
    },
    removeFromWorld: function() {
        this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
    },
    destroy: function() {
        this.removeFromWorld();
        this.clearShapes();
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        this.debugBody && this.debugBody.destroy();
        this.sprite = this.debugBody = null
    },
    clearShapes: function() {
        for (var c = this.data.shapes.length; c--;) this.data.removeShape(this.data.shapes[c]);
        this.shapeChanged()
    },
    addShape: function(c, g, a, b) {
        "undefined" === typeof g && (g = 0);
        "undefined" === typeof a && (a = 0);
        "undefined" === typeof b && (b = 0);
        this.data.addShape(c, [this.world.pxmi(g), this.world.pxmi(a)],
            b);
        this.shapeChanged();
        return c
    },
    addCircle: function(c, g, a, b) {
        c = new p2.Circle(this.world.pxm(c));
        return this.addShape(c, g, a, b)
    },
    addRectangle: function(c, g, a, b, d) {
        c = new p2.Rectangle(this.world.pxm(c), this.world.pxm(g));
        return this.addShape(c, a, b, d)
    },
    addPlane: function(c, g, a) {
        var b = new p2.Plane;
        return this.addShape(b, c, g, a)
    },
    addParticle: function(c, g, a) {
        var b = new p2.Particle;
        return this.addShape(b, c, g, a)
    },
    addLine: function(c, g, a, b) {
        c = new p2.Line(this.world.pxm(c));
        return this.addShape(c, g, a, b)
    },
    addCapsule: function(c,
        g, a, b, d) {
        c = new p2.Capsule(this.world.pxm(c), g);
        return this.addShape(c, a, b, d)
    },
    addPolygon: function(c, g) {
        c = c || {};
        g = Array.prototype.slice.call(arguments, 1);
        var a = [];
        if (1 === g.length && Array.isArray(g[0])) a = g[0].slice(0);
        else if (Array.isArray(g[0])) a = g[0].slice(0);
        else if ("number" === typeof g[0])
            for (var b = 0, d = g.length; b < d; b += 2) a.push([g[b], g[b + 1]]);
        b = a.length - 1;
        a[b][0] === a[0][0] && a[b][1] === a[0][1] && a.pop();
        for (b = 0; b < a.length; b++) a[b][0] = this.world.pxmi(a[b][0]), a[b][1] = this.world.pxmi(a[b][1]);
        a = this.data.fromPolygon(a,
            c);
        this.shapeChanged();
        return a
    },
    removeShape: function(c) {
        return this.data.removeShape(c)
    },
    setCircle: function(c, g, a, b) {
        this.clearShapes();
        return this.addCircle(c, g, a, b)
    },
    setRectangle: function(c, g, a, b, d) {
        "undefined" === typeof c && (c = 16);
        "undefined" === typeof g && (g = 16);
        this.clearShapes();
        return this.addRectangle(c, g, a, b, d)
    },
    setRectangleFromSprite: function(c) {
        "undefined" === typeof c && (c = this.sprite);
        this.clearShapes();
        return this.addRectangle(c.width, c.height, 0, 0, c.rotation)
    },
    setMaterial: function(c, g) {
        if ("undefined" ===
            typeof g)
            for (var a = this.data.shapes.length - 1; 0 <= a; a--) this.data.shapes[a].material = c;
        else g.material = c
    },
    shapeChanged: function() {
        this.debugBody && this.debugBody.draw()
    },
    addPhaserPolygon: function(c, g) {
        for (var a = this.game.cache.getPhysicsData(c, g), b = [], d = 0; d < a.length; d++) {
            var e = a[d],
                f = this.addFixture(e);
            b[e.filter.group] = b[e.filter.group] || [];
            b[e.filter.group] = b[e.filter.group].concat(f);
            e.fixtureKey && (b[e.fixtureKey] = f)
        }
        this.data.aabbNeedsUpdate = !0;
        this.shapeChanged();
        return b
    },
    addFixture: function(c) {
        var g = [];
        if (c.circle) {
            var a = new p2.Circle(this.world.pxm(c.circle.radius));
            a.collisionGroup = c.filter.categoryBits;
            a.collisionMask = c.filter.maskBits;
            a.sensor = c.isSensor;
            var b = p2.vec2.create();
            b[0] = this.world.pxmi(c.circle.position[0] - this.sprite.width / 2);
            b[1] = this.world.pxmi(c.circle.position[1] - this.sprite.height / 2);
            this.data.addShape(a, b);
            g.push(a)
        } else
            for (var b = c.polygons, d = p2.vec2.create(), e = 0; e < b.length; e++) {
                for (var a = b[e], f = [], h = 0; h < a.length; h += 2) f.push([this.world.pxmi(a[h]), this.world.pxmi(a[h +
                    1])]);
                a = new p2.Convex(f);
                for (f = 0; f !== a.vertices.length; f++) h = a.vertices[f], p2.vec2.sub(h, h, a.centerOfMass);
                p2.vec2.scale(d, a.centerOfMass, 1);
                d[0] -= this.world.pxmi(this.sprite.width / 2);
                d[1] -= this.world.pxmi(this.sprite.height / 2);
                a.updateTriangles();
                a.updateCenterOfMass();
                a.updateBoundingRadius();
                a.collisionGroup = c.filter.categoryBits;
                a.collisionMask = c.filter.maskBits;
                a.sensor = c.isSensor;
                this.data.addShape(a, d);
                g.push(a)
            }
        return g
    },
    loadPolygon: function(c, g) {
        for (var a = this.game.cache.getPhysicsData(c,
                g), b = p2.vec2.create(), d = 0; d < a.length; d++) {
            for (var e = [], f = 0; f < a[d].shape.length; f += 2) e.push([this.world.pxmi(a[d].shape[f]), this.world.pxmi(a[d].shape[f + 1])]);
            e = new p2.Convex(e);
            for (f = 0; f !== e.vertices.length; f++) {
                var h = e.vertices[f];
                p2.vec2.sub(h, h, e.centerOfMass)
            }
            p2.vec2.scale(b, e.centerOfMass, 1);
            b[0] -= this.world.pxmi(this.sprite.width / 2);
            b[1] -= this.world.pxmi(this.sprite.height / 2);
            e.updateTriangles();
            e.updateCenterOfMass();
            e.updateBoundingRadius();
            this.data.addShape(e, b)
        }
        this.data.aabbNeedsUpdate = !0;
        this.shapeChanged();
        return !0
    },
    loadData: function(c, g) {
        var a = this.game.cache.getPhysicsData(c, g);
        if (a && a.shape) return this.mass = a.density, this.loadPolygon(c, g)
    }
};
Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;
Phaser.Physics.P2.Body.DYNAMIC = 1;
Phaser.Physics.P2.Body.STATIC = 2;
Phaser.Physics.P2.Body.KINEMATIC = 4;
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.STATIC
    },
    set: function(c) {
        c && this.data.motionState !== Phaser.Physics.P2.Body.STATIC ? (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0) : !c && this.data.motionState === Phaser.Physics.P2.Body.STATIC && (this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC, 0 === this.mass && (this.mass = 1))
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC
    },
    set: function(c) {
        c && this.data.motionState !== Phaser.Physics.P2.Body.DYNAMIC ? (this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC, 0 === this.mass && (this.mass = 1)) : !c && this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC && (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC
    },
    set: function(c) {
        c && this.data.motionState !== Phaser.Physics.P2.Body.KINEMATIC ? (this.data.motionState = Phaser.Physics.P2.Body.KINEMATIC, this.mass = 4) : !c && this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC && (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
    get: function() {
        return this.data.allowSleep
    },
    set: function(c) {
        c !== this.data.allowSleep && (this.data.allowSleep = c)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle))
    },
    set: function(c) {
        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(c))
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.angularDamping
    },
    set: function(c) {
        this.data.angularDamping = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
    get: function() {
        return this.data.angularForce
    },
    set: function(c) {
        this.data.angularForce = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.angularVelocity
    },
    set: function(c) {
        this.data.angularVelocity = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
    get: function() {
        return this.data.damping
    },
    set: function(c) {
        this.data.damping = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.fixedRotation
    },
    set: function(c) {
        c !== this.data.fixedRotation && (this.data.fixedRotation = c)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
    get: function() {
        return this.data.inertia
    },
    set: function(c) {
        this.data.inertia = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
    get: function() {
        return this.data.mass
    },
    set: function(c) {
        c !== this.data.mass && (this.data.mass = c, this.data.updateMassProperties())
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
    get: function() {
        return this.data.motionState
    },
    set: function(c) {
        c !== this.data.motionState && (this.data.motionState = c)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
    get: function() {
        return this.data.angle
    },
    set: function(c) {
        this.data.angle = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
    get: function() {
        return this.data.sleepSpeedLimit
    },
    set: function(c) {
        this.data.sleepSpeedLimit = c
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.data.position[0])
    },
    set: function(c) {
        this.data.position[0] = this.world.pxmi(c)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.data.position[1])
    },
    set: function(c) {
        this.data.position[1] = this.world.pxmi(c)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
    get: function() {
        return this.data.id
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
    get: function() {
        return !this.debugBody
    },
    set: function(c) {
        c && !this.debugBody ? this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data) : !c && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
    get: function() {
        return this._collideWorldBounds
    },
    set: function(c) {
        c && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !c && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
    }
});
Phaser.Physics.P2.BodyDebug = function(c, g, a) {
    Phaser.Group.call(this, c);
    this.settings = Phaser.Utils.extend({
        pixelsPerLengthUnit: 20,
        debugPolygons: !1,
        lineWidth: 1,
        alpha: 0.5
    }, a);
    this.ppu = this.settings.pixelsPerLengthUnit;
    this.ppu *= -1;
    this.body = g;
    this.canvas = new Phaser.Graphics(c);
    this.canvas.alpha = this.settings.alpha;
    this.add(this.canvas);
    this.draw()
};
Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);
Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;
Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
    update: function() {
        this.updateSpriteTransform()
    },
    updateSpriteTransform: function() {
        this.position.x = this.body.position[0] * this.ppu;
        this.position.y = this.body.position[1] * this.ppu;
        return this.rotation = this.body.angle
    },
    draw: function() {
        var c, g, a, b, d, e, f, h, k, p, l, m, n;
        f = this.body;
        k = this.canvas;
        k.clear();
        a = parseInt(this.randomPastelHex(), 16);
        e = this.lineWidth;
        if (f instanceof p2.Body && f.shapes.length) {
            var q = f.shapes.length;
            for (b = 0; b !== q;) {
                g = f.shapes[b];
                h = f.shapeOffsets[b];
                c = f.shapeAngles[b];
                h = h || 0;
                c = c || 0;
                if (g instanceof p2.Circle) this.drawCircle(k, h[0] * this.ppu, h[1] * this.ppu, c, g.radius * this.ppu, a, e);
                else if (g instanceof p2.Convex) {
                    p = [];
                    l = p2.vec2.create();
                    d = m = 0;
                    for (n = g.vertices.length; 0 <= n ? m < n : m > n; d = 0 <= n ? ++m : --m) d = g.vertices[d], p2.vec2.rotate(l, d, c), p.push([(l[0] + h[0]) * this.ppu, -(l[1] + h[1]) * this.ppu]);
                    this.drawConvex(k, p, g.triangles, 16711680, a, e, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                } else g instanceof p2.Plane ? this.drawPlane(k,
                    h[0] * this.ppu, -h[1] * this.ppu, a, 16711680, 5 * e, 10 * e, 10 * e, 100 * this.ppu, c) : g instanceof p2.Line ? this.drawLine(k, g.length * this.ppu, 16711680, e) : g instanceof p2.Rectangle && this.drawRectangle(k, h[0] * this.ppu, -h[1] * this.ppu, c, g.width * this.ppu, g.height * this.ppu, 16711680, a, e);
                b++
            }
        }
    },
    drawRectangle: function(c, g, a, b, d, e, f, h, k) {
        "undefined" === typeof k && (k = 1);
        "undefined" === typeof f && (f = 0);
        c.lineStyle(k, f, 1);
        c.beginFill(h);
        c.drawRect(g - d / 2, a - e / 2, d, e)
    },
    drawCircle: function(c, g, a, b, d, e, f) {
        "undefined" === typeof f && (f = 1);
        "undefined" === typeof e && (e = 16777215);
        c.lineStyle(f, 0, 1);
        c.beginFill(e, 1);
        c.drawCircle(g, a, -d);
        c.endFill();
        c.moveTo(g, a);
        c.lineTo(g + d * Math.cos(-b), a + d * Math.sin(-b))
    },
    drawLine: function(c, g, a, b) {
        "undefined" === typeof b && (b = 1);
        "undefined" === typeof a && (a = 0);
        c.lineStyle(5 * b, a, 1);
        c.moveTo(-g / 2, 0);
        c.lineTo(g / 2, 0)
    },
    drawConvex: function(c, g, a, b, d, e, f, h) {
        var k, p;
        "undefined" === typeof e && (e = 1);
        "undefined" === typeof b && (b = 0);
        if (f) {
            b = [16711680, 65280, 255];
            for (a = 0; a !== g.length + 1;) k = g[a % g.length], f = g[(a + 1) % g.length],
                d = k[0], p = k[1], k = f[0], f = f[1], c.lineStyle(e, b[a % b.length], 1), c.moveTo(d, -p), c.lineTo(k, -f), c.drawCircle(d, -p, 2 * e), a++;
            c.lineStyle(e, 0, 1);
            return c.drawCircle(h[0], h[1], 2 * e)
        }
        c.lineStyle(e, b, 1);
        c.beginFill(d);
        for (a = 0; a !== g.length;) h = g[a], e = h[0], h = h[1], 0 === a ? c.moveTo(e, -h) : c.lineTo(e, -h), a++;
        c.endFill();
        if (2 < g.length) return c.moveTo(g[g.length - 1][0], -g[g.length - 1][1]), c.lineTo(g[0][0], -g[0][1])
    },
    drawPath: function(c, g, a, b, d) {
        var e, f, h, k, p, l, m;
        "undefined" === typeof d && (d = 1);
        "undefined" === typeof a && (a = 0);
        c.lineStyle(d,
            a, 1);
        "number" === typeof b && c.beginFill(b);
        f = e = null;
        for (a = 0; a < g.length;) {
            m = g[a];
            d = m[0];
            m = m[1];
            if (d !== e || m !== f) 0 === a ? c.moveTo(d, m) : (h = d, k = m, p = g[(a + 1) % g.length][0], l = g[(a + 1) % g.length][1], e = (h - e) * (l - f) - (p - e) * (k - f), 0 !== e && c.lineTo(d, m)), e = d, f = m;
            a++
        }
        "number" === typeof b && c.endFill();
        2 < g.length && "number" === typeof b && (c.moveTo(g[g.length - 1][0], g[g.length - 1][1]), c.lineTo(g[0][0], g[0][1]))
    },
    drawPlane: function(c, g, a, b, d, e, f, h, k, p) {
        "undefined" === typeof e && (e = 1);
        "undefined" === typeof b && (b = 16777215);
        c.lineStyle(e,
            d, 11);
        c.beginFill(b);
        c.moveTo(g, -a);
        b = g + Math.cos(p) * this.game.width;
        d = a + Math.sin(p) * this.game.height;
        c.lineTo(b, -d);
        c.moveTo(g, -a);
        b = g + Math.cos(p) * -this.game.width;
        d = a + Math.sin(p) * -this.game.height;
        c.lineTo(b, -d)
    },
    randomPastelHex: function() {
        var c, g, a, b;
        a = [255, 255, 255];
        b = Math.floor(256 * Math.random());
        g = Math.floor(256 * Math.random());
        c = Math.floor(256 * Math.random());
        b = Math.floor((b + 3 * a[0]) / 4);
        g = Math.floor((g + 3 * a[1]) / 4);
        c = Math.floor((c + 3 * a[2]) / 4);
        return this.rgbToHex(b, g, c)
    },
    rgbToHex: function(c, g, a) {
        return this.componentToHex(c) +
            this.componentToHex(g) + this.componentToHex(a)
    },
    componentToHex: function(c) {
        c = c.toString(16);
        return 2 === c.len ? c : c + "0"
    }
});
Phaser.Physics.P2.Spring = function(c, g, a, b, d, e, f, h, k, p) {
    this.game = c.game;
    this.world = c;
    "undefined" === typeof b && (b = 1);
    "undefined" === typeof d && (d = 100);
    "undefined" === typeof e && (e = 1);
    b = c.pxm(b);
    b = {
        restLength: b,
        stiffness: d,
        damping: e
    };
    "undefined" !== typeof f && null !== f && (b.worldAnchorA = [c.pxm(f[0]), c.pxm(f[1])]);
    "undefined" !== typeof h && null !== h && (b.worldAnchorB = [c.pxm(h[0]), c.pxm(h[1])]);
    "undefined" !== typeof k && null !== k && (b.localAnchorA = [c.pxm(k[0]), c.pxm(k[1])]);
    "undefined" !== typeof p && null !== p && (b.localAnchorB = [c.pxm(p[0]), c.pxm(p[1])]);
    p2.Spring.call(this, g, a, b)
};
Phaser.Physics.P2.Spring.prototype = Object.create(p2.Spring.prototype);
Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;
Phaser.Physics.P2.Material = function(c) {
    this.name = c;
    p2.Material.call(this)
};
Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);
Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;
Phaser.Physics.P2.ContactMaterial = function(c, g, a) {
    p2.ContactMaterial.call(this, c, g, a)
};
Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);
Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;
Phaser.Physics.P2.CollisionGroup = function(c) {
    this.mask = c
};
Phaser.Physics.P2.DistanceConstraint = function(c, g, a, b, d) {
    "undefined" === typeof b && (b = 100);
    this.game = c.game;
    this.world = c;
    b = c.pxm(b);
    p2.DistanceConstraint.call(this, g, a, b, {
        maxForce: d
    })
};
Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);
Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;
Phaser.Physics.P2.GearConstraint = function(c, g, a, b, d) {
    "undefined" === typeof b && (b = 0);
    "undefined" === typeof d && (d = 1);
    this.game = c.game;
    this.world = c;
    p2.GearConstraint.call(this, g, a, {
        angle: b,
        ratio: d
    })
};
Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);
Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;
Phaser.Physics.P2.LockConstraint = function(c, g, a, b, d, e) {
    "undefined" === typeof b && (b = [0, 0]);
    "undefined" === typeof d && (d = 0);
    "undefined" === typeof e && (e = Number.MAX_VALUE);
    this.game = c.game;
    this.world = c;
    b = [c.pxm(b[0]), c.pxm(b[1])];
    p2.LockConstraint.call(this, g, a, {
        localOffsetB: b,
        localAngleB: d,
        maxForce: e
    })
};
Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);
Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;
Phaser.Physics.P2.PrismaticConstraint = function(c, g, a, b, d, e, f, h) {
    "undefined" === typeof b && (b = !0);
    "undefined" === typeof d && (d = [0, 0]);
    "undefined" === typeof e && (e = [0, 0]);
    "undefined" === typeof f && (f = [0, 0]);
    "undefined" === typeof h && (h = Number.MAX_VALUE);
    this.game = c.game;
    this.world = c;
    d = [c.pxmi(d[0]), c.pxmi(d[1])];
    e = [c.pxmi(e[0]), c.pxmi(e[1])];
    p2.PrismaticConstraint.call(this, g, a, {
        localAnchorA: d,
        localAnchorB: e,
        localAxisA: f,
        maxForce: h,
        disableRotationalLock: !b
    })
};
Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);
Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;
Phaser.Physics.P2.RevoluteConstraint = function(c, g, a, b, d, e) {
    "undefined" === typeof e && (e = Number.MAX_VALUE);
    this.game = c.game;
    this.world = c;
    a = [c.pxmi(a[0]), c.pxmi(a[1])];
    d = [c.pxmi(d[0]), c.pxmi(d[1])];
    p2.RevoluteConstraint.call(this, g, a, b, d, {
        maxForce: e
    })
};
Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);
Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint;